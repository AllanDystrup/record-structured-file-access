XC ... 'C' Concordance Utility   KEY.c                      Page 1

1       1: /*+1========================================================================*/
2       2: /*   MODULE                       KEY.C                                     */
3       3: /*==========================================================================*/
4       4: /*   FUNCTION  Provides key-based access to key'ed, flat datafiles.
5       5:  *
6       6:  *             The module offers an object oriented program interface (API)
7       7:  *             to BASIC INFORMATION stored on disk in one or more flat
8       8:  *             DATAFILEs (sequential records of variable length, identified
9       9:  *             by a unique key: a fixed length string starting in 1. record-
10     10:  *             position), each with an associated INDEXFILE (mapping a key-
11     11:  *             value to a datafile offset for each datarecord); An keyfile
12     12:  *             may be generated from a datafile using the module key.c
13     13:  *
14     14:  *             The purpose of the key.c module is twofold :
15     15:  *              1  to implement a set of fast and reliable routines for the
16     16:  *                 general "low level" ACCESS to basic disk-information (ie.
17     17:  *                 file-access, caching and buffering operations), which is
18     18:  *                 typically a common requirement for several modules in the
19     19:  *                 same application (keyword: reuse).
20     20:  *              2  to hide the technical details of the implementation below
21     21:  *                 a general, easy-to-use application program interface / API
22     22:  *                 (keyword: data abstraction); - The key.c API allows the
23     23:  *                 user to access the basic information as very simple "data-
24     24:  *                 base(s)", using :
25     25:  *                  -  an abstract datastructure to represent each database
26     26:  *                     OBJECT (consisting of a data- & key-file w. attached
27     27:  *                     "in core" descriptor structures, plus a cache-array for
28     28:  *                     datarecord offsets and a buffer object for datarecords)
29     29:  *                  -  public interface FUNCTIONS for open-, read- and close-
30     30:  *                     operations on the database objects.
31     31:  *
32     32:  *              Some good reasons for NOT using a more general database product
33     33:  *              to satisfy these simple objectives are :
34     34:  *               1  commercial database products (as for instance "c-tree" by
35     35:  *                  FairCom Corp.) typically have a much "broader" functio-
36     36:  *                  nality, - which does also imply a more complex design,
37     37:  *                  a greater appetite for RAM and an inferior performance.
38     38:  *               2  why should your application depend on yet another product
39     39:  *                  (technically and economically) to fulfill just a simple
40     40:  *                  dataaccess requirement ?
41     41:  *
42     42:  *   SYSTEM     Standard (ANSI/ISO) C,
43     43:  *              Tested on PC/MS DOS V3.3 (MSC 600A) & UNIX SYS V.3 (GNU GCC).
44     44:  *
45     45:  *   SEE ALSO   Modules : GENERAL.H, KEY.H
46     46:  *
47     47:  *   PROGRAMMER Allan Dystrup
48     48:  *
49     49:  *   COPYRIGHT  (c) Allan Dystrup, Kommunedata I/S, may 1992
50     50:  *
51     51:  *   VERSION    $Header: d:/cwork/soul1/RCS/key.c 0.1 92/09/14 10:05:58
52     52:  *              Allan_Dystrup PREREL Locker: Allan_Dystrup $
53     53:  *              --------------------------------------------------------------
54     54:  *              $Log:	key.c $
55     55:  *              Revision 0.1  92/09/14  10:05:58  Allan_Dystrup
56     56:  *              PREREL (ALFA1)

XC ... 'C' Concordance Utility   KEY.c                      Page 2

57     57:  *
58     58:  *   REFERENCES The concept of abstract data types is probably familiar; -
59     59:  *              If you want an introduction, consider :
60     60:  *              Azmoodeh, Manoochehr[1990]: "Abstract Data Types and Algorithms",
61     61:  *                 Macmillan Education Ltd., London (2.Ed) 
62     62:  *
63     63:  *   USAGE      Module key.c provides a "high level" interface for fast
64     64:  *              access to simple "DATABASE OBJECTS", each consisting of : 
65     65:  *              1: a DATAFILE on disk, - a flat/sequential file with variable
66     66:  *                 length records identified by unique key-values,
67     67:  *              2: an INDEXFILE on disk, - a table mapping each keyvalue to
68     68:  *                 the corresponding record-offset in the datafile,
69     69:  *              3: a DESCRIPTOR structure in memory, - a datastructure
70     70:  *                 maintained by module key.c for each database object,
71     71:  *                 coupling the data- & key-file with a cache-array for
72     72:  *                 datafile-offsets and a buffer for retrieving datarecords.
73     73:  *                 (The buffer may be shared by multiple DESCRIPTOR structs.)
74     74:  *
75     75:  *              The API offered by module key.c consists of 3 functions for
76     76:  *              accessing a key'ed flat datafile through a key.c DESCRIPTOR :
77     77:  *                 eKeyDBOpen()  // Open a database object (instantiate descr.)
78     78:  *                 eKeyDBClose() // Close a database object (release descr.)
79     79:  *                 eKeyDBRead()  // Read a database object in two steps :
80     80:  *                               // 1: build an offset-cache from a key-list.
81     81:  *                               // 2: fill/scroll a data-buffer from the cache
82     82:  *
83     83:  *              The user is expected to provide any application-specific
84     84:  *              functions such as displaying the databuffer contents on VDU
85     85:  *              (within the framework of the application's presentation method,
86     86:  *              be it text-based or a more sophisticated GUI as Cscape or Panel).
87     87:  *
88     88:  * DOC         Documentation is incorporated into the module and may be
89     89:  *             selectively extracted (using a utility such as ex.awk) :
90     90:  *                Level 1: Module documentation (history, design, testdriver)
91     91:  *                Level 2: PUBLIC functions (module program interface, "API")
92     92:  *                Level 3: major PRIVATE functions (design)
93     93:  *                Level 4: minor PRIVATE functions (support)
94     94:  *
95     95:  * BUGS        The module is coded in STANDARD C (ANSI/ISO), which is a
96     96:  *             feature! -  It is however prepared to compile under "old"
97     97:  *             K&R C (if you prefer bugs ...)
98     98:  *
99     99:  *
100   100:  * ========================== MODULE STRUCTURE ===============================
101   101:  *
102   102:  *                            Data model
103   103:  *   To define a database object in memory we need a descriptor datastructure
104   104:  *   for connecting the data- & key-fileptr's with a cache array of datafile
105   105:  *   offsets. The buffer for datarecords is defined as a separate structure,
106   106:  *   so the same buffer may be reused by several "databases".
107   107:  *
108   108:  *   (1) Database descriptor :
109   109:  *
110   110:  *                           RAM (incore)
111   111:  *                           struct stDataBase DBASE
112   112:  *                           +------------------+

XC ... 'C' Concordance Utility   KEY.c                      Page 3

113   113:  *                 +---------- CACHE   stCache  | cache datastructure
114   114:  *                 |         | FILE    *fpData  | data file pointer
115   115:  *                 |         | ITYPE   pIndex  -----------+ handle for key 
116   116:  *                 |         +------------------+         | 
117   117:  *                 |                                      | Compile switch : 
118   118:  *     RAM (incore)                                       | -DVA: ITYPE= VACB
119   119:  *     struct stKeyCache CACHE                            | -DSS: ITYPE= HASH
120   120:  *     +-------------------+ Ptr to array of offsets      | 
121   121:  *     | DWORD (*padwData)[]--->[ malloc'ed area ]        |
122   122:  *     |                   |                              |
123   123:  *     | DWORD  dwCsize    | max. entries in array        |             
124   124:  *     | DWORD  dwCused    | used entries in array        |          
125   125:  *     | DWORD  dwCbwin[2] | range of array in buffer     |                  
126   126:  *     +-------------------+                              |
127   127:  *                                                        |
128   128:  *                                               RAM (incore)
129   129:  *                                               struct ... ITYPE 
130   130:  *                                               +---------------------+
131   131:  *                            open mode [RO|RW]  | enum      keymode   |
132   132:  *                            key file pointer   | FILE      *fpIndex  | 
133   133:  *                                     +---------- SIZEINFO  stSize    |
134   134:  *                                     |         |<Cf. va.h and ss.h>  |
135   135:  *                                     |         +---------------------+
136   136:  *                         RAM (incore)
137   137:  *                         struct ... SIZEINFO
138   138:  *                         +---------------------+
139   139:  *                         |<Cf. va.h and ss.h>  |
140   140:  *                         +---------------------+
141   141:  *
142   142:  *
143   143:  *
144   144:  *   (2) Data buffer:
145   145:  *                           RAM (incore)
146   146:  *                           struct stDataBuffer BUFFER
147   147:  *                           +----------------+
148   148:  *                           | char  *pzBaddr | Ptr to buffer area 
149   149:  *                           | WORD  wBsize   | Size of buffer area
150   150:  *                           +----------------+  
151   151:  *
152   152:  *
153   153:  *
154   154:  *                           Function decomposition
155   155:  *   The key-module functions to access these datastructures may be grouped
156   156:  *   into two levels and three seperate categories :
157   157:  *   ( 1 ) API functions providing an external interface for calling modules
158   158:  *   (2.1) Functions operating internally on the CACHE datastructure,
159   159:  *   (2.2) Functions operating internally on the BUFFER datastructure.
160   160:  *   Thus the low-level CACHE & BUFFER functions (level 2) handle the direct
161   161:  *   access to files and "incore" descriptor structures, but these internal
162   162:  *   functions are wrapped in a high-level API (level 1) offering the basic
163   163:  *   operations of opening, reading and closing an abstract "database" object.
164   164:  *   An application (level 0) will call on the KEY API for data access, and
165   165:  *   typically introduce further functionality for user interaction (ie. data
166   166:  *   selection and buffer display).
167   167:  *
168   168:  *   The main calling hierachy is outlined in the following diagram, where

XC ... 'C' Concordance Utility   KEY.c                      Page 4

169   169:  *   the signatures -> and <- indicate input resp. output parameters, and
170   170:  *   the signature (__) represents repetition.
171   171:  *
172   172:  *   .........................................................................
173   173:  *   LEVEL 0
174   174:  *   APPLICATION
175   175:  *   (example)                  main  
176   176:  *                                |
177   177:  *             +------------------+-------------------+
178   178:  *             |                  |                   |
179   179:  *             |             eKeyDBAccess             |
180   180:  *             |                  |                   |
181   181:  *             |            eKeyListScroll            |
182   182:  *             |             |    |    |              |
183   183:  *             |            (___________)             |
184   184:  *             |             |    |   |               |
185   185:  *             |        getchar   |  eKeyBufDump      |
186   186:  *             |                  |                   |
187   187:  *   ..........|..................|...................|.......................
188   188:  *   LEVEL 1   |                  |                   |
189   189:  *   KEY API   |                  |                   |
190   190:  *             |                  |                   |
191   191:  *      eKeyDBOpen            eKeyDBRead          eKeyDBClose
192   192:  *                              /     \
193   193:  *                             |       |
194   194:  *      -> [K_LIST | K_EXPR]   |       |  -> (initialized cache)
195   195:  *      <- (initialized cache) |       |  <- (filled buffer)
196   196:  *                          __/\__     |___________________
197   197:  *                          | \/ |                        |
198   198:  *                   K_EXPR |    | K_LIST                 |
199   199:  *   .......................|....|........................|...................
200   200:  *   LEVEL 2                |    |                        | 
201   201:  *   KEY LOW-LEVEL          |    |                        | 
202   202:  *                          |    |                        | 
203   203:  *          +<--------------+    |                        |
204   204:  *          |                    |                        |
205   205:  *          |   +<---------------+                        |
206   206:  *          |   |                                         |
207   207:  *          |   |  (2.1) CACHE              (2.2) BUFFER  |
208   208:  *          |   |                                         |
209   209:  *          |   |  ->(keylist)                            |
210   210:  *          |   |  <-(cache)                              |
211   211:  *          |   +->eKeyCacheFill------------>eKeyBufScan  |
212   212:  *          |                |                            |
213   213:  *          |   +------------+                            |
214   214:  *          |   |                                         |
215   215:  *          |   +->eKeyCacheFree                          |
216   216:  *          |   |                                         |
217   217:  *          |   +->eKeyCacheAlloc                         |
218   218:  *          |                                        eKeyBufFill
219   219:  *          |
220   220:  *          |      ->(cache,pattern)
221   221:  *          |      <-(new cache)
222   222:  *          +----->eKeyCacheSearch --------->eKeyBufRead
223   223:  *                           |                          
224   224:  *   ........................|................................................

XC ... 'C' Concordance Utility   KEY.c                      Page 5

225   225:  *   LEVEL 3                 |
226   226:  *   SEARCH SERVICE          |
227   227:  *                           |               GENERIC SEARCH              
228   228:  *                           |
229   229:  *                           +-------------->(*pvBldSearch)()
230   230:  *                                           (*pfRunSearch)()
231   231:  *                                           (*pvDelSearch)()
232   232:  *                                           ----------------
233   233:  *                                                  |
234   234:  *                                           SPECIFIC SEARCH
235   235:  *                                        one of several methods
236   236:  *                                          cf. search modules
237   237:  *
238   238:  *-1========================================================================*/
239   239: 
240   240: 
241   241: 
242   242: /*==========================================================================*/
243   243: /*                                Includes                                  */
244   244: /*==========================================================================*/
245   245: 
246   246: /* ANSI X3J11 / ISO JTC1 SC22 WG14 Standard C headerfiles */
247   247: #include   <stdlib.h>
248   248: #include   <stdio.h>
249   249: #include   <malloc.h>
250   250: #include   <signal.h>
251   251: #include   <string.h>                                         
252   252: #include   <ctype.h>
253   253: #include   <math.h>
254   254: 
255   255: /* #define S/H-DEBUG: runtime check of stack- and heap on DOS  */
256   256: /* Relies on PC/MS DOS V.3.3 system files which are deprecated */
257   257: //#include "UTIL/chk/stck/stck.h"
258   258:    # define STCK(x)
259   259:    # define REAL_MAIN	main
260   260: //#include "UTIL/chk/hpck/hpck.h"
261   261: 
262   262: 
263   263: /* Project headerfile, w. PUBLIC errormacros, datastructures & functions */
264   264: #define    _KEY_ALLOC
265   265: #include   "key.h"
266   266: 
267   267: 
268   268: /*==========================================================================*/
269   269: /*                      (PRIVATE) Function prototypes                       */
270   270: /*==========================================================================*/
271   271: 
272   272: /* Main */
273   273: #ifdef MAIN
274   274: PRIVATE   eRetType
275   275:           eKeyDBAccess P((DBASE *pstDBx, BUFFER *pstBF, char *pzKlist));
276   276: 
277   277: PRIVATE   eRetType
278   278:           eKeyListScroll P((DBASE * pstDBx, BUFFER * pstBF));
279   279: 
280   280: PRIVATE   void 

XC ... 'C' Concordance Utility   KEY.c                      Page 6

281   281:           vSigCatch P((int vSigNum));
282   282: #endif
283   283: 
284   284: 
285   285: /* Cache */
286   286: PRIVATE   eRetType
287   287:           eKeyCacheFill P((DBASE * pstDBx, char *pzKeyList));
288   288: 
289   289: PRIVATE   eRetType
290   290:           eKeyCacheSearch P((DBASE * pstDBx, BUFFER * pstBF));
291   291: 
292   292: PRIVATE   eRetType
293   293:           eKeyCacheAlloc P((CACHE * pstCache, double rResize));
294   294: 
295   295: PRIVATE   eRetType
296   296:           eKeyCacheFree P((CACHE * pstCache));
297   297: 
298   298: 
299   299: /* Buffer */
300   300: PRIVATE   eRetType
301   301:           eKeyBufScan P((DBASE * pstDBx, char **ppzKeyList, char **ppzKeyStr));
302   302: 
303   303: PRIVATE   eRetType
304   304:           eKeyBufFill P((DBASE * pstDBx, BUFFER * pstBF, DWORD(*dwCbwinNew)[]));
305   305: 
306   306: PRIVATE   eRetType
307   307:           eKeyBufRead P((FILE *fpData, BUFFER *pstBF, DWORD *dwDRec));
308   308: 
309   309: 
310   310: /* Utility/Debug */
311   311: #ifdef DEBUG
312   312: PRIVATE   eRetType
313   313:           eKeyDBDump P((DBASE * pstDBx, BUFFER * pstBF));
314   314: 
315   315: PRIVATE   eRetType
316   316:           eKeyIndexDump P((DBASE * pstDBx));
317   317: 
318   318: PRIVATE   eRetType							    
319   319:           eKeyCacheDump P((DBASE * pstDBx, int fAll));
320   320: 
321   321: PRIVATE   eRetType
322   322:           eKeyRecDump P((char *key, DWORD dwFileOffset));
323   323: 
324   324: PRIVATE   eRetType
325   325:           eKeyDatDump P((FILE * fdDataFile, DWORD dwFileOffset));
326   326: #endif /* DEBUG */
327   327: 
328   328: 
329   329: 
330   330: 
331   331: #ifdef MAIN
332   332: /****************************************************************************/
333   333: /******************************** MAIN **************************************/
334   334: /****************************************************************************/
335   335: /*+1*/
336   336: 

XC ... 'C' Concordance Utility   KEY.c                      Page 7

337   337: /* 1: Set up nessecary variables (cf. datastructures defined in key.h)  */
338   338: 
339   339: /* Hard coded file names for data- & key-file (test):   */
340   340: /*    Format of data file name: must be [xxxxxxxx.dat]  */
341   341: /*    Default index file is then format [xxxxxxxx.idx]  */
342   342: PRIVATE char pzDat12[] = "soul.dat";	/* Name of datafile for DB 1&2 */
343   343: PRIVATE char pzIdx2[] = "soul2.idx";	/* Name of keyfile for DB 2 */
344   344: 
345   345: /* Two incore descriptors, one for each database (here DB1 & DB2) */
346   346: PRIVATE DBASE stDB1;           /* "Incore" descriptor for database1 */
347   347: PRIVATE DBASE stDB2;           /* "Incore" descriptor for database2 */
348   348: 
349   349: /* One incore descriptor for buffer, shared by database 1 & 2 */
350   350: PRIVATE BUFFER stBF;           /* "Incore" descriptor for (shared) buffer */
351   351: /* #define BUFLEN (5*1024) */  /* Length of realistic buffer for data-rec's */
352   352: #define BUFLEN    (512)        /* Length of test buffer for data-records */
353   353: 
354   354: /* Define "signon message" for key lookup testdriver */
355   355: PRIVATE const char SIGNON[] =
356   356:    "\nKMD Index access testdriver, Version 0.1.0\n"
357   357:    "MOD[key.c] VER[0.1.0 Pre] DAT[92/07/10] DEV[ad dec]\n"
358   358:    "Copyright (c) KommuneData I/S 1992\n\n";
359   359: 
360   360: 
361   361: 
362   362: 
363   363: /*== MODULE KEY.C ==========================================================*/
364   364: /*   NAME   01                    REAL_MAIN()                               */
365   365: /*== SYNOPSIS ==============================================================*/
366   366: int 
367   367: REAL_MAIN(argc, argv, envp)
368   368:   int argc;                    /* Argument count */
369   369:   char *argv[];                /* Argument vector */
370   370:   char *envp[];                /* Environment pointer */
371   371: {
372   372: /* DESCRIPTION
373   373:  *    Demoprogram and testdriver for module "key.c".
374   374:  *    The function demonstrates the proper use of datastructures and
375   375:  *    public functions declared in key.h and defined in key.c.
376   376:  *    (REAL_MAIN() is called from main() in stck.obj, - a module providing
377   377:  *    stack checking services; - you can safely ignore this debugging feature)
378   378:  *
379   379:  *    1: *DECLARE* variables for use as params to the functions in module key.c;
380   380:  *       For each "database" x (ie. key'ed flat data-file) to use, declare :
381   381:  *        - one  DBASE stDBx    to access the cache, key-file, and data-file
382   382:  *        - one  char pzDatx[]  initialized to name of the datafile, eg "datax.dat"
383   383:  *        - one  char pzIdxx[]  initialized to name of the keyfile;
384   384:  *                              If pzIdxx==NULL, the name is default "datax.idx"
385   385:  *                              otherwise a filename must be passed as parameter.
386   386:  *       For retrieving data-records from the datafile, declare :
387   387:  *        - one  BUFFER stBF    to hold the data-records in RAM; This variable
388   388:  *                              may be shared between multiple "databases".
389   389:  *
390   390:  *       The variables of the demo-program are declared with global scope,
391   391:  *       to make them accessible from the exception handler : vSigCatch()
392   392:  *

XC ... 'C' Concordance Utility   KEY.c                      Page 8

393   393:  *    2: *OPEN* each "database" before access by calling :
394   394:  *       eKeyDBOpen(&stDBx, pzDatx, pzIdxx, &stBF, <pzDatBuf>, <iBufLen>)
395   395:  *       This will allocate and initialize "incore" descriptors for the
396   396:  *       "database's" buffer, cache, key-file and data-file, as well as
397   397:  *       open the key- and data-file.
398   398:  *       The initialization of a databuffer (stBF) may be done in three ways :
399   399:  *       As the third pameter to eKeyDBOpen() you may pass :
400   400:  *        - &stBF  the address of a BUFFER struct. variable to initialize;
401   401:  *                 In this case the last two param's may take on the values :
402   402:  *                  - NULL,  BUFLEN  enthrust eKeyDBOpen() to allocate dataarea
403   403:  *                  - pzBuf, BUFLEN  pass ptr to an already allocated dataarea
404   404:  *                 In both cases BUFLEN is a #define'd constant for the length
405   405:  *                 of the buffer dataarea (# byte).
406   406:  *        - NULL   to omit initialization of a new buffer structure.
407   407:  *                 (if your intention is to reuse an already allocated buffer)
408   408:  *
409   409:  *    3: You may now *ACCESS* the "databases", that have been opened;
410   410:  *        1 first copy a comma-separated key-list to the buffer
411   411:  *        2 then call eKeyDBRead(&stDBx, &stBF, K_LIST, 0) to set up a cache,
412   412:  *          ie. array of datafile offests, for the keylist (using the key)
413   413:  *        3 finally call eKeyDBRead(&stDBx, &stBF, <position>, <records>) to
414   414:  *          read datarecords from the datafile to your buffer using cache-
415   415:  *          lookup operations; in the last two parameters to eKeyDBRead you
416   416:  *          pass an key-range (a "window") in the cache-array specifying the
417   417:  *          datarecords to retrieve: cache[position] - cache[position+records-1]
418   418:  *        4 Several symbolic constants have been #define'd to simplify scrol-
419   419:  *          ling the buffer-window through the cache (cf. eKeyListScroll()).
420   420:  *       This retrieval of datarecords via the cache, as well the whole
421   421:  *       procedure of keylist-/cache-setup and data read may be repeated
422   422:  *       as required by your application.
423   423:  *
424   424:  *    4: When you don't need a "database" any more (for instance before
425   425:  *       exiting your program!), you MUST *CLOSE* the "database" gracefully :
426   426:  *        - call eKeyDBClose(&stDBx, &stBF) to deallocate all "incore"
427   427:  *          descriptors and close the key- and data-files.
428   428:  *          If &stBF is set to NULL, eKeyDBClose() will not deallocate the
429   429:  *          databuffer structure, which may thus "survive" for subsequent use
430   430:  *          by other open "databases".
431   431:  *
432   432:  * RETURN
433   433:  *   REAL_MAIN() is a testdriver and not intented to interface with
434   434:  *   any calling program. The return value from REAL_MAIN() is thus
435   435:  *   insignificant in this context.
436   436:  *   You should however notice the checking of error-conditions on return
437   437:  *   from each call to a PUBLIC function defined in key.c; - This practice
438   438:  *   should also be followed in your application to "catch" and diagnose any
439   439:  *   malfunction in the system or in the services provided by this module.
440   440:  *   (You will probably want to write your own error-handling, though).
441   441:  *
442   442:  * EXAMPLE
443   443:  *   The contents of function REAL_MAIN() and the support-functions 
444   444:  *   eKeyDBAccess() and eKeyListScroll() constitute a self-contained
445   445:  *   main-program demonstrating the proper use of public data-structures
446   446:  *   and interface-functions in key.c.
447   447:  *
448   448:  * SEE ALSO

XC ... 'C' Concordance Utility   KEY.c                      Page 9

449   449:  *   - key.h for a detailed description of symbolic constants, macro's,
450   450:  *     data structures, return codes and error codes,
451   451:  *   - key.c/h  for a description of how the keyfile is generated from
452   452:  *     the datafile, using one of several available access methods.
453   453:  */
454   454: 
455   455:     /* 1: *DECLARE* : setup of variables for data- & key-access */
456   456:     /* DONE IN GLOBAL SCOPE */
457   457:     stDB1.fdData = stDB2.fdData = NULL;
458   458:     stDB1.pIndex = stDB2.pIndex = NULL;
459   459: 
460   460: 
461   461:     /* Signon and Setup to redirect interrupt signals to our own handler */
462   462:     fputs(SIGNON, stdout);
463   463: 
464   464:     (void) signal(SIGINT, vSigCatch);
465   465:     (void) signal(SIGTERM, vSigCatch);
466   466: 
467   467: 
468   468:     /*-DBASE 1--------------------------------------------------------------*/
469   469:     /* 2: *OPEN* database 1 (instantiate incore descriptor stDB1)           */
470   470:     /* Use default keyname (soul.idx), and let system allocate bufferarea */
471   471:     KCHK_ERR(eKeyDBOpen(&stDB1, pzDat12, NULL, &stBF, NULL, BUFLEN), K_STOP)
472   472:     D(eKeyIndexDump(&stDB1));
473   473: 
474   474:     /* 3: *ACCESS* database 1; define keylist, sHetup cache, retrieve rec's. */
475   475:     eKeyDBAccess(&stDB1, &stBF, "20200-20202,20203,20204-20206,20207,2099#-");
476   476: 
477   477: 
478   478:     /*-DBASE 2--------------------------------------------------------------*/
479   479:     /* 2: *OPEN* database 2 (instantiate incore descriptor stDB2)           */
480   480:     /* Use keyname "soul2.idx",and reuse already allocated buffer struct. */
481   481:     KCHK_ERR(eKeyDBOpen(&stDB2, pzDat12, pzIdx2, (BUFFER *) NULL, (char *) NULL, 0), K_STOP)
482   482:     D(eKeyIndexDump(&stDB2));
483   483: 
484   484:     /* 3: *ACCESS* database 2; define keylist, setup cache, retrieve rec's. */
485   485:     eKeyDBAccess(&stDB2, &stBF, "50###-");
486   486: 
487   487:     /* 4: *CLOSE* database 2, but let the buffer survive for use by stDB1 */
488   488:     KCHK_ERR(eKeyDBClose(&stDB2, NULL), K_STOP)
489   489:     D(eKeyDBDump(&stDB2, &stBF));
490   490: 
491   491: 
492   492:     /*-DBASE 1--------------------------------------------------------------*/
493   493:     /* 3: *ACCESS* database 1; define keylist, setup cache, retrieve recs */
494   494:     eKeyDBAccess(&stDB1, &stBF, "60000-69999");
495   495: 
496   496:     /* 4: *CLOSE* database 1, including the buffer (prev shared with stDB2) */
497   497:     KCHK_ERR(eKeyDBClose(&stDB1, &stBF), K_STOP)
498   498:     D(eKeyDBDump(&stDB1, &stBF));
499   499: 
500   500: 
501   501:     /* Function complete : return ok */
502   502:     STCK("REAL_MAIN");
503   503:     return (OK);
504   504: 

XC ... 'C' Concordance Utility   KEY.c                      Page 10

505   505: } /* END function REAL_MAIN() */
506   506: /*-1*/
507   507: 
508   508: 
509   509: 
510   510: /*+4 MODULE KEY.C ----------------------------------------------------------*/
511   511: /*   NAME   02.1               vSigCatch                                    */
512   512: /*-- SYNOPSIS --------------------------------------------------------------*/
513   513: PRIVATE  void 
514   514: vSigCatch(iSigNum)
515   515:    int iSigNum;
516   516: {
517   517: /* DESCRIPTION
518   518:  *    Support function for REAL_MAIN() test driver, - (cf. REAL_MAIN, pt.1).
519   519:  *    Signal handler set up to catch the "break" signals : SIGINT (asynch.
520   520:  *    interactive attention) & SIGTERM (asynch. interactive termination).
521   521:  * RETURN
522   522:  *    Open databases closed & program terminated with exit code 'EXIT_FAILURE'.
523   523:  * BUGS
524   524:  *    The REAL_MAIN() test driver is dialog intensive, so we can't prompt the
525   525:  *    user for an abortion confirmation (interrupting a C-library(DOS) I/O-
526   526:  *    routine with a new I/O-request will *NOT* work due to non-reentrancy).
527   527:  *-4*/
528   528:       /* Close all open databases */
529   529:       fputs("\nINTERRUPT:\n\a", stderr); 
530   530:       fprintf(stderr, "\tSignal [%d] received\n", iSigNum);
531   531:       fputs("\tCleaning up...\n", stderr);
532   532:       eKeyDBClose(&stDB1, &stBF);
533   533:       eKeyDBClose(&stDB2, NULL);
534   534: 
535   535:       /* Quit test driver */
536   536:       fputs("\tBailing out...\n", stderr);
537   537:       exit(EXIT_FAILURE);
538   538: 
539   539: } /* END function vSigCatch() */
540   540: 
541   541: 
542   542: 
543   543: /*+1 MODULE KEY.C ----------------------------------------------------------*/
544   544: /*   NAME   02.2               eKeyDBAccess                                 */
545   545: /*-- SYNOPSIS --------------------------------------------------------------*/
546   546: PRIVATE eRetType
547   547: eKeyDBAccess(pstDBx, pstBF, pzKlist)
548   548:    DBASE  *pstDBx;             /* Ptr to DBASE structure (w. cache array) */
549   549:    BUFFER *pstBF;              /* Ptr to BUFFER structure for data-rec's  */
550   550:    char   *pzKlist;            /* Ptr to list of key values for retrieval */
551   551: {
552   552: /* DESCRIPTION
553   553:  *    Support function for REAL_MAIN() test driver, - (cf. REAL_MAIN, pt.3).
554   554:  *    Access the database <pstDBx> using buffer <pstBF> and keylist <pzKlist>; 
555   555:  *    1-2: Parse keylist <pzKlist> and setup cache using eKeyDBRead(). 
556   556:  *     3 : Retrieve datarecords from file to buffer <pstBF> using eKeyDBRead().
557   557:  *     4 : Display cach'd datarecords using the simple eKeyListScroll() func.;
558   558:  *         The display func. will call eKeyDBRead() as needed to refill <pstBF>
559   559:  * RETURN
560   560:  *    Void (but errors checked inside function using the KCHK_ERR macro)

XC ... 'C' Concordance Utility   KEY.c                      Page 11

561   561:  */
562   562:     /* 1: Copy comma-separated keylist <pzKlist> to start of buffer */
563   563:     (void) strcpy(pstBF->pzBaddr, pzKlist);
564   564:     D(eKeyBufDump(pstBF, TRUE));
565   565: 
566   566:     /* 2: Setup dataoffset cache for <pstDBx> (from keylist in buffer) */
567   567:     KCHK_ERR(eKeyDBRead(pstDBx, pstBF, K_LIST, 0L), K_STOP)
568   568:     D(eKeyCacheDump(pstDBx, TRUE));
569   569: 
570   570:     /* 3: Retrieve all datarecords from the cache (up to the buffer limit) */
571   571:     KCHK_ERR(eKeyDBRead(pstDBx, pstBF, 1L, K_ALL), K_CONT)
572   572:     D(eKeyBufDump(pstBF, TRUE));
573   573: 
574   574:     /* 4: Scroll through the cache (ie. keylist), using simple KBD commands */
575   575:     KCHK_ERR(eKeyListScroll(pstDBx, pstBF), K_CONT)
576   576:     KRET_OK
577   577: } /* END function eKeyDBAccess() */
578   578: /*-1*/
579   579: 
580   580: 
581   581: 
582   582: /*+1 MODULE KEY.C ----------------------------------------------------------*/
583   583: /*   NAME   02.3               eKeyListScroll                               */
584   584: /*-- SYNOPSIS --------------------------------------------------------------*/
585   585: PRIVATE   eRetType
586   586: eKeyListScroll(pstDBx, pstBF)
587   587:     DBASE    *pstDBx;	       /* Pointer to DBASE structure w. cache array  */
588   588:     BUFFER   *pstBF;	       /* Pointer to BUFFER structure for data-rec's */
589   589: {
590   590: /* DESCRIPTION
591   591:  *    Support function for REAL_MAIN() test driver, called from eKeyDBAccess().
592   592:  *    Demonstrate and test the various parameters allowed by eKeyDBRead() for
593   593:  *    setting up and scrolling through a cache array.
594   594:  *
595   595:  *    LOOP prompt & get input ...
596   596:  *    0:  Set up "shorthand" var.'s for easy access to the cache bufferwindow.
597   597:  *    1:  Prompt for input (a char code) defining a reset of the bufferwindow.
598   598:  *    2:  Get input (a char code) from stdin, and dispatch to eKeyDBRead() to
599   599:  *        perform the actual cache reset, buffferwindow reset and databuffer
600   600:  *        fill operations
601   601:  *    3:  Call eKeyBufDump() to write the contents of the databuffer to stdout.
602   602:  *    WHILE (input not "QUIT")
603   603:  *
604   604:  * RETURN
605   605:  *    Side effects ........: Depending on input-codes from user/stdin ...
606   606:  *     - reset of cache-array (user entering a new key-list or key-expression)
607   607:  *     - reset of cache buf.window (user entering new window-pos. &/ -size)
608   608:  *     - fill of the buffer area (cf. cache slots currently in the buf.window)
609   609:  *    Function return value: OK if operation succeeded, ERROR otherwise; -
610   610:  *                           If ERROR, "Kstat" holds the precise error code.
611   611:  */
612   612:     register int iAnswer= 'H'; /* Answer entered by user (via keyboard) */
613   613:     DWORD      dwWin[2];       /* Buffer window into cache array : TOP-BOT */
614   614:     DWORD      dwSiz    = 0L;  /* Current size of buf.window */
615   615:     DWORD      dwMax    = 0L;  /* Maximal size of buf.window */
616   616:     DWORD      dwSetPos = 0L;  /* For entering new pos. of buf.window */

XC ... 'C' Concordance Utility   KEY.c                      Page 12

617   617:     DWORD      dwSetSiz = 0L;  /* For entering new size of buf.window */
618   618: 
619   619: 
620   620:     /* Scroll through list of datarecords */
621   621:     do {
622   622: 	/* 0: Initialize shorthand var's */
623   623: 	dwWin[0] = pstDBx->stCache.dwCbwin[0];
624   624: 	dwWin[1] = pstDBx->stCache.dwCbwin[1];
625   625: 	dwMax    = pstDBx->stCache.dwCused;
626   626: 	dwSiz    = pstDBx->stCache.dwCbwin[1] - pstDBx->stCache.dwCbwin[0] + 1;
627   627: 
628   628: 
629   629: 	/* 1: Prompt for input */
630   630: 	fputs("\nEnter code (H:HELP) [F|P|U|C|D|N|L|R|M|S|K|X|H|Q] -> ", stdout);
631   631: 
632   632: 
633   633: 	/* 2: Get ONE char code from user/stdin, and dispatch to eKeyDBRead() */
634   634:        iAnswer = getchar();    /* NB: often implemented as MACRO */
635   635:        iAnswer = toupper(iAnswer);
636   636:        switch (iAnswer) {
637   637: 
638   638:           case 'F':            /* First <dwSiz> slots */
639   639:              KCHK_ERR(eKeyDBRead(pstDBx, pstBF, K_FIRST, dwSiz), K_CONT)
640   640:              break;
641   641: 
642   642:           case 'P':            /* Previous <dwSiz> slots */
643   643:              KCHK_ERR(eKeyDBRead(pstDBx, pstBF, K_PREV, dwSiz), K_CONT)
644   644:              break;
645   645: 
646   646:           case 'U':            /* Up 1 slot */
647   647:              KCHK_ERR(eKeyDBRead(pstDBx, pstBF, dwWin[0] - 1, dwSiz), K_CONT)
648   648:              break;
649   649: 
650   650:           case 'C':            /* Current <dwSiz> slots ("echo") */
651   651:              KCHK_ERR(eKeyDBRead(pstDBx, pstBF, K_CURR, dwSiz), K_CONT)
652   652:              break;
653   653: 
654   654:           case 'D':            /* Down 1 slot */
655   655:              KCHK_ERR(eKeyDBRead(pstDBx, pstBF, dwWin[0] + 1, dwSiz), K_CONT)
656   656:              break;
657   657: 
658   658:           case 'N':            /* Next <dwSiz> slots */
659   659:              KCHK_ERR(eKeyDBRead(pstDBx, pstBF, K_NEXT, dwSiz), K_CONT)
660   660:              break;
661   661: 
662   662:           case 'L':            /* Last <dwSiz> slots */
663   663:              KCHK_ERR(eKeyDBRead(pstDBx, pstBF, K_LAST, -dwSiz), K_CONT)
664   664:              break;
665   665: 
666   666:           case 'R':            /* Resize */
667   667:              printf("\nENTER height of bufferwindow :\n");
668   668:              printf("\tCurrent[%ld], New -> ", dwSiz);
669   669:              scanf("%ld", &dwSetSiz);
670   670:              KCHK_ERR(eKeyDBRead(pstDBx, pstBF, K_CURR, dwSetSiz), K_CONT)
671   671:              break;
672   672: 

XC ... 'C' Concordance Utility   KEY.c                      Page 13

673   673:           case 'M':            /* Move */
674   674:              printf("\nENTER position of bufferwindow :\n");
675   675:              printf("\tCurrent[%ld], New -> ", dwWin[0]);
676   676:              scanf("%ld", &dwSetPos);
677   677:              KCHK_ERR(eKeyDBRead(pstDBx, pstBF, dwSetPos, dwSiz), K_CONT)
678   678:              break;
679   679: 
680   680:           case 'S':            /* Set-new */
681   681:              printf("\nENTER position & height of bufferwindow :\n");
682   682:              printf("\tCurrent[%ld %ld], New -> ", dwWin[0], dwSiz);
683   683:              scanf("%ld %ld", &dwSetPos, &dwSetSiz);
684   684:              KCHK_ERR(eKeyDBRead(pstDBx, pstBF, dwSetPos, dwSetSiz), K_CONT)
685   685:              break;
686   686: 
687   687:           case 'K':            /* Key-list */
688   688:              do {
689   689:                 printf("\nENTER list of comma-separated key-values :\n->");
690   690:                 scanf("%s", pstBF->pzBaddr);
691   691:                 KCHK_ERR(eKeyDBRead(pstDBx, pstBF, K_LIST, 0), K_CONT)
692   692:              } while (Kstat == K_BADLIST);
693   693:              break;
694   694: 
695   695:           case 'X':            /* Expression for key-class */
696   696:              do {
697   697:                 printf("\nENTER search expression :\n->");
698   698:                 scanf("%s", pstBF->pzBaddr);
699   699:                 KCHK_ERR(eKeyDBRead(pstDBx, pstBF, K_EXPR, 0), K_CONT)
700   700:              } while (Kstat == K_BADLIST);
701   701:              break;
702   702: 
703   703:           default:             /* Error */
704   704:              fprintf(stderr, "\nERROR in input[%c-x%x-d%d], - try again ...\a",
705   705:                              (char) iAnswer, iAnswer, iAnswer);
706   706:              iAnswer = 'E'; 
707   707:              /* fall through! */
708   708: 
709   709:           case 'H':            /* Help */
710   710:              fputs("\neKeyListScroll() function SCROLL CODES :\n", stdout);
711   711:              fprintf(stdout, "\t+================================================================+\n
           ");
712   712:              fprintf(stdout, "\t|  F : MOVE   pos. of    bufferwindow first %3ld slots  in cache |\n
           ", dwSiz);
713   713:              fprintf(stdout, "\t|  P : MOVE   pos. of    bufferwindow up    %3ld slots  in cache |\n
           ", dwSiz);
714   714:              fprintf(stdout, "\t|  U : MOVE   pos. of    bufferwindow up      1  slot   in cache |\n
           ");
715   715:              fprintf(stdout, "\t|  C : KEEP   pos. of    bufferwindow curr  %3ld slot   in cache |\n
           ", dwSiz);
716   716:              fprintf(stdout, "\t|  D : MOVE   pos. of    bufferwindow down    1  slot   in cache |\n
           ");
717   717:              fprintf(stdout, "\t|  D : MOVE   pos. of    bufferwindow down    1  slot   in cache |\n
           ");
718   718:              fprintf(stdout, "\t|  N : MOVE   pos. of    bufferwindow down  %3ld slots  in cache |\n
           ", dwSiz);
719   719:              fprintf(stdout, "\t|  L : MOVE   pos. of    bufferwindow last  %3ld slots  in cache |\n
           ", dwSiz);

XC ... 'C' Concordance Utility   KEY.c                      Page 14

720   720:              fprintf(stdout, "\t+----------------------------------------------------------------+\n
           ");
721   721:              fprintf(stdout, "\t|  M : ENTER  pos.   of  bufferwindow  :   new   slot   in cache |\n
           ");
722   722:              fprintf(stdout, "\t|  R : ENTER  height of  bufferwindow  :   new   #slots in cache |\n
           ");
723   723:              fprintf(stdout, "\t|  S : ENTER  pos/height bufferwindow  :   new   slot & #slots   |\n
           ");
724   724:              fprintf(stdout, "\t+----------------------------------------------------------------+\n
           ");
725   725:              fprintf(stdout, "\t|  K : ENTER  list       of key values :   new   array for cache |\n
           ");
726   726:              fprintf(stdout, "\t|  X : ENTER  expr.      of key-class  :   new   array for cache |\n
           ");
727   727:              fprintf(stdout, "\t+----------------------------------------------------------------+\n
           ");
728   728:              fprintf(stdout, "\t|  H : HELP   options f. eKeyListScroll()                        |\n
           ");
729   729:              fprintf(stdout, "\t|  Q : QUIT   function   eKeyListScroll()                        |\n
           ");
730   730:              fprintf(stdout, "\t|  A : ABORT  program    key.c                                   |\n
           ");
731   731:              fprintf(stdout, "\t+================================================================+\n
           ");
732   732:              break;
733   733: 
734   734:            case 'Q':           /* Quit */
735   735:               break;
736   736: 
737   737: 	    case 'A':           /* Abort, - Commit harakiri */
738   738:               (void) raise(SIGTERM);
739   739:               /*NOTREACHED*/
740   740:               break;
741   741: 
742   742: 	} /* END switch (iAnswer=toupper(getchar())) */
743   743: 
744   744: 
745   745: 	/* Eat rest of input-line in silence */
746   746: 	while (getchar() != '\n')
747   747: 	     /* skip input chars up to (& including) newline */ ;
748   748: 
749   749: 	/* 3: Trace the buffer */
750   750:        if ( iAnswer != 'H' && iAnswer != 'K' && iAnswer != 'X' &&
751   751:             iAnswer != 'E' && iAnswer != 'Q' &&
752   752:             pstDBx->stCache.dwCused > (DWORD) 0 )
753   753:           eKeyBufDump(pstBF, FALSE);
754   754: 
755   755:     } while (iAnswer != 'Q');
756   756: 
757   757: 
758   758:     /* Function complete : return ok */
759   759:     STCK("eKeyListScroll");
760   760:     KRET_OK
761   761: 
762   762: } /* END function eKeyListScroll */
763   763: /*-1*/

XC ... 'C' Concordance Utility   KEY.c                      Page 15

764   764: 
765   765: #endif	/* MAIN */
766   766: 
767   767: 
768   768: 
769   769: 
770   770: /****************************************************************************/
771   771: /******************************** DB ****************************************/
772   772: /****************************************************************************/
773   773: 
774   774: 
775   775: 
776   776: /*+2 MODULE KEY.C ==========================================================*/
777   777: /*   NAME   03                    eKeyDBOpen                                */
778   778: /*== SYNOPSIS ==============================================================*/
779   779: PUBLIC    eRetType
780   780: eKeyDBOpen(pstDBx, pzDatFile, pzIdxFile,
781   781:            pstBF, pzDatBuf, iBufLen)
782   782:     DBASE    *pstDBx;         /* Pointer to DBASE struct. to initialize */
783   783:     char     *pzDatFile;      /* - Name of datafile for DBASE stDBx */
784   784:     char     *pzIdxFile;      /* - Name of keyfile for DBASE stDBx */
785   785:     BUFFER   *pstBF;          /* Pointer to BUFFER structure data records */
786   786:     char     *pzDatBuf;       /* - Location of databuffer for BUFFER stBF */
787   787:     int      iBufLen;         /* - Length of databuffer for BUFFER stBF */
788   788: {
789   789: /* DESCRIPTION
790   790:  *    Opens a "database" (an key'ed flat datafile) for subsequent record
791   791:  *    retrieval based on a list of key-values or on a search expression.
792   792:  *    The positions (offsets) of the records to retrieve from the datafile
793   793:  *    are determined in one of two ways :
794   794:  *     - KeyList....: offsets corresponding to key-values are looked up in a
795   795:  *                    previously generated keyfile (cf. module key.c).
796   796:  *     - SearchExpr.: offsets are found by a scan of the datafile sections
797   797:  *                    specified by the current cache array (cf. module search.c).
798   798:  *    In both cases the record positions are "cache'd" in an array of data-
799   799:  *    file offsets to facilitate fast subsequent scrolling through identified
800   800:  *    records; The scrolling operation comprises maintaining a range of active
801   801:  *    key'es (a "window") into the cache array, and filling a RAM buffer-
802   802:  *    area with data-records corresponding to the active buffer-window.
803   803:  *
804   804:  *    The eKeyDBOpen() function thus implies opening of a datafile with
805   805:  *    associated keyfile, plus initialization of a cache and optionally
806   806:  *    a databuffer for subsequent access to the datarecords :
807   807:  *
808   808:  *    1: Initialize CACHE : set structure variables to all zero (NULL/0)
809   809:  *    2: Initialize INDEX : set name of keyfile, and instantiate an "incore"
810   810:  *       keydescriptor structure (including opening of the keyfile).
811   811:  *       In DEBUG-mode : dump keystatus (size & load) to stdout.
812   812:  *    3: Initialize DATAFILE : open datafile as textfile, mode ReadOnly (RO)
813   813:  *    4: Initialize DATABUFFER : 3 possible cases ...
814   814:  *       4.1: pstBF != NULL & pzDatBuf == NULL : allocate a new dataarea
815   815:  *       4.2: pstBF != NULL & pzDatBuf != NULL : use caller-provided dataarea
816   816:  *       4.3: pstBF == NULL .................. : ignore buffer initialization
817   817:  *
818   818:  * RETURN
819   819:  *    Side effects ........: Cache structure variables reset to all NULL/0.

XC ... 'C' Concordance Utility   KEY.c                      Page 16

820   820:  *                           Index-structure instantiated, keyfile opened.
821   821:  *                           Datafile opened & (optionally) buffer allocated.
822   822:  *    Function return value: OK if operation succeeded, ERROR otherwise; -
823   823:  *                           If ERROR, "Kstat" holds the precise error code.
824   824:  *
825   825:  * SEE ALSO
826   826:  *    The functions eKeyDBRead() and eKeyDBClose(), both in module key.c
827   827:  *-2*/
828   828: 
829   829:     char      aIdxFile[12];       /* Name of keyfile */
830   830:     char      *pIdx    = NULL;    /* - with associated ptr */
831   831:     eRetType  eRetCode = ERROR;   /* Return code for key.c functions */
832   832:     int       iRetCode = 1;       /* Int return code for setvbuf() */
833   833: #ifdef DEBUG
834   834:     DWORD     dwIdxSiz = 0L;      /* Debug: Index size  */
835   835:     DWORD     dwIdxUse = 0L;      /* Debug: Index usage */
836   836:     WORD      wIdxLoad = 0;       /* Debug: Index load  */
837   837: #endif			       /* DEBUG */
838   838: 
839   839: 
840   840:     /*- CACHE --------------------------------------------------------------*/
841   841:     /* 1: Init. CACHE array (not allocated) & buffer window (empty)         */
842   842: 
843   843:     /* Cache array */
844   844:     pstDBx->stCache.padwData = NULL;   /* Pointer to array of key-rec's */
845   845:     pstDBx->stCache.dwCsize  = 0L;     /* Size of array, initially zero */
846   846: 
847   847:     /* Buffer window : key range of stCache.padwData[] currently in buf. */
848   848:     pstDBx->stCache.dwCused    = 0L;   /* Total # of dataoffsets in cache */
849   849:     pstDBx->stCache.dwCbwin[0] = 0L;   /* Index of first dataoffset in buffer */
850   850:     pstDBx->stCache.dwCbwin[1] = 0L;   /* Index of last dataoffest in buffer  */
851   851: 
852   852: 
853   853:     /*- INDEX --------------------------------------------------------------*/
854   854:     /* 2: Init. INDEX filename & call key-open to instantiate keystruct */
855   855: 
856   856:     /* Set up name for keyfile */
857   857:     if (pzIdxFile == NULL) {
858   858: 	/* Use default name for the keyfile : "pzDatFile".idx */
859   859: 	(void) strncpy(aIdxFile, pzDatFile, 12);
860   860: 	if ((pIdx = strchr(aIdxFile, '.')) == NULL) {
861   861: 	    pIdx = aIdxFile + strlen(aIdxFile);
862   862: 	}
863   863: 	(void) strcpy(pIdx, ".idx");
864   864:     }
865   865:     else
866   866: 	/* Use name passed as parameter for the keyfile */
867   867: 	(void) strncpy(aIdxFile, pzIdxFile, 12);
868   868: 
869   869:     /* Call specific key access-function to open key, ie. :  */
870   870:     /* instantiate an "incore" key descriptor & open keyfile */
871   871:     eRetCode = (*peIdxOpen)(&(pstDBx->pIndex), aIdxFile, "rb");
872   872:     KRET_ERR(eRetCode == ERROR, K_IDXOPEN, 300)
873   873: 
874   874: #ifdef DEBUG
875   875:     /* Trace status of key to stdout */

XC ... 'C' Concordance Utility   KEY.c                      Page 17

876   876:     KCHK_ERR((*peIdxGetSize)(&(pstDBx->pIndex), &dwIdxSiz, &dwIdxUse), K_CONT)
877   877:     fprintf(stdout, "Index Keyrecords : Size=[%lu], Used=[%lu]\n", dwIdxSiz, dwIdxUse);
878   878:     KCHK_ERR((*peIdxGetLoad)(&(pstDBx->pIndex), &wIdxLoad), K_CONT)
879   879:     fprintf(stdout, "Index Loadfactor=%d\n", wIdxLoad);
880   880: #endif	/* DEBUG */
881   881: 
882   882: 
883   883:     /*- DATAFILE -----------------------------------------------------------*/
884   884:     /* 3: Init. DATAFILE : open & set up filesystem buffer                  */
885   885: 
886   886:     /* Open datafile as textfile mode RO, and give it a large I/O buffer */
887   887:     pstDBx->fdData = fopen(pzDatFile, "r");
888   888:     KRET_ERR(pstDBx->fdData == NULL, K_DATOPEN, 301)
889   889: 
890   890:     iRetCode = setvbuf(pstDBx->fdData, NULL, _IOFBF, 4*1024);
891   891:     KRET_ERR(iRetCode != 0, K_DATOPEN, 302) 
892   892: 
893   893: 
894   894:     /*- DATABUFFER ---------------------------------------------------------*/
895   895:     /* 4: Init. DATABUFFER : allocate & initialize buffer area, - optional! */
896   896: 
897   897:     /* 4.1-2: Fill in a BUFFER datastructure, if provided as argument! */
898   898:     if (pstBF != NULL) {
899   899: 
900   900: 	KRET_ERR(iBufLen <= 0, K_BADARGS, 303)
901   901: 
902   902: 	/* 4.1: Allocate a new dataarea for the BUFFER */
903   903: 	if (pzDatBuf == NULL) {
904   904: 	    /* Initialize to newly allocated dataarea */
905   905: 	    pstBF->pzBaddr = (char *) calloc(iBufLen, sizeof(char));
906   906: 	    KRET_ERR(pstBF->pzBaddr == NULL, K_BADALLOC, 304)
907   907: 	}
908   908: 	else {
909   909: 	    /* 4.2: Use dataarea previously allocated by caller */
910   910: 	    pstBF->pzBaddr = pzDatBuf;
911   911: 	}
912   912: 
913   913: 	/* Clear & Zero-terminate the dataarea */
914   914: 	(void) memset(pstBF->pzBaddr, ' ', iBufLen);
915   915: 	D(memset(pstBF->pzBaddr, '*', iBufLen));
916   916: 	*(pstBF->pzBaddr + iBufLen - 1) = '\0';
917   917: 
918   918: 	/* Set the buffer length */
919   919: 	pstBF->wBsize = iBufLen;
920   920:     }
921   921: 
922   922:     /* 4.3: else (pstBF == NULL), - Ignore BUFFER initialization! */
923   923: 
924   924: 
925   925:     /* Function complete : return ok */
926   926:     STCK("eKeyDBOpen");
927   927:     KRET_OK
928   928: 
929   929: } /* END function eKeyDBOpen() */
930   930: 
931   931: 

XC ... 'C' Concordance Utility   KEY.c                      Page 18

932   932: 
933   933: /*+2 MODULE KEY.C ==========================================================*/
934   934: /*   NAME   04                    eKeyDBClose                               */
935   935: /*== SYNOPSIS ==============================================================*/
936   936: PUBLIC    eRetType
937   937: eKeyDBClose(pstDBx, pstBF)
938   938:     DBASE    *pstDBx;         /* Pointer to DBASE structure to close */
939   939:     BUFFER   *pstBF;          /* Pointer to BUFFER structure to close */
940   940: {
941   941: /* DESCRIPTION
942   942:  *    Closes a "database", that has previously been opened by eKeyDBOpen();
943   943:  *    The function "reverses" the actions of opening a "database" : it
944   944:  *     - closes the datafile and its accociated keyfile, and
945   945:  *     - free's the database cache and (optionally) the databuffer.
946   946:  *
947   947:  *    1: Shut down CACHE : free the cache array and reset cache struct. var's
948   948:  *    2: Shut down INDEX : free the "incore" keydescriptor structure
949   949:  *                         (including closing the keyfile).
950   950:  *    3: Shut down DATAFILE : close the datafile
951   951:  *    4: Shut down DATABUFFER : 2 possible cases ...
952   952:  *       4.1: pstBF != NULL : free buffer's dataarea, and reset buffersize
953   953:  *       4.2: pstBF == NULL : ignore release of buffer (stBF may be reused)
954   954:  *
955   955:  * RETURN
956   956:  *    Side effects ........: Cache array deallocated & size-var's reset to 0.
957   957:  *                           Indexfile closed & key-structure deallocated.
958   958:  *                           Datafile closed & (optionally) buffer deallocated.
959   959:  *    Function return value: OK if operation succeeded, ERROR otherwise; -
960   960:  *                           If ERROR, "Kstat" holds the precise error code.
961   961:  *
962   962:  * SEE ALSO
963   963:  *   The function eKeyDBOpen() in module key.c.
964   964:  *-2*/
965   965: 
966   966:     eRetType  eRetCode = ERROR;   /* Return code for key.c functions */
967   967: 
968   968:     /* 0: Validate input parameter (prevent closing a not opened DB) */
969   969:     KRET_ERR(pstDBx->fdData == NULL, K_BADARGS, 400)
970   970: 
971   971: 
972   972:     /* 1: CACHE Shut down */
973   973:     eRetCode = eKeyCacheFree(&(pstDBx->stCache));
974   974:     KRET_ERR(eRetCode == ERROR, Kstat, 401)
975   975: 
976   976: 
977   977:     /* 2: INDEX Shut down : call specific key access-function. */
978   978:     eRetCode = (*peIdxClose)(&(pstDBx->pIndex));
979   979:     KRET_ERR(eRetCode == ERROR, K_IDXCLOSE, 402)
980   980: 
981   981: 
982   982:     /* 3: DATAFILE Shut down */
983   983:     eRetCode = (fclose(pstDBx->fdData) != 0 ? ERROR : OK);
984   984:     KRET_ERR(eRetCode == ERROR, K_DATCLOSE, 403)
985   985: 
986   986: 
987   987:     /* 4: DATABUFFER Shut down, - Optional (NB: buffer may be shared!) */

XC ... 'C' Concordance Utility   KEY.c                      Page 19

988   988:     if (pstBF != NULL) {
989   989: 	/* 4.1: Free the buffer dataarea, and zero the buffersize */
990   990: 	free(pstBF->pzBaddr);
991   991: 	pstBF->pzBaddr = NULL;
992   992: 
993   993: 	pstBF->wBsize = 0;
994   994: 	pstBF = NULL;
995   995:     }
996   996:     /* 4.2: else (pstBF == NULL), - Ignore buffer release */
997   997: 
998   998: 
999   999:     /* Function complete : return ok */
1000 1000:     STCK("eKeyDBClose");
1001 1001:     KRET_OK
1002 1002: 
1003 1003: } /* END function eKeyDBClose() */ 
1004 1004: 
1005 1005: 
1006 1006: 
1007 1007: /*+2 MODULE KEY.C ==========================================================*/
1008 1008: /*   NAME   05                    eKeyDBRead                                */
1009 1009: /*== SYNOPSIS ==============================================================*/
1010 1010: PUBLIC    eRetType
1011 1011: eKeyDBRead(pstDBx, pstBF, lSetPos, lSetSiz)
1012 1012:     DBASE    *pstDBx;	       /* Pointer to DBASE struct. for reading data  */
1013 1013:     BUFFER   *pstBF;	       /* Pointer to BUFFER struct. for writing data */
1014 1014:     long      lSetPos;	       /* Startkey into stDBx->stCache.padwData[]  */
1015 1015:     long      lSetSiz;	       /* Number of padwData[] entries to retrieve   */
1016 1016: {
1017 1017: /* DESCRIPTION
1018 1018:  *    The "procedural strength" of this function has deliberately been chosen
1019 1019:  *    to be "communicational" (as opposed to "functional", - cf. Glenford
1020 1020:  *    J. Meyers' structured design terminology) : the function performs several
1021 1021:  *    related actions on the same data in the same code section (procedure).
1022 1022:  *    The aim of this design has been to provide the user with ONE GENERAL
1023 1023:  *    INTERFACE to all access-operations on a "database" (an key'ed flat
1024 1024:  *    datafile) :
1025 1025:  *     - the main function is to FIND and READ one or more data-records from
1026 1026:  *       a "database" (identified by pstDBx) to a buffer (identified by pstBF).
1027 1027:  *       The datarecord(s) are identified by a list of key-values or by a
1028 1028:  *       search expression, both passed as a zero-terminated string in the
1029 1029:  *       buffer-area (pstBF->pzBaddr).
1030 1030:  *     - the cache datastructure has been introduced to allow fast and easy
1031 1031:  *       PRESENTATION of already identified datarecords, using direct retrie-
1032 1032:  *       val by datafile offsets (ie. short cutting the time consuming FIND
1033 1033:  *       operations of key-lookup and text-search). The presentation options
1034 1034:  *       offered are : movement <lSetPos> and resizing <lSetSiz> of an key
1035 1035:  *       range in the cache array (a "buffer-window") specifying the records
1036 1036:  *       to be read from the datafile to the buffer-area.
1037 1037:  *
1038 1038:  *   The procedure of accessing a "database" thus requires :
1039 1039:  *    - one call of eKeyDBRead() with a key-list or a key-expression in the
1040 1040:  *      buffer-area <pstBF> to FIND a sequence of datafile offsets, and build
1041 1041:  *      a CACHE datastructure from these,
1042 1042:  *    - one or more subsequent calls of eKeyDBRead() with <lSetPos> and
1043 1043:  *      <lSetSiz> defined to RESET the cache bufferwindow and REFILL the data-

XC ... 'C' Concordance Utility   KEY.c                      Page 20

1044 1044:  *      buffer accordingly.
1045 1045:  *   The actions of redefining a cache array and resetting a cache buffer-
1046 1046:  *   window (thereby refilling the bufferarea) are intimately connected
1047 1047:  *   (logically, temporal, procedural and communicational strength), and
1048 1048:  *   I have therefore chosen to provide them as a single function for acces-
1049 1049:  *   sing a database :
1050 1050:  *
1051 1051:  *    Depending on the value of <lSetPos> the function may proceed along
1052 1052:  *    3 different paths :
1053 1053:  *    1: K_EXPR   the buffer pstBF contains a zero-terminated string defining
1054 1054:  *                a search expression; the function calls on eKeyCacheSearch()
1055 1055:  *                to search datarecords defined by a cache of datafile-offsets
1056 1056:  *                for a content "matching" the search expression.
1057 1057:  *    2: K_LIST   the buffer pstBF contains a zero-terminated string holding
1058 1058:  *                a comma-separated list of key values; the function calls on
1059 1059:  *                eKeyCacheFill() to set up a cache of datafile-offsets by
1060 1060:  *                looking up the keys in the keyfile and reading the offsets.
1061 1061:  *    3:<lSetPos> a specifcation of the position in a previously defined cache
1062 1062:  *      3.1:       - EITHER  any of a series of #defined symbolic constants
1063 1063:  *      3.2:       - OR      a numeric key value
1064 1064:  *      3.3:      Taken together <lSetPos> and <lSetSiz> defines a range of
1065 1065:  *                slots in the cache-array (a "bufferwindow") defining the
1066 1066:  *      3.4:      datarecords to be read from the datafile to the buffer, -
1067 1067:  *                an operation performed by calling function eKeyBufFill().
1068 1068:  *     After a call with K_EXPR or K_LIST to set up a cache-array, one may
1069 1069:  *     thus use the cache for subsequent direct retrieval of datarecords from
1070 1070:  *     the datafile to the buffer (thereby facilitating fast and intelligent
1071 1071:  *     buffer-handling such as vertical scrolling). The actual display of the
1072 1072:  *     buffer contents is left to the calling application, using its preferred
1073 1073:  *     user interface.
1074 1074:  *
1075 1075:  * RETURN
1076 1076:  *    Side effects ........: Depending on the value of parameter <lSetPos>,
1077 1077:  *                           - K_EXPR, K_LIST : cache allocated & initialized
1078 1078:  *                           - symbl./numeric : buffer filled cf. buf.window
1079 1079:  *    Function return value: OK if operation succeeded, ERROR otherwise; -
1080 1080:  *                           If ERROR, "Kstat" holds the precise error code.
1081 1081:  *
1082 1082:  * SEE ALSO
1083 1083:  *    The functions eKeyDBOpen() and eKeyDBClose(), both in module key.c
1084 1084:  *-2*/
1085 1085: 
1086 1086:     DWORD     dwMax = pstDBx->stCache.dwCused; /* #slots used in cache */
1087 1087:     long      lNew[2];                         /* New bufferwindow in cache */
1088 1088:     long      lTmp = 0L;                       /* For "swap" of window TOP/BOT */
1089 1089:     eRetType  eRetCode = ERROR;
1090 1090: 
1091 1091: 
1092 1092:     /* INITIALIZE CACHE ARRAY or RESET CACHE WINDOW POS., cf. <lSetPos> */
1093 1093:     switch (lSetPos) {
1094 1094: 
1095 1095: 	    /* 1-2: INITIALIZE CACHE ARRAY --------------------------------- */
1096 1096: 	case K_EXPR:
1097 1097:            /* 1: Initialize a cache from a SEARCH-EXPRession in buffer */
1098 1098:            eRetCode = eKeyCacheSearch(pstDBx, pstBF);
1099 1099:            KRET_ERR(eRetCode == ERROR, Kstat, 500)

XC ... 'C' Concordance Utility   KEY.c                      Page 21

1100 1100:            KRET_OK
1101 1101:            /*NOTREACHED*/
1102 1102:            break;
1103 1103: 
1104 1104: 	case K_LIST:
1105 1105:            /* 2: Initialize a cache from a KEY-LIST in buffer */
1106 1106:            eRetCode = eKeyCacheFill(pstDBx, pstBF->pzBaddr);
1107 1107:            KRET_ERR(eRetCode == ERROR, Kstat, 501)
1108 1108:            KRET_OK
1109 1109:            /*NOTREACHED*/
1110 1110:            break;
1111 1111: 
1112 1112:            /* 3.1: RESET CACHE WINDOW POS., using symbolic constant ------- */
1113 1113: 	case K_FIRST:           /* First <lSetSiz> slots */
1114 1114:            lNew[0] = 1;
1115 1115:            break;
1116 1116: 
1117 1117: 	case K_PREV:            /* Previous <lSetSiz> slots */
1118 1118:            lNew[0] = pstDBx->stCache.dwCbwin[0] - lSetSiz;
1119 1119:            break;
1120 1120: 
1121 1121: 	case K_CURR:            /* Current <lSetSiz> slots ("echo") */
1122 1122:            lNew[0] = pstDBx->stCache.dwCbwin[0];
1123 1123:            break;
1124 1124: 
1125 1125: 	case K_NEXT:            /* Next <lSetSiz> slots */
1126 1126:            lNew[0] = pstDBx->stCache.dwCbwin[1] + 1;
1127 1127:            break;
1128 1128: 
1129 1129: 	case K_LAST:            /* Last <lSetSiz> slots */
1130 1130:            lNew[0] = (long) dwMax;
1131 1131:            break;
1132 1132: 
1133 1133: 	    /* 3.2: RESET CACHE WINDOW POS., using numeric key ----------- */
1134 1134: 	default:
1135 1135:            lNew[0] = lSetPos;
1136 1136:            break;
1137 1137: 
1138 1138:     } /* END switch (lSetPos) */
1139 1139: 
1140 1140: 
1141 1141:     /* 3.3: RESET CACHE WINDOW SIZE (clamp to actual cache range) */
1142 1142:     lNew[0] = (long) ( lNew[0] < 1L ? 1L :
1143 1143:                       (lNew[0] > (long) dwMax ? (long) dwMax : lNew[0]));
1144 1144: 
1145 1145:     /* Set new window range, and clamp to actual cache range */
1146 1146:     lSetSiz += ( lSetSiz > 0L ? -1L :
1147 1147:                 (lSetSiz < 0L ?  1L : 0L));
1148 1148:     lNew[1] = lNew[0] + lSetSiz;
1149 1149:     lNew[1] = (long) ( lNew[1] < 1L ? 1L :
1150 1150:                       (lNew[1] > (long) dwMax ? (long) dwMax : lNew[1]));
1151 1151: 
1152 1152:     /* Swap window Top/Bottom-key, if nessecary */
1153 1153:     if (lNew[1] < lNew[0]) {
1154 1154: 	lTmp    = lNew[0];
1155 1155: 	lNew[0] = lNew[1];

XC ... 'C' Concordance Utility   KEY.c                      Page 22

1156 1156: 	lNew[1] = lTmp;
1157 1157:     }
1158 1158: 
1159 1159: 
1160 1160:     /* 3.4: FILL BUFFER according to the new cache window */
1161 1161: 
1162 1162:     /* Check for valid cache : the cache must contain at least 1 element */
1163 1163:     assert(dwMax >= 0L);
1164 1164:     KRET_ERR(dwMax == 0L, K_CACEMPTY, 502)
1165 1165: 
1166 1166:     /* Read rec's from datafile to buffer cf. to new cache window: lNew[] */
1167 1167:     eRetCode = eKeyBufFill(pstDBx, pstBF, (DWORD(*)[])(&(lNew[0])));
1168 1168:     KRET_ERR(eRetCode == ERROR, Kstat, 503)
1169 1169: 
1170 1170: 
1171 1171:     /* Function complete : return ok */
1172 1172:     STCK("eKeyDBRead");
1173 1173:     KRET_OK
1174 1174: 
1175 1175: } /* END function eKeyDBRead() */
1176 1176: 
1177 1177: 
1178 1178: 
1179 1179: 
1180 1180: /****************************************************************************/
1181 1181: /******************************** CACHE *************************************/
1182 1182: /****************************************************************************/
1183 1183: 
1184 1184: 
1185 1185: 
1186 1186: /*+2 MODULE KEY.C ==========================================================*/
1187 1187: /*   NAME   06                    eKeyCacheFill                             */
1188 1188: /*== SYNOPSIS ==============================================================*/
1189 1189: PRIVATE   eRetType
1190 1190: eKeyCacheFill(pstDBx, pzKeyList)
1191 1191:     DBASE    *pstDBx;         /* Ptr to DBASE structure w. cache to create */
1192 1192:     char     *pzKeyList;      /* List of keys for data offsets to "cache"  */
1193 1193: {
1194 1194: /* DESCRIPTION
1195 1195:  *    Setup a cache array (pstDBx->stCache) from a list of comma-separated
1196 1196:  *    key specifications (pzKeyList), using lookup operations on the key-
1197 1197:  *    file (pstDBx->pIndex) to directly map keyvalues to record-offsets.
1198 1198:  *
1199 1199:  *    The keyfile has been previously generated from the datafile (by
1200 1200:  *    module key.c) as a collection of key-records identifying the
1201 1201:  *    mapping [keystring:fileoffset] for all records in the datafile.
1202 1202:  *
1203 1203:  *    1: INITIALIZE
1204 1204:  *       Create a cache-array to hold offsets into the datafile for the data-
1205 1205:  *       records specified by the keyvalues in <pzKeyList>
1206 1206:  *
1207 1207:  *    2: LOOKUP & CACHE ...
1208 1208:  *       Fill the cache-array with file-offsets (by lookup in the keyfile):
1209 1209:  *       LOOP through the <pzKeyList> string :
1210 1210:  *          2.1: Call on eKeyBufScan() to get next keyvalue from <pzKeyList>
1211 1211:  *          2.2: Lookup key-record in keyfile, and retrieve datafileoffset

XC ... 'C' Concordance Utility   KEY.c                      Page 23

1212 1212:  *          2.3: If key found, insert the datarecord offset in the cache-array
1213 1213:  *               else: ignore key; Expand cache array dynamically as required.
1214 1214:  *       WHILE (more keys in <pzKeyList>, or parse-error)
1215 1215:  *
1216 1216:  *    3: TERMINATE
1217 1217:  *       Set number of slots currently used in cache (= #keys from <pzKeyList>
1218 1218:  *       found in the key)
1219 1219:  *
1220 1220:  * RETURN
1221 1221:  *    Side effects ........: Old cache (if any) deallocated, new cache
1222 1222:  *                           allocated and fill'd in with a datarecord offset
1223 1223:  *                           for each keyvalue in <pzKeyList> found in key.
1224 1224:  *                           The cache struct. slotcount <dwCused> is updated.
1225 1225:  *    Function return value: OK if operation succeeded, ERROR otherwise; -
1226 1226:  *                           If ERROR, "Kstat" holds the precise error code.
1227 1227:  *-2*/
1228 1228: 
1229 1229:     char     *pzKeyStr   = NULL;   /* Ptr into pzKeyList, set by eKeyBufScan */
1230 1230:     DWORD     dwKeyCount = 0L;     /* Current slot: pstDBx->stCache.padwData */
1231 1231:     DWORD     dwDatFile  = 0L;     /* Flatfile offset into datafile */
1232 1232:     eRetType  eRetCode   = ERROR;  /* Function return code */
1233 1233: 
1234 1234: 
1235 1235:     /* 1: INITIALIZE: Create cache for datafile offsets... */
1236 1236:     /* First free old cache, if any */
1237 1237:     if (pstDBx->stCache.padwData != NULL) {
1238 1238: 	eRetCode = eKeyCacheFree(&(pstDBx->stCache));
1239 1239: 	KRET_ERR(eRetCode == ERROR, Kstat, 600)
1240 1240:     }
1241 1241:     /* Then allocate new cache, initial size */
1242 1242:     eRetCode = eKeyCacheAlloc(&(pstDBx->stCache), 0.0);
1243 1243:     KRET_ERR(eRetCode == ERROR, Kstat, 601)
1244 1244: 
1245 1245: 
1246 1246:     /* 2: LOOP: LOOKUP & CACHE ... */
1247 1247:     /* Lookup datafile-offset: key[key], and insert offset in cache */
1248 1248:     while (eKeyBufScan(pstDBx, &pzKeyList, &pzKeyStr) == OK) {
1249 1249: 
1250 1250: 	/* 2.1: Retrieve next keyvalue from <pzKeyList> : eKeyBufScan() */
1251 1251: 	D(fprintf(stdout, "Cache#[%lu] Key#[%s]\n", dwKeyCount+1, pzKeyStr));
1252 1252: 
1253 1253: 	/* 2.2: Look up datafile offset <dwDatFile> in keyfile[pzKeyStr] */
1254 1254: 	(void) (*peIdxRead)(&(pstDBx->pIndex), pzKeyStr, &dwDatFile);
1255 1255: 	KRET_ERR(Astat != A_NOTFOUND && Astat != A_OK, K_IDXREAD, 602)
1256 1256: 
1257 1257: 	/* 2.3: If key defined in key, - insert dataoffset in cache */
1258 1258: 	if (Astat == A_OK) {
1259 1259: 
1260 1260: 	    /* Resize cache if overflow : expand to double size! */
1261 1261: 	    if (dwKeyCount >= pstDBx->stCache.dwCsize) {
1262 1262: 	        eRetCode = eKeyCacheAlloc(&(pstDBx->stCache), 2.0);
1263 1263: 	        KRET_ERR(eRetCode == ERROR, Kstat, 603)
1264 1264: 	    }
1265 1265: 
1266 1266: 	    /* Insert datafileoffset in cache [1...dwCsize-1], slot 0 unused */
1267 1267: 	    (*(pstDBx->stCache.padwData))[++dwKeyCount] = dwDatFile;

XC ... 'C' Concordance Utility   KEY.c                      Page 24

1268 1268: 
1269 1269: 	    /* Trace key keyrecord and flatfile datarecord (optional) */
1270 1270: 	    D(eKeyRecDump(pzKeyStr, dwDatFile));
1271 1271: 	    D(eKeyDatDump(pstDBx->fdData, dwDatFile));
1272 1272: 	}
1273 1273: 	/* else (Astat == A_NOTFOUND) : ignore key not found in key */
1274 1274: 
1275 1275:     } /* END LOOP <while eKeyBufScan()==OK>, ie. while more in key-list. */
1276 1276: 
1277 1277:     /* Now eKeyBufScan() != OK; - if not <pzKeyStr> exhausted, return ERROR */
1278 1278:     KRET_ERR((Kstat != K_EOL), Kstat, 604)
1279 1279: 
1280 1280: 
1281 1281:     /* 3: Set total number of dataoffsets currently used in cache */
1282 1282:     pstDBx->stCache.dwCused = dwKeyCount;
1283 1283: 
1284 1284:     /* Trace cache contents (but don't print the data records) */
1285 1285:     D(eKeyCacheDump(pstDBx, FALSE));
1286 1286: 
1287 1287: 
1288 1288:     /* Function complete : return ok */
1289 1289:     STCK("eKeyCacheFill");
1290 1290:     KRET_OK
1291 1291: 
1292 1292: } /* END function eKeyCacheFill() */
1293 1293: 
1294 1294: 
1295 1295: 
1296 1296: /*+2 MODULE KEY.C ==========================================================*/
1297 1297: /*   NAME   07                    eKeyCacheSearch                           */
1298 1298: /*== SYNOPSIS ==============================================================*/
1299 1299: #define    MAXPAT  128     /* Max. allowed length of pattern string */
1300 1300: 
1301 1301: PRIVATE   eRetType
1302 1302: eKeyCacheSearch(pstDBx, pstBF)
1303 1303:     DBASE    *pstDBx;      /* Pointer to DBASE structure w. cache to search */
1304 1304:     BUFFER   *pstBF;       /* Pointer to BUFFER struct. with search pattern */
1305 1305: {
1306 1306: /* DESCRIPTION
1307 1307:  *    Uses an existing cache-array (pstDBx->stCache) of datafile record-offsets
1308 1308:  *    to retrieve a sequence of data-records one at a time, and scan each record
1309 1309:  *    for a search expression/pattern passed in the buffer <pstBF>.
1310 1310:  *    Each time the pattern is NOT found, the cache-entry is tagged, and after
1311 1311:  *    the cache has been fully searched, it is "compressed" by removing all
1312 1312:  *    tagged entries (ie. a "lazy delete").
1313 1313:  *    The function returns an updated cache containing only the offsets of
1314 1314:  *    those records, with a content "matching" the search expression.
1315 1315:  *
1316 1316:  *    1: INITIALIZE search machine
1317 1317:  *
1318 1318:  *    2: LOOP: RETRIEVE & SEARCH ...
1319 1319:  *       For all offsets in current cache : 
1320 1320:  *       2.1: Get offset of next datarecord from cache array
1321 1321:  *       2.2: Call eKeyBufRead() to read datarecord from file to buffer
1322 1322:  *       2.3: Search datarecord for pattern, - return TRUE if match
1323 1323:  *       2.4: If not match, - tag current cache slot ("lazy delete")

XC ... 'C' Concordance Utility   KEY.c                      Page 25

1324 1324:  *
1325 1325:  *    3: COMPRESS cache ...
1326 1326:  *       3.1: Scan through cache, removing each tagged entry
1327 1327:  *       3.2: Update cache count of used slots
1328 1328:  *
1329 1329:  * RETURN
1330 1330:  *    Side effects ........: Old cache compressed to hold only offsets for 
1331 1331:  *                           records with a content matching search pattern.
1332 1332:  *                           The cache struct. slotcount <dwCused> is updated.
1333 1333:  *    Function return value: OK if operation succeeded, ERROR otherwise; -
1334 1334:  *                           If ERROR, "Kstat" holds the precise error code.
1335 1335:  *-2*/
1336 1336: 
1337 1337:     char      pzPat[MAXPAT+1];     /* String for retrieving pattern from buf. */
1338 1338:     DWORD     dwCindx  = 0L;       /* Index for looping through cache array */
1339 1339:     DWORD     dwCused  = 0L;       /* #slots currently used in cache array */
1340 1340:     DWORD     dwCoffs  = 0L;       /* Datafile Offset retrieved from cache */
1341 1341:     DWORD     dwCfree  = 0L;       /* Index of first free cache slot */ 	
1342 1342:     FLAG      fMatch   = FALSE;    /* Flag : match of pzKeyExpr<->datarecord */
1343 1343:     eRetType  eRetCode = ERROR;    /* Function return code */
1344 1344: 
1345 1345: 
1346 1346:     /* 1: INITIALIZE search machine */
1347 1347:     (void) strncpy(pzPat, pstBF->pzBaddr, MAXPAT);/* Save pattern from buffer */
1348 1348:     pzPat[MAXPAT] = '\0';                         /* Assure zero termination */
1349 1349:     (*pvBldSearch)((BYTE*)pzPat, strlen(pzPat));  /* Build search tables */
1350 1350: 
1351 1351: 
1352 1352:     /* 2: LOOP: RETRIEVE & SEARCH record, for all offsets in current cache */
1353 1353:     for( dwCindx = 1L, dwCused = pstDBx->stCache.dwCused;
1354 1354:          dwCindx <= dwCused; dwCindx++) {
1355 1355:       
1356 1356:        /* 2.1: Get offset of next datarecord from cache array */
1357 1357:        dwCoffs =  (*(pstDBx->stCache.padwData))[dwCindx];
1358 1358: 
1359 1359:        /* 2.2: Call eKeyBufRead() to read datarecord from file to buffer */
1360 1360:        eRetCode = eKeyBufRead(pstDBx->fdData, pstBF, &dwCoffs);
1361 1361:        KRET_ERR(eRetCode == ERROR, K_DATREAD, 700)
1362 1362: 
1363 1363:        /* 2.3: Search datarecord for pattern, - return TRUE if match */
1364 1364:        fMatch = (FLAG) (*piRunSearch)((BYTE*)(pstBF->pzBaddr), strlen(pstBF->pzBaddr));
1365 1365:        D(fprintf(stdout, "Search: %s\n\n", (fMatch ? "MATCH!" : "NO-MATCH"));)
1366 1366: 
1367 1367: 	/* 2.4: If not match, - tag current cache slot */
1368 1368: 	if (!fMatch)
1369 1369: 	    (*(pstDBx->stCache.padwData))[dwCindx] = (DWORD) ULONG_MAX;
1370 1370: 
1371 1371:     }  /* END LOOP <for all offsets in cache> */
1372 1372: 
1373 1373: 
1374 1374:     /* 3: COMPRESS cache (ie. eliminate all tag'd entries) */
1375 1375:     D(eKeyCacheDump(pstDBx, FALSE);)
1376 1376: 
1377 1377:     /* 3.1: Scan through cache, removing each tagged entry */
1378 1378:     for( dwCindx = 1L, dwCfree = 0L;
1379 1379:          dwCindx <= dwCused; dwCindx++) {

XC ... 'C' Concordance Utility   KEY.c                      Page 26

1380 1380: 
1381 1381:        /* Retrieve datafile offset from cache (ULONG_MAX:delete tag) */
1382 1382:        dwCoffs = (*(pstDBx->stCache.padwData))[dwCindx];
1383 1383: 
1384 1384:        /* Hook in <dwCfree> on first tagged entry (to be deleted) */
1385 1385:        if (dwCoffs == (DWORD) ULONG_MAX && dwCfree == (DWORD) 0L)
1386 1386:            dwCfree = dwCindx;
1387 1387: 
1388 1388:        /* Move occupied entry up to first free slot, if any (step down free) */
1389 1389:        if (dwCoffs != (DWORD) ULONG_MAX && dwCfree > (DWORD) 0L)
1390 1390: 	    (*(pstDBx->stCache.padwData))[dwCfree++] = dwCoffs;
1391 1391:     }
1392 1392: 
1393 1393:     /* 3.2: Update cache count of used slots */
1394 1394:     pstDBx->stCache.dwCused = (dwCfree > (DWORD) 0L ? dwCfree-1 : dwCused);
1395 1395:     D(eKeyCacheDump(pstDBx, FALSE);)
1396 1396: 
1397 1397:     /* Function complete : return ok */
1398 1398:     STCK("eKeyCacheSearch");
1399 1399:     KRET_OK
1400 1400: 
1401 1401: } /* END function eKeyCacheSearch() */
1402 1402: 
1403 1403: 
1404 1404: 
1405 1405: /*+3 MODULE KEY.C-----------------------------------------------------------*/
1406 1406: /*   NAME   08                 eKeyCacheAlloc                               */
1407 1407: /*-- SYNOPSIS --------------------------------------------------------------*/
1408 1408: #define INITSIZE   100L        /* Initial size of new cache array: MIN 2! */
1409 1409: #define PANIC      1.2         /* Fallback resize factor (bad malloc) */
1410 1410: 
1411 1411: 
1412 1412: PUBLIC    eRetType
1413 1413: eKeyCacheAlloc(pstCache, rResize)
1414 1414:     CACHE    *pstCache;        /* Pointer to cache datastructure */
1415 1415:     double    rResize;         /* Multiplication factor for resizing cache */
1416 1416: {
1417 1417: /* DESCRIPTION
1418 1418:  *    Allocate cache-array for struct. <pstCache> to hold datarecord-offsets.
1419 1419:  *
1420 1420:  *    1: If no array is defined for <pstCache>
1421 1421:  *            MALLOC it from scratch with a startsize of <INITSIZE>
1422 1422:  *    2: Else
1423 1423:  *       2.1: REALLOC it to new size determined by the factor <rResize>; 
1424 1424:  *       2.2: make it robust, using a fallback value of <rResize>.
1425 1425:  *    3: RESET cache structure variables: cache array-pointer & -size
1426 1426:  *
1427 1427:  * RETURN
1428 1428:  *    Side effects ........: Cache array (re)alloc'ed to specified size.
1429 1429:  *                           Cache struct. fields updated accordingly.
1430 1430:  *    Function return value: OK if operation succeeded, ERROR otherwise; -
1431 1431:  *                           If ERROR, "Kstat" holds the precise error code.
1432 1432:  * SEE ALSO
1433 1433:  *    The function eKeyCacheFree() in module key.c.
1434 1434:  *-3*/
1435 1435: 

XC ... 'C' Concordance Utility   KEY.c                      Page 27

1436 1436:     DWORD(*p)[] = pstCache->padwData;  /* Pointer to old cache, if any */
1437 1437:     DWORD(*q)[] = NULL;                /* Pointer to new cache, if realloc */ 
1438 1438:     register DWORD dwNewSize = 0L;     /* Size of new cache (# slots) */
1439 1439: 
1440 1440: 
1441 1441:     /* 1: If no cache defined, ALLOCATE NEW array of size INITSIZE */
1442 1442:     if (p == NULL) {
1443 1443: 
1444 1444: 	/* No cache, - allocate new of initial size INITSIZE */
1445 1445: 	dwNewSize = INITSIZE;
1446 1446: 	assert(dwNewSize > 2);   /* Ensure quadratic expansion on realloc */
1447 1447: 
1448 1448: 	p = (DWORD((*)[])) malloc( (size_t) (sizeof(DWORD) * dwNewSize));
1449 1449: 	KRET_ERR(p == NULL, K_BADALLOC, 800)
1450 1450:     }
1451 1451: 
1452 1452:     else {
1453 1453: 
1454 1454:     /* 2: Else (cache defined), REALLOCATE EXISTING array to oldsize*rResize */
1455 1455:     L_Again:
1456 1456: 
1457 1457:        /* 2.1: Active cache, - reallocate it using factor <rResize> */
1458 1458:        dwNewSize = (DWORD) (((double) pstCache->dwCsize) * rResize);
1459 1459:        KRET_ERR(dwNewSize <= (DWORD) 0L, K_BADARGS, 801)
1460 1460: 
1461 1461:        D(printf("eKeyCacheAlloc: dwCsize[%lu], rResize[%.2f], dwNewSize[%lu]\n",
1462 1462:                  pstCache->dwCsize, rResize, dwNewSize);)
1463 1463: 
1464 1464:        q = (DWORD((*)[])) realloc((void *) p, (size_t) (sizeof(DWORD) * dwNewSize));
1465 1465: 
1466 1466: 
1467 1467:        /* 2.2.a: Bad alloc, - retry with <rResize> reduced to factor PANIC */
1468 1468:        if (q == NULL && rResize > (double) PANIC) {
1469 1469:            rResize = (double) PANIC;
1470 1470:            goto L_Again;   /* Try once more (NOT considered harmfull...) */
1471 1471:        }
1472 1472: 
1473 1473:        /* 2.2.b: Realbad alloc, - bail out, but reset cache for next list */
1474 1474:        if (q == NULL) {
1475 1475:            (void) eKeyCacheFree(pstCache);
1476 1476:            KRET_ERR(q == (DWORD((*)[])) NULL, K_BADALLOC, 802) /* Bail out! */
1477 1477:        }
1478 1478: 
1479 1479:        /* 2.3: Realloc OK, point to resized cache */
1480 1480:        p = q;
1481 1481:     }
1482 1482: 
1483 1483: 
1484 1484:     /* 3: Reset cache structure variables: cache array-pointer & -size */
1485 1485:     pstCache->padwData = p;                /* New or resized cache */
1486 1486:     pstCache->dwCsize = dwNewSize - 1L;    /* Index range [1 ... dwNewSize] */
1487 1487:     D(printf("eKeyCacheAlloc: dwCsize[%lu], rResize[%.2f], dwNewSize[%lu]\n",
1488 1488:               pstCache->dwCsize, rResize, dwNewSize);)
1489 1489: 
1490 1490: 
1491 1491:     /* Function complete : return ok */

XC ... 'C' Concordance Utility   KEY.c                      Page 28

1492 1492:     STCK("eKeyCacheAlloc");
1493 1493:     KRET_OK
1494 1494: 
1495 1495: } /* END function eKeyCacheAlloc() */
1496 1496: 
1497 1497: 
1498 1498: 
1499 1499: /*+3 MODULE KEY.C ----------------------------------------------------------*/
1500 1500: /*   NAME   09                 eKeyCacheFree                                */
1501 1501: /*-- SYNOPSIS --------------------------------------------------------------*/
1502 1502: PUBLIC    eRetType
1503 1503: eKeyCacheFree(pstCache)
1504 1504:     CACHE    *pstCache;       /* Pointer to cache datastructure */
1505 1505: {
1506 1506: /*
1507 1507:  * DESCRIPTION
1508 1508:  *    Deallocate cache-array for struct <pstCache>.
1509 1509:  *
1510 1510:  *    1: FREE the cache-array of struct. <pstCache>.
1511 1511:  *    2: RESET the cache structure fields to NULL/0.
1512 1512:  *
1513 1513:  * RETURN
1514 1514:  *    Side effects ........: Cache array deallocated (ie. RAM free'd).
1515 1515:  *                           Cache struct. fields reset accordingly (NULL/0).
1516 1516:  *    Function return value: OK if operation succeeded, ERROR otherwise; -
1517 1517:  *                           If ERROR, "Kstat" holds the precise error code.
1518 1518:  * SEE ALSO
1519 1519:  *    The function eKeyCacheAlloc() in module key.c
1520 1520:  *-3*/
1521 1521: 
1522 1522:     /* 1: FREE cache array */
1523 1523:     if (pstCache->padwData != NULL) {
1524 1524: 	free((char *) pstCache->padwData);
1525 1525: 	pstCache->padwData = NULL;
1526 1526:     }
1527 1527: 
1528 1528: 
1529 1529:     /* 2: RESET cache size to zero */
1530 1530:     pstCache->dwCsize = 0L;
1531 1531:     pstCache->dwCused = 0L;
1532 1532: 
1533 1533: 
1534 1534:     /* Function complete : return ok */
1535 1535:     STCK("eKeyCacheFree");
1536 1536:     KRET_OK
1537 1537: 
1538 1538: } /* END function eKeyCacheFree() */ 
1539 1539: 
1540 1540: 
1541 1541: 
1542 1542: 
1543 1543: /****************************************************************************/
1544 1544: /******************************** BUFFER ************************************/
1545 1545: /****************************************************************************/
1546 1546: 
1547 1547: 

XC ... 'C' Concordance Utility   KEY.c                      Page 29

1548 1548: 
1549 1549: /*+3 MODULE KEY.C-----------------------------------------------------------*/
1550 1550: /*   NAME   10                 eKeyBufScan                                  */
1551 1551: /*-- SYNOPSIS --------------------------------------------------------------*/
1552 1552: /*+0*/
1553 1553: /* Definition of KeySpec separators in KeyList */
1554 1554: #define KEYSEP     ','        /* Keylist keyspecification separator */
1555 1555: #define KEYEOL     '\0'       /* End-Of-List */
1556 1556: 
1557 1557: /* Definition of metachars for KeyClass and KeyRange specification */
1558 1558: #define KEYEXP     '-'        /* Keyspec. expansion indicator: range/class */
1559 1559: #define K_A        '*'        /* Metachar alfanumeric: digit | letter */
1560 1560: #define K_D        '#'        /* Metachar digit .....: [0-9] */
1561 1561: #define K_L        '@'        /* Metachar letter.....: [a-A-] */
1562 1562: 
1563 1563: /* Definition of character collating sequence for expansion of KeySpec's */
1564 1564: static const char acAlnum[] =
1565 1565:    "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
1566 1566: 
1567 1567: #define CHRPOS(c)  strchr(acAlnum, (int) c)
1568 1568: #define KEYDGT(i)  ( (acAlnum <= pB[i]) && (pE[i] <= acAlnum+9) )
1569 1569: 
1570 1570: /* Declaration of static arrays for expansion of KeySpec's */
1571 1571: static char *pB[KEYMAX];       /* Ptrs into acAlnum, for start KeyValue */
1572 1572: static char *pW[KEYMAX];       /* Ptrs into acAlnum, for work KeyValue */
1573 1573: static char *pE[KEYMAX];       /* Ptrs into acAlnum, for end KeyValue */
1574 1574: static int iCB[KEYMAX];        /* #Decimal "clicks", for start KeyValue */
1575 1575: static int iCW[KEYMAX];        /* #Decimal "clicks", for work KeyValue */
1576 1576: 
1577 1577: #define EXPDEC		       /* Uncomment to enable decimal interpretation */
1578 1578: /*-0*/
1579 1579: 
1580 1580: PRIVATE   eRetType
1581 1581: eKeyBufScan(pstDBx, ppzKeyList, ppzKeyStr)
1582 1582:     DBASE    *pstDBx;         /* Pointer to DBASE structure (w. key size) */
1583 1583:     char     **ppzKeyList;    /* Addr. of ptr. for walking the key-list */
1584 1584:     char     **ppzKeyStr;     /* Addr. of ptr. for returning retrieved key */
1585 1585:                               /* NB: *ppzKeyStr MUST be NULL on first call */
1586 1586: {
1587 1587: /* DESCRIPTION
1588 1588:  *    Scans a string <*ppzKeyList> containing one (or more, comma-separated)
1589 1589:  *    key specifications, and sets the stringpointer <*ppzKeyStr> on the
1590 1590:  *    substring of the next key-value to retrieve; The substring is zero-
1591 1591:  *    terminated before return from eKeyBufScan().
1592 1592:  *
1593 1593:  *    The precise SYNTAX of <*ppzKeyList> is as follows, where :
1594 1594:  *       {} means 0-more repetitions, | means alternative expressions, and
1595 1595:  *       a blank character indicates contatenation (NB: no whitespace allowed)
1596 1596:  *       *ppzKeyList ::=       {KeySpec,} KeySpec KEYEOL
1597 1597:  *       KeySpec     ::=   |   KeyValue                    // one key value
1598 1598:  *                         |   KeyValue KEYEXP KeyValue    // a key range
1599 1599:  *                             KeyClass KEYEXP             // a key class
1600 1600:  *       KeyValue    ::=       a string of exactly KeyLen
1601 1601:  *                             of arbitrary ASCII chars or numeric chars
1602 1602:  *                             depending on access method (VA, SS, ...)
1603 1603:  *       KeyClass    ::=       a KeyValye with possible embedded metachars :

XC ... 'C' Concordance Utility   KEY.c                      Page 30

1604 1604:  *            K_A    ::=       alphanumeric :  digit | letter
1605 1605:  *            K_D    ::=       digit        :  [0-9]
1606 1606:  *            K_L    ::=       letter       :  [a-A-]
1607 1607:  *
1608 1608:  *    Example of a valid keylist : "20240,20259,20713-20772,649#3-,01267"
1609 1609:  *       20240,20259 : two single KeyValues
1610 1610:  *       20713-20772 : a range of KeyValues : 20713,20714,20715, ... ,20772
1611 1611:  *       649#3-      : a class of KeyValues : 64903,64913,64923, ... ,64993
1612 1612:  *       01267       : one more single KeyValue
1613 1613:  *
1614 1614:  * RETURN
1615 1615:  *    Side effects ........: *ppzKeyStr pointed at start of next key-substring
1616 1616:  *                           in *ppzKeyList, and key-substring zero-terminated
1617 1617:  *    Function return value: OK if operation succeeded, ERROR otherwise; -
1618 1618:  *                           If ERROR, "Kstat" holds the precise error code.
1619 1619:  *                           (End-Of-Line is treated as error with code K_EOL)
1620 1620:  * BUGS
1621 1621:  *    The scanner algorithm for the keylist-string is rather "unforgiving" :
1622 1622:  *    each KeyValue MUST be specified with precise length (no attempt of error
1623 1623:  *    recovery is made such as "patching" a too short key or "chopping" a too
1624 1624:  *    long key to the required length), and an incorrect key will result in
1625 1625:  *    immediate "abortion" of the KeyList scanning (w. error code K_BADLIST).
1626 1626:  *    No escape mechanism is provided for the KeyClass metachars.
1627 1627:  *
1628 1628:  *    Some key access methods (such as scatter-storage : SS/"hashing") is
1629 1629:  *    not well suited for sequential access. I have never the less provided a
1630 1630:  *    syntax for specifying a Range or Class of KeyValues in the KeyList
1631 1631:  *    parameter, - but BE WARNED : in a specification expanding to many (more
1632 1632:  *    than 100) KeyValues, the key lookup-operations required to setup the
1633 1633:  *    cache-array may consume a substantial amount of time (for a SS-key:
1634 1634:  *    6-12sec/100 keys, depending on key "hit rate" and machine type).
1635 1635:  *+0
1636 1636:  * IMPLEMENTATION
1637 1637:  *    The expansion of a KeyClass or KeyRange is done by the following means
1638 1638:  *    (which is by no means trivial ...) :
1639 1639:  *     - a boolean variable (fKeyExpand) is toggled ON, when a KeyClass or
1640 1640:  *       KeyRange is first met in the sequential scanning of the KeyList;
1641 1641:  *       the first KeyValue in the expansion is returned to the caller.
1642 1642:  *     - a "trap" is set up at the start of the function to "catch" the
1643 1643:  *       flow of control at subsequent calls, whenever fKeyExpand is ON;
1644 1644:  *       Inside the "trap" I generate the next KeyValue in the defined
1645 1645:  *       class/range, test if that value completes the expansion (in which
1646 1646:  *       case I toggle fKeyExpand OFF), and return the KeyValue to the caller.
1647 1647:  *
1648 1648:  *    In order to remember the state of expansion for all character-positions
1649 1649:  *    in the key BETWEEN function calls, I define 3 STATIC arrays to hold the
1650 1650:  *    begin-character pB[i], end-character pE[i] and current "work"-character
1651 1651:  *    pW[i] for the expansion of each position i in the KeyClass/KeyRange
1652 1652:  *    specification.
1653 1653:  *
1654 1654:  *    Expansion of digit-sequence(s) in a KeyRange can be handled in two ways:
1655 1655:  *     - EXPDEC not #defined : ordinary character expansion, with no signifi-
1656 1656:  *       cance attached to the positions of the digits.
1657 1657:  *       Example 15-29 -> [15,16,17,18,19,25,26,27,28,29]
1658 1658:  *     - EXPDEC is  #defined : decimal character expansion, ie. each digit
1659 1659:  *       expanded according to its position in the digit-sequence. This is

XC ... 'C' Concordance Utility   KEY.c                      Page 31

1660 1660:  *       probably what you want, so I have made this option default.
1661 1661:  *       Example 15-29 -> [15,16,17,18,19,20,21,22,23,24,25,26,27,28,29]
1662 1662:  *
1663 1663:  *    For the purpose of decimal character expansion, I define a new STATIC
1664 1664:  *    array iCB[i] to hold the number of "clicks" (ie. [0-9] runs) to "turn"
1665 1665:  *    each digit position i for a full expansion. This in effect is a small
1666 1666:  *    analog "difference engine" with symbolic gear-wheels for the decimal
1667 1667:  *    addition operation (Charles Babbage, personal communication...).
1668 1668:  *    Finally, for handling multiple digital runs embedded in an alphabetic
1669 1669:  *    KeyRange, I introduce the STATIC "work" array iCW[i], which is reset
1670 1670:  *    to iCB[i] each time we hit an alphabetic position in the key-expansion.
1671 1671:  *
1672 1672:  *    This design is an ultimate consequence of my wish to treat a KeyValue
1673 1673:  *    as an arbitrary string composed of digits and/or alphabetic characters,
1674 1674:  *    so I accept the complexity of key-expansion in the name of generality
1675 1675:  *    (- and besides : it was fun to "crack" the problem !).
1676 1676:  *-0
1677 1677:  *-3*/
1678 1678: 
1679 1679:     /* Setup length of actual KeyList and KeyValue */
1680 1680:     WORD        wListLen  = strlen(*ppzKeyList); /* Length of keylist string */
1681 1681:     WORD        wKeyLen   = 0;         /* Length of one key in <pzKeyList> */
1682 1682:     char        *pcKeySep = NULL;      /* Ptr's to delimit of KeyValue */
1683 1683:     char        *pc       = NULL;      /* Ptr's to delimit of KeyValue */
1684 1684:     register    int i=0, j=0;          /* Scratch int : count variables */
1685 1685: 
1686 1686:     /* Variables for KeyValue expansion */
1687 1687:     static FLAG fKeyExpand = FALSE;    /* Boolean: expansion? */
1688 1688:     FLAG        fDigits    = FALSE;    /* Boolean: digit-range? */
1689 1689:     char        *pEnd      = NULL;     /* Ptr to end char of expansion */
1690 1690:     char        cb=0, ce=0, cw=0;      /* Scratch char: begin, end, work */
1691 1691: 
1692 1692: 
1693 1693: 
1694 1694:     /*----------------------------------------------------------------------*/
1695 1695:     /* 0: Initialize variables                                              */
1696 1696:     /* Define fixed keylength for parse of the key-list: <ppzKeyStr>        */
1697 1697:     /* BUG: we should allow var-length keystring, relying on key separators */
1698 1698: #ifdef SS
1699 1699:     /* SS-key: Keylength included as field in key-struct */
1700 1700:     wKeyLen = pstDBx->pIndex->indexsize.wKsize;
1701 1701: #endif /*SS*/
1702 1702: #ifdef VA
1703 1703:     /* VA-key: Assume fixed default keylength (might include MAX in VA-struct) */
1704 1704:     wKeyLen = KEYLEN;
1705 1705: #endif /*VA*/
1706 1706:     assert(wKeyLen > 0);
1707 1707: 
1708 1708: 
1709 1709:     /*----------------------------------------------------------------------*/
1710 1710:     /* 1: Trap flow-of-control when inside KeyClass- or KeyRange-expansion; */
1711 1711:     /* - The first key in an expansion is generated in KEYEXP-switch below. */
1712 1712:     /* - The following keys are genereted by this key-expansion codeblock.  */
1713 1713:     /* - When expansion complete, fKeyExpand<-OFF and cntl "falls through". */
1714 1714: 
1715 1715:     /* Reset trap, when function called with new keylist! */

XC ... 'C' Concordance Utility   KEY.c                      Page 32

1716 1716:     if (*ppzKeyStr == NULL)
1717 1717:        fKeyExpand = FALSE;
1718 1718: 
1719 1719:     /* If trap active (lookout: here the bits hit the fan...) */
1720 1720:     if (fKeyExpand) {
1721 1721: 
1722 1722:        /* Step through key pointer-arrays: left<-right */
1723 1723:        for (i = wKeyLen - 1; i >= 0; i--) {
1724 1724: 
1725 1725:            /* At pos i: step work-ptr pW[i] from pB[i] to pEnd in acAlnum[] */
1726 1726:            pEnd = (iCW[i] > 0 ? CHRPOS('9') : pE[i]);	/* click defined? */
1727 1727:            if (pW[i] < pEnd) {
1728 1728: 
1729 1729:               /* Increment work-ptr at pos i & xfer char acAlnum->KeyValue */
1730 1730:               /* If char xfer'd was '9', count down #clicks for position i */
1731 1731:               *(*ppzKeyStr + i) = *(++(pW[i]));
1732 1732:               if (pW[i] == CHRPOS('9') && iCW[i] > 0)
1733 1733:                  iCW[i]--;
1734 1734: 
1735 1735:               /* Reset KeyValue & click-array in all pos. j to the right of i */
1736 1736:               for (j = i + 1, fDigits = KEYDGT(i); (WORD) j < wKeyLen; j++) {
1737 1737:                  fDigits = (fDigits && KEYDGT(j));
1738 1738:                  pW[j] = (iCW[j] >= 0 && fDigits ? CHRPOS('0') : pB[j]);
1739 1739:                  *(*ppzKeyStr + j) = *pW[j];
1740 1740:                  iCW[j] = (!fDigits ? iCB[j] : iCW[j]);
1741 1741:               }
1742 1742: 
1743 1743:               /* Key now generated, - break enclosing for-loop! */
1744 1744:               D(printf("Expanded KeyValue : [%s]\n", *ppzKeyStr));
1745 1745:               break;
1746 1746:            }
1747 1747:            /* else (pW[i] >= pE[i]): range at pos i already done! */
1748 1748:            /* Proceed with KeyValue[i-1], until KeyValue[0] */
1749 1749:        }
1750 1750: 
1751 1751:        /* If new KeyValue generated (ie: i < 0), return it to caller */ 
1752 1752:        fKeyExpand = (i < 0 ? FALSE : TRUE);
1753 1753:        if (fKeyExpand)
1754 1754:            KRET_OK
1755 1755: 
1756 1756:        /* Else continue processing KeyList : "Fall Through" to 2: */
1757 1757:        /* NB: ppzKeyStr already advanced in KEYEXP-switch below ! */
1758 1758: 
1759 1759:     } /* END [1]: Key Expansion active */
1760 1760: 
1761 1761: 
1762 1762: 
1763 1763:     /*----------------------------------------------------------------------*/
1764 1764:     /* 2: Key expansion NOT active, retrieve next key directly from KeyList */
1765 1765: 
1766 1766:     /* Check for KeyList exhausted */
1767 1767:     KRET_ERR((**ppzKeyList == KEYEOL), K_EOL, 1000)
1768 1768: 
1769 1769:     /* Reset decimal "click" arrays */
1770 1770:     for (i = 0; (WORD) i < wKeyLen; i++)
1771 1771: 	iCB[i] = iCW[i] = -1;

XC ... 'C' Concordance Utility   KEY.c                      Page 33

1772 1772: 
1773 1773:     /* Point past end of next key, and check key length  */
1774 1774:     pcKeySep = *ppzKeyList + wKeyLen;
1775 1775:     KRET_ERR((pcKeySep > (*ppzKeyList + wListLen)), K_BADLIST, 1001)
1776 1776: 
1777 1777: 
1778 1778:     /* Setup pointer to retrieve the next key... */
1779 1779:     switch (*pcKeySep) {
1780 1780: 
1781 1781: 	case KEYEXP:            /* A KEY EXPANSION */
1782 1782: 	    /* --------------------------------------------------------------*/
1783 1783: 	    /* Activate *KEYCLASS* expansion, ie. <KeyClass KEYEXP>          */
1784 1784: 
1785 1785: 	    /* Check valid format of KeyClass specification */
1786 1786:            if ((*(pcKeySep + 1) == KEYSEP || *(pcKeySep + 1) == KEYEOL)) {
1787 1787: 
1788 1788:               /* Setup arrays of char-pointers for generating key class */
1789 1789:               for (i = 0; (WORD) i < wKeyLen; i++) {	/* Scan key left->right */
1790 1790: 
1791 1791:                  /* Set Begin-char and End-char for KeyValue in position i */
1792 1792:                  cw = *(*ppzKeyList + i);	/* Retrieve next key-char */
1793 1793:                  cb = (char) (cw == K_D ? '0' : (cw == K_L ? 'a' : (cw == K_A ? '0' : cw)));
1794 1794:                  ce = (char) (cw == K_D ? '9' : (cw == K_L ? '' : (cw == K_A ? '' : cw)));
1795 1795: 
1796 1796:                  /* Set Begin-, Work- and End-ptr. for KeyValue in pos. i */
1797 1797:                  pB[i] = pW[i] = CHRPOS(cb);
1798 1798:                  pE[i] = CHRPOS(ce);
1799 1799: 
1800 1800:                  /* Reset KeyValue in KeyList to beginning value */
1801 1801:                  if (pW[i] != NULL)
1802 1802:                     *(*ppzKeyList + i) = *pW[i];
1803 1803: 
1804 1804:               } /* END Setup c-arrays */
1805 1805: 
1806 1806:               /* Set pointer past KeyClass */
1807 1807:               pc = pcKeySep + 1;
1808 1808: 
1809 1809:            } /* END activate *KEYCLASS* expansion */
1810 1810: 
1811 1811:            else {
1812 1812:            /* --------------------------------------------------------------*/
1813 1813:            /* Activate *KEYRANGE* expansion, ie. <KeyValue KEYEXP KeyValue> */
1814 1814:                         
1815 1815:               /* Set ptr. past KeyRange & Check valid format of KeyRange spec. */
1816 1816:               pc = pcKeySep + wKeyLen + 1;
1817 1817:               KRET_ERR(*pc != KEYSEP && *pc != KEYEOL, K_BADLIST, 1002)
1818 1818:               KRET_ERR(pc > (*ppzKeyList + wListLen), K_BADLIST, 1003)
1819 1819: 
1820 1820:               /* Set Begin-, Work- and End- charptr. arrays for KeyValue */
1821 1821:               for (i = 0; (WORD) i < wKeyLen; i++) {
1822 1822:                  pB[i] = pW[i] = CHRPOS(*(*ppzKeyList + i));
1823 1823:                  pE[i] = CHRPOS(*(pcKeySep + 1 + i));
1824 1824:               }
1825 1825: 
1826 1826: #ifdef EXPDEC
1827 1827:               /* If decimal interpretation of digit sequence is enabled : */

XC ... 'C' Concordance Utility   KEY.c                      Page 34

1828 1828:               /* Set decimal "Click-count" for all digital (sub-)range(s) */
1829 1829:               for (i = 0; (WORD) i < wKeyLen; i++) {
1830 1830: 
1831 1831:                  if (KEYDGT(i) && pB[i] != pE[i]) {
1832 1832: 
1833 1833:                     /* Invalid KeyRange (begin > end) : set end = begin */
1834 1834:                     if (pB[i] > pE[i])
1835 1835:                        while (((WORD)++ i < wKeyLen) && KEYDGT(i))
1836 1836:                           pE[i] = pB[i];
1837 1837:                     else
1838 1838:                        /* Valid KeyRange : setup click-count arrays */
1839 1839:                        /* Step i through one digital (sub)range */
1840 1840:                        for (iCW[i]=iCB[i]=0, j=i+1; (WORD) i < wKeyLen && KEYDGT(i); i++, j++) {
1841 1841: 
1842 1842:                           /* Set click-counter for next pos (j) in the digital (sub)range */
1843 1843:                           if ( (WORD)j < wKeyLen && KEYDGT(j) ) {
1844 1844:                              iCW[j] = iCB[j] = iCB[i] * 10 + (pE[i]-pB[i]);           
1845 1845:                              D(printf("   Pos %d:[%c]->Pos %d:[%c] : Click[%d]\n",
1846 1846:                                 i, *pB[i], j, *pE[j], iCW[j]));
1847 1847:                           } /* END j: calculate click for pos.j(=i+1), based at i */
1848 1848: 
1849 1849:                        } /* END i: calculate clicks for one (sub)range (stepping i) */
1850 1850: 
1851 1851:                  } /* END if KEYDGT(i) */
1852 1852:                  /* else: not digits or equal digits, - ignore */
1853 1853: 
1854 1854:               } /* END for i in [0,wKeyLen-1] */
1855 1855: #endif	/* EXPDEC */
1856 1856: 
1857 1857:            } /* END Activate *KEYRANGE* expansion */
1858 1858: 
1859 1859: 
1860 1860: 	    /* ------------------------------------------------------------- */
1861 1861: 	    /* KeySpec expansion (*KEYCLASS* and *KEYRANGE*)                 */
1862 1862: 
1863 1863: 	    /* Setup for return of first KeyValue in key-expansion */
1864 1864: 	    *pcKeySep  = '\0';          /* Zero-term. KeyValue string */
1865 1865: 	    *ppzKeyStr = *ppzKeyList;   /* Return 1. KeyValue in KeyExp */
1866 1866: 
1867 1867: 	    /* Setup for processing rest of KeyList */
1868 1868: 	    *ppzKeyList = pc;           /* Point past KeyExp */
1869 1869: 	    *ppzKeyList += (**ppzKeyList == KEYSEP ? 1 : 0);
1870 1870: 
1871 1871: 	    D(printf("Expanded KeyValue : [%s]\n", *ppzKeyStr));
1872 1872: 	    fKeyExpand = TRUE;          /* Raise KeyExpansion flag */
1873 1873: 	    break;
1874 1874: 
1875 1875: 
1876 1876: 	case KEYSEP:            /* ONE VALID KEY (comma separated) */
1877 1877: 	    /* Setup for return of current KeyValue */
1878 1878: 	    *pcKeySep  = '\0';          /* Zero-term. KeyValue string */
1879 1879: 	    *ppzKeyStr = *ppzKeyList;   /* Return this key string segment */
1880 1880: 
1881 1881: 	    /* Setup for processing rest of KeyList */
1882 1882: 	    *ppzKeyList = (pcKeySep+1); /* Point past KeyValue */
1883 1883: 	    break;

XC ... 'C' Concordance Utility   KEY.c                      Page 35

1884 1884: 
1885 1885: 
1886 1886: 	case KEYEOL:            /* LAST KEY (zero-terminated) */
1887 1887: 	    /* Setup for return of last KeyValue, - already zero-terminated */
1888 1888: 	    *ppzKeyStr = *ppzKeyList;   /* Return this key string segment */
1889 1889: 
1890 1890: 	    /* Setup for processing rest of KeyList */
1891 1891: 	    *ppzKeyList = pcKeySep;     /* Point past KeyValue, - to K_EOL */
1892 1892: 	    break;
1893 1893: 
1894 1894: 
1895 1895: 	default:                /* BAD KEY-LIST FORMAT */
1896 1896: 	    D(fprintf(stderr, "BAD KEYLIST FORMAT ->[%s]\n", *ppzKeyList));
1897 1897: 	    KRET_ERR(YES, K_BADLIST, 1004)      /*CONSTVAL*/
1898 1898: 	    break;
1899 1899: 
1900 1900:     } /* END switch (*pcKeySep): setup ptr. <*ppzKeyStr> to retrieve key */
1901 1901: 
1902 1902: 
1903 1903:     /* Function complete : return ok */
1904 1904:     STCK("eKeyBufScan");
1905 1905:     KRET_OK
1906 1906: 
1907 1907: } /* END function eKeyBufScan () */
1908 1908: 
1909 1909: 
1910 1910: 
1911 1911: /*+2 MODULE KEY.C ==========================================================*/
1912 1912: /*   NAME   11                 eKeyBufRead                                  */
1913 1913: /*== SYNOPSIS ==============================================================*/
1914 1914: PRIVATE eRetType
1915 1915: eKeyBufRead(fdData, pstBF, pdwOff)
1916 1916:     FILE     *fdData;         /* File pointer for datafile */
1917 1917:     BUFFER   *pstBF;          /* Ptr. to BUFFER structure for read */
1918 1918:     DWORD    *pdwOff;         /* Offset of record to read */
1919 1919: {
1920 1920: /* DESCRIPTION
1921 1921:  *   Read ONE datarecord from the datafile identified by file pointer <fdData>
1922 1922:  *   to the buffer specified by <pstBF>; Record to be read depends on <pswOff>:
1923 1923:  *    - *pdwOff != NEXT : Retrieve specified datarecord (file offset: <pdwOff>)
1924 1924:  *    - *pdwOff  = NEXT : Retrieve next datarecord (from current datafile pos)
1925 1925:  *
1926 1926:  *   1: RESET...
1927 1927:  *      1.1: RESET DATAFILE pos., according to <pdwOff> (catch EOF on datafile)
1928 1928:  *      1.2: RESET BUFFER pos. & size (to empty buffer)
1929 1929:  *   2: LOOP:
1930 1930:  *         read one line from datafile to buffer
1931 1931:  *         update current buffer position & size
1932 1932:  *      until (KEYMARK of next rec or EOF)
1933 1933:  *
1934 1934:  * RETURN
1935 1935:  *    Side effects ........: One datarecord specified by: <fdData>,<pdwOff>
1936 1936:  *                           read to buffer <pstBF>.
1937 1937:  *    Function return value: OK if operation succeeded, ERROR otherwise; -
1938 1938:  *                           If ERROR, "Kstat" holds the precise error code.
1939 1939:  *-2*/

XC ... 'C' Concordance Utility   KEY.c                      Page 36

1940 1940:     register char *pcBinp   = NULL;    /* BUF: current buffer input pointer */
1941 1941:     register WORD wBsiz     = 0L;      /* BUF: current size of buffer (#byte left) */
1942 1942:     WORD          wBLlen    = 0L;      /* BUF: length of current buffer Line */
1943 1943:     int           iRetCode  = 1;       /* fseek() ret.code: 0=OK, !0=ERR */
1944 1944:     char         *pcRetCode = NULL;    /* fgets() ret.code: !NULL=OK, NULL=ERR */
1945 1945:     BYTE          bPeek     = (BYTE)0; /* char obtained by "peek" on stdin */
1946 1946: 
1947 1947: 
1948 1948:    /* 1.1: RESET DATAFILE position, according to <pdwOff> */
1949 1949:    if (*pdwOff != NEXT) {           /* Read from specified file offset */
1950 1950:       iRetCode = fseek(fdData, *pdwOff, SEEK_SET);
1951 1951:       KRET_ERR(iRetCode != 0, K_DATSEEK, 1100)
1952 1952:    } else                          /* Read from current file position */
1953 1953:       *pdwOff = ftell(fdData);    
1954 1954: 
1955 1955:    /* Catch EOF on datafile */
1956 1956:    KRET_ERR(feof(fdData), K_DATEOF, 1101)
1957 1957: 
1958 1958: 
1959 1959:    /* 1.2: RESET BUFFER pointer & size (to empty buffer) */
1960 1960:    pcBinp = pstBF->pzBaddr;     /* Init buffer input-ptr to buf.start */
1961 1961:    wBsiz  = pstBF->wBsize;      /* Init rest size to full buffer size */
1962 1962: 
1963 1963: 
1964 1964:     /* 2: LOOP: READ record lines (until KEYMARK of new rec or EOF) */
1965 1965:     do {
1966 1966:        /* Read one line from datafile to buffer */
1967 1967:        pcRetCode = fgets(pcBinp, wBsiz, fdData);
1968 1968:        KRET_ERR(pcRetCode == NULL && !fdData, K_DATREAD, 1102)
1969 1969: 
1970 1970:        /* Update current buffer pos. & size (advance pos., decrement size) */
1971 1971:        wBLlen = strlen(pcBinp);  /* Length of rec line, excl. term. '\0' */
1972 1972:        pcBinp += wBLlen;         /* Advance to terminal '\0' from fgets */
1973 1973:        wBsiz  -= wBLlen;         /* Count down buffer size */
1974 1974:        D(printf("TRACE: wBsiz[%d]\n", (int) wBsiz));
1975 1975:        KRET_ERR(wBsiz <=1, K_BUFOVFL, 1103)
1976 1976: 
1977 1977:        /* LookAhead: Peek next char */
1978 1978:        KRET_ERR(ungetc( (bPeek = (BYTE) getc(fdData)), fdData) == EOF, K_DATREAD, 1104)
1979 1979: 
1980 1980:     } while (bPeek != (BYTE) KEYMARK && !feof(fdData));
1981 1981:     /* Until next record || EOF */
1982 1982: 
1983 1983: 
1984 1984:    /* Debug trace */
1985 1985:    D(fputs("\nECHO DATA RECORD :\n", stdout));
1986 1986:    D(fputs(pstBF->pzBaddr, stdout));
1987 1987: 
1988 1988:    /* Function complete : return ok */
1989 1989:    STCK("eKeyBufRead");
1990 1990:    KRET_OK
1991 1991: 
1992 1992: } /* END function eKeyBufRead() */
1993 1993: 
1994 1994: 
1995 1995: 

XC ... 'C' Concordance Utility   KEY.c                      Page 37

1996 1996: /*+2 MODULE KEY.C ==========================================================*/
1997 1997: /*   NAME   12                    eKeyBufFill                               */
1998 1998: /*== SYNOPSIS ==============================================================*/
1999 1999: PRIVATE   eRetType
2000 2000: eKeyBufFill(pstDBx, pstBF, dwCbwinNew)
2001 2001:     DBASE    *pstDBx;         /* Handle of database-str. w. datafile */
2002 2002:     BUFFER   *pstBF;          /* Handle of buffer-str. w. bufferarea */
2003 2003:     DWORD    (*dwCbwinNew)[]; /* New window into cache array */
2004 2004: {
2005 2005: /* DESCRIPTION
2006 2006:  *    Fill the databuffer (address:pstBF->pzBaddr, length:pstBF->wBsize byte)
2007 2007:  *    with SEVERAL records read from the datafile (handle:pstDBx->fdData).
2008 2008:  *    The records to retrieve are specified by the pstDBx->stCache datastruct.
2009 2009:  *     - stCache.padwData[] holding an array of cach'ed datafile offsets
2010 2010:  *       (previously set up by : eKeyCacheFill() or eKeyCacheSearch())
2011 2011:  *     - stCache.dwCbwin[2] defining the range of cache-key'es currently
2012 2012:  *       held by the buffer : the old "buffer-window".
2013 2013:  *     - parameter <cCbwinNew[2]> defining the range of cache-key'es to be
2014 2014:  *       fill'ed into the buffer by eKeyBufFill() : the new "buffer-window".
2015 2015:  *
2016 2016:  *    1:   Set up shorthand pointers for easy access to cache buffer-windows.
2017 2017:  *
2018 2018:  *    2:   Retrieve all datarecords defined by the new cache buffer-window :
2019 2019:  *         LOOP FOR ALL slots in the buffer-window <dwCbwinNew[2]> ...
2020 2020:  *    2.1:    Set the datafile-pointer to the next cach'ed datafile-offset
2021 2021:  *    2.2:    Read the datarec. to the databuffer, in bursts of BLKSIZ chars :
2022 2022:  *            LOOP FOR EACH datarecord in the datafile <pstSBx->fdData>
2023 2023:  *    2.2.1:     Setup next blocksize (BLKSIZ, or less if buffer nearly full)
2024 2024:  *    2.2.2:     Read the block & check for completed record (KEYMARK present)
2025 2025:  *    2.2.3:     Move the buffer-readpointer to position after the block read
2026 2026:  *            WHILE (datarecord not complete AND more space in buffer)
2027 2027:  *         WHILE more slots in the new cache buffer-window
2028 2028:  *
2029 2029:  *    3:   If incomplete last datarecord, back up to previous KEYMARK in buffer.
2030 2030:  *    4:   Zero-terminate the datarecords, and clear to the buffer end.
2031 2031:  *    5:   Update the "old" cache buf.window to the datarec's now in the buffer.
2032 2032:  *
2033 2033:  * RETURN
2034 2034:  *    Side effects ........: Buffer pstBF->pzBaddr fill'd in with datarecords
2035 2035:  *                           (up to max pstBF->wBsize chars), according to
2036 2036:  *                           the specified new bufferwindow <dwCbwinNew[2]>.
2037 2037:  *                           The cache struct. bufferwindow dwCbwin[2] updated.
2038 2038:  *    Function return value: OK if operation succeeded, ERROR otherwise; -
2039 2039:  *                           If ERROR, "Kstat" holds the precise error code.
2040 2040:  *
2041 2041:  * BUGS
2042 2042:  *    The bufferfilling algorithm is rather simple minded as regards scrolling:
2043 2043:  *    we always perform a complete refill of the buffer without utilizing the
2044 2044:  *    possibility of moving already retrieved datarecords in RAM instead of
2045 2045:  *    re-reading them from the datafile on DISK.
2046 2046:  *    To implement a more intelligent bufferfilling algorithm, you must main-
2047 2047:  *    tain a list of offsets into the databuffer for each datarecord currently
2048 2048:  *    in the cache (cf. the "old" buffer-window).
2049 2049:  *-2*/
2050 2050: 
2051 2051:     D(DWORD  dwOld[2];)                /* CACHE: buf.window, OLD (DEBUG) */

XC ... 'C' Concordance Utility   KEY.c                      Page 38

2052 2052:     DWORD    dwNew[2];                 /* CACHE: buf.window, NEW */
2053 2053:     register DWORD dwNext = 0L;        /* CACHE: next cache slot for read-to-buf. */
2054 2054:     char    *pBF0    = pstBF->pzBaddr; /* BUFFER: start-of-datarecord ptr. */
2055 2055:     char    *pBF1    = pstBF->pzBaddr; /* BUFFER: start-of-datablock ptr. */
2056 2056:     char    *pBF2    = NULL;           /* BUFFER: end-of-datablock ptr. */
2057 2057:     WORD     wBFRest = 0L;             /* BUFFER: #byte left in databuffer */
2058 2058:     WORD     wBFBlock= 0L;             /* BUFFER: current blocksize to read */
2059 2059:     FILE    *fdDataFile=pstDBx->fdData;/* DATA: datafile handle */
2060 2060:     FLAG     fDone   = FALSE;          /* Boolean: TRUE when datarecord read */
2061 2061:     int      iSkip;                    /* [0|1] : include or skip KEYMARK */
2062 2062:     eRetType   eRetCode = ERROR;       /* Return code for key.c functions */
2063 2063:     eKeyStatus eScrCode = K_OK;        /* Return code for eKeyBufFill() */
2064 2064: 
2065 2065: 
2066 2066:     /* 1: Set up shorthand pointers for convenient access to cache buf.win */
2067 2067:     /* Get old buffer window (for DEBUG trace) */
2068 2068:     D(dwOld[0] = pstDBx->stCache.dwCbwin[0];)
2069 2069:     D(dwOld[1] = pstDBx->stCache.dwCbwin[1];)
2070 2070: 
2071 2071:     /* Get new buffer window, and assert range "in bounds" */
2072 2072:     dwNew[0] = (*dwCbwinNew)[0];
2073 2073:     dwNew[1] = (*dwCbwinNew)[1];
2074 2074:     assert(dwNew[0] >= 1L);
2075 2075:     assert(dwNew[1] >= dwNew[0]);
2076 2076:     assert(dwNew[1] <= pstDBx->stCache.dwCused);
2077 2077: 
2078 2078:     D(fprintf(stdout, "BufFil:\tTOP old[%lu]->new[%lu]\n\tBOT old[%lu]->new[%lu]\n",
2079 2079:                        dwOld[0], dwNew[0], dwOld[1], dwNew[1]));
2080 2080: 
2081 2081:     /* 2: LOOP through ALL slots in the new cache buffer-window ... */
2082 2082:     for ( dwNext = dwNew[0], fDone = FALSE, wBFRest = (WORD) 2;
2083 2083:           dwNext <= dwNew[1] && wBFRest > (WORD) 1;
2084 2084:           dwNext++, fDone = FALSE ) {
2085 2085: 
2086 2086: 	/* 2.1: Set filepointer on datarecord, using fileoffset in the cache */
2087 2087: 	eRetCode = (fseek(fdDataFile, (*(pstDBx->stCache.padwData))[dwNext], SEEK_SET)
2088 2088: 		    == 0 ? OK : ERROR);
2089 2089: 	KRET_ERR(eRetCode == ERROR, K_DATSEEK, 1200)
2090 2090: 
2091 2091: 	/* 2.2: LOOP Read ONE datarec. to buffer, in bursts of BLKSIZ chars */
2092 2092: 	pBF0  = pBF1;                   /* remember start of datarecord */
2093 2093: 	iSkip = 1;                      /* skip 1. KEYMARK in datarecord */
2094 2094: 	do {
2095 2095: 
2096 2096:            /* 2.2.1: Setup next BLKSIZ block to read */
2097 2097:            wBFRest = pstBF->wBsize - (pBF1 - pstBF->pzBaddr);
2098 2098:            wBFBlock = (wBFRest > BLKSIZ ? BLKSIZ : wBFRest - 1);
2099 2099:            D(fprintf(stdout, "wBFrest[%d] - wBFBlock[%d]\n", wBFRest, wBFBlock));
2100 2100: 
2101 2101:            /* 2.2.2: Read the block & check if that completes the record read */
2102 2102:            if (wBFBlock > (WORD) 0) {
2103 2103: 
2104 2104:               /* Read next block of the datarecord from file */
2105 2105:               clearerr(fdDataFile);
2106 2106:               wBFBlock = (WORD) fread(pBF1, sizeof(char), wBFBlock, fdDataFile);
2107 2107: 

XC ... 'C' Concordance Utility   KEY.c                      Page 39

2108 2108:               /* Check for read-error and EOF */
2109 2109:               KRET_ERR(ferror(fdDataFile), K_DATREAD, 1201)
2110 2110:               if (feof(fdDataFile))
2111 2111:                  fDone = TRUE;
2112 2112: 
2113 2113:               /* Check if this block contains a KEYMARK (ie. read DONE!) */
2114 2114:               /* NOTE : memchr() interprets its args to "unsigned char" */
2115 2115:               if ((pBF2 = memchr(pBF1 + iSkip, (unsigned char) KEYMARK, wBFBlock)) != (char *) NULL)
            {
2116 2116:                 wBFBlock = pBF2 - pBF1;	/* usable part of the block */
2117 2117:                 fDone = TRUE;	            /* this datarecord finished */
2118 2118: 	       }
2119 2119: 	    }
2120 2120: 
2121 2121: 	    /* 2.2.3: Move buffer readpointer to position after block read */
2122 2122: 	    pBF1 += wBFBlock;
2123 2123: 	    iSkip = 0;
2124 2124: 
2125 2125: 	} while (!fDone && (wBFRest > 1));	/* reserve 1 byte for '\0' */
2126 2126:        /* END LOOP [2.2]: Block-Read of ONE datarecord */
2127 2127: 
2128 2128:     } /* END LOOP [2]: for #slots in cache buffer window (ie. #datarecs.) */
2129 2129:     /*   NB: Note the following conditions:                    */
2130 2130:     /* - inside the for-loop   : dwNext in dwNew[0]...dwNew[1] */
2131 2131:     /* - at exit (read succes) : dwNext =  dwNew[1]+1          */
2132 2132:     /* - at exit (buf. overfl) : dwNext =  cacheslot of incomplete last read+1 */
2133 2133: 
2134 2134: 
2135 2135:     /* 3: If incomplete last datarecord, back up to previous cacheslot/record */
2136 2136:     if (wBFRest == 1 && !fDone) {
2137 2137:        dwNext--;                   /* reset to slot AFTER last OK-read */
2138 2138:        pBF1 = pBF0;                /* reset to end of prev. record */
2139 2139:        eScrCode = K_BUFOVFL;       /* raise errorflag ("overflow!") */
2140 2140:     }
2141 2141: 
2142 2142: 
2143 2143:     /* 4: Zero-terminate the datarecords, and clear to buffer end ... */
2144 2144:     /* Terminate datarecords in the buffer */
2145 2145:     *pBF1++ = '\0';
2146 2146: 
2147 2147:     /* Clear from end of datarecords to buffer end */
2148 2148:     wBFRest = pstBF->wBsize - (pBF1 - pstBF->pzBaddr) - 1;
2149 2149:     if (wBFRest > 1) {
2150 2150: 	(void) memset(pBF1, ' ', wBFRest);
2151 2151: 	D((void) memset(pBF1, '*', wBFRest));
2152 2152:     }
2153 2153: 
2154 2154:     /* Terminate whole buffer (defensive programming) */
2155 2155:     *(pstBF->pzBaddr + pstBF->wBsize - 1) = '\0';
2156 2156: 
2157 2157: 
2158 2158:     /* 5: Finally update the cache bufferwindow */
2159 2159:     pstDBx->stCache.dwCbwin[0] = dwNew[0];
2160 2160:     pstDBx->stCache.dwCbwin[1] = dwNext - 1;
2161 2161: 
2162 2162: 

XC ... 'C' Concordance Utility   KEY.c                      Page 40

2163 2163:     /* Return : OK if buffer filled, else ERROR */
2164 2164:     STCK("eKeyBufFill");
2165 2165:     KRET_ERR(eScrCode != K_OK, eScrCode, 1202)
2166 2166:     KRET_OK
2167 2167: 
2168 2168: } /* END function eKeyBufFill() */
2169 2169: 
2170 2170: 
2171 2171: 
2172 2172: 
2173 2173: /****************************************************************************/
2174 2174: /******************************** UTILITY ***********************************/
2175 2175: /****************************************************************************/
2176 2176: 
2177 2177: #ifdef DEBUG   /* Matching #endif at end-of-file; -DEBUG-DEBUG-DEBUG-DEBUG- */
2178 2178: 
2179 2179: 
2180 2180: /*+3 MODULE KEY.C ----------------------------------------------------------*/
2181 2181: /*   NAME   13                    eKeyDBDump                                */
2182 2182: /*-- SYNOPSIS --------------------------------------------------------------*/
2183 2183: PRIVATE   eRetType
2184 2184: eKeyDBDump(pstDBx, pstBF)
2185 2185:     DBASE    *pstDBx;         /* Pointer to DBASE structure to dump */
2186 2186:     BUFFER   *pstBF;          /* Pointer to BUFFER structure to dump */
2187 2187: {
2188 2188: /* DESCRIPTION
2189 2189:  *    Dump all incore descriptors of a "database" (DBASE + associated BUFFER),
2190 2190:  *    Obs.: the dump routines are only active during DEBUG (compile switch).
2191 2191:  *
2192 2192:  *    Print header and ...
2193 2193:  *    1: Dump the key structure, handle <pstDBx->pIndex>
2194 2194:  *    2: Dump the cache-array, handle <pstDBx->stCache>
2195 2195:  *    3: Dump the buffer area, handle <pstBF->pzBaddr>
2196 2196:  *
2197 2197:  * RETURN
2198 2198:  *    Side effects ........: Control structs. of a "database" dumped on stdout.
2199 2199:  *    Function return value: OK if operation succeeded, ERROR otherwise; -
2200 2200:  *                           If ERROR, "Kstat" holds the precise error code.
2201 2201:  * SEE ALSO
2202 2202:  *    The functions eKeyCacheDump(), eKeyIndexDump(), eKeyBufDump(), in key.c
2203 2203:  *-3*/
2204 2204:     eRetType eRetCode = ERROR;         /* Return code for key.c functions */
2205 2205: 
2206 2206:     /* 0: Print header */
2207 2207:     fputs("\n########## DUMP OF DBASE ##########\n", stdout);
2208 2208: 
2209 2209:     /* 1: Dump key control information */
2210 2210:     eRetCode = eKeyIndexDump(pstDBx);
2211 2211:     KRET_ERR(eRetCode == ERROR, Kstat, 1300)
2212 2212: 
2213 2213:     /* 2: Dump cache array contents (but NOT the datarecords) */
2214 2214:     eRetCode = eKeyCacheDump(pstDBx, FALSE);
2215 2215:     KRET_ERR(eRetCode == ERROR, Kstat, 1301)
2216 2216: 
2217 2217:     /* 3: Dump buffer contents (ONLY the null terminated data-area) */
2218 2218:     eRetCode = eKeyBufDump(pstBF, FALSE);

XC ... 'C' Concordance Utility   KEY.c                      Page 41

2219 2219:     KRET_ERR(eRetCode == ERROR, Kstat, 1302)
2220 2220: 
2221 2221: 
2222 2222:     /* Function complete : return ok */
2223 2223:     STCK("eKeyBufFill");
2224 2224:     KRET_OK
2225 2225: 
2226 2226: } /* END function eKeyDBDump() */
2227 2227: 
2228 2228: 
2229 2229: 
2230 2230: /*+3 MODULE KEY.C ----------------------------------------------------------*/
2231 2231: /*   NAME   14                    eKeyIndexDump                             */
2232 2232: /*-- SYNOPSIS --------------------------------------------------------------*/
2233 2233: PRIVATE   eRetType
2234 2234: eKeyIndexDump(pstDBx)
2235 2235:     DBASE    *pstDBx;         /* Pointer to DBASE structure w. key */
2236 2236: {
2237 2237: /* DESCRIPTION
2238 2238:  *    Dump the info. contained in a DBASE key-descr. <pstDBx->pIndex>.
2239 2239:  *
2240 2240:  *    Print header and ...
2241 2241:  *    1: Dump state.....: availability [open|closed], access-mode [RdWr|RdOnly],
2242 2242:  *    2: Dump id & size : name of keyfile, size of key and key
2243 2243:  *
2244 2244:  * RETURN
2245 2245:  *    Side effects ........: Control structs. of a "DBASE" dumped on stdout.
2246 2246:  *    Function return value: OK (operation succeeded)
2247 2247:  *
2248 2248:  * BUG
2249 2249:  *    Function pt. only defined for key of type SS.
2250 2250:  *-3*/
2251 2251: 
2252 2252:     /* 0: Print header */
2253 2253:     fputs("\n========== DUMP OF INDEX ==========\n", stdout);
2254 2254: 
2255 2255: #ifdef SS
2256 2256:     /* 1: Dump key open-state and open-mode */
2257 2257:     fprintf(stdout, "INDEX:\topenstatus[%s]\n",
2258 2258: 	    pstDBx->pIndex->indexstatus == ICLOSED ? "ICLOSED" : "IOPEN");
2259 2259: 
2260 2260:     if (pstDBx->pIndex->indexstatus == IOPEN)
2261 2261: 	fprintf(stdout, "\topenmode[%s]\n",
2262 2262: 		pstDBx->pIndex->indexmode == RW ? "RW" : "RO");
2263 2263: 
2264 2264: 
2265 2265:     /* 2: Dump key name and size-info */
2266 2266:     fprintf(stdout, "\tfilename[%s]", pstDBx->pIndex->filename);
2267 2267:     fprintf(stdout, "\tsize: key[%d] key[%lu] used[%lu]\n",
2268 2268:             pstDBx->pIndex->indexsize.wKsize,      /* #chars in keystring */
2269 2269:             pstDBx->pIndex->indexsize.dwIsize,     /* #rec's total */
2270 2270:             pstDBx->pIndex->indexsize.dwIused );   /* #rec's used */
2271 2271: #endif /* SS */
2272 2272: 
2273 2273: 
2274 2274:     /* Function complete : return ok */

XC ... 'C' Concordance Utility   KEY.c                      Page 42

2275 2275:     STCK("eKeyIndexDump");
2276 2276:     KRET_OK
2277 2277: 
2278 2278: } /* END function eKeyIndexDump() */
2279 2279: 
2280 2280: 
2281 2281: 
2282 2282: /*+3 MODULE KEY.C ----------------------------------------------------------*/
2283 2283: /*   NAME   15                    eKeyCacheDump                             */
2284 2284: /*-- SYNOPSIS --------------------------------------------------------------*/
2285 2285: PRIVATE   eRetType
2286 2286: eKeyCacheDump(pstDBx, fAll)
2287 2287:     DBASE    *pstDBx;         /* Pointer to DBASE structure, with cache */
2288 2288:     int      fAll;            /* Dump contents of datarec's: [TRUE|FALSE] */
2289 2289: {
2290 2290: /* DESCRIPTION
2291 2291:  *    Dump the info. contained in a DBASE cache-descriptor <pstDBx->stCache>.
2292 2292:  *
2293 2293:  *    1: Initialize status variables for dump (cache length).
2294 2294:  *    2: Dump cache to stdout: print header & dump cache contents ...
2295 2295:  *       2.1: Catch & report empty buffer; otherwise 
2296 2296:  *       2.2: Cache contains data; - LOOP through cache pos. [1-dwCused] and:
2297 2297:  *            2.2.1: print the datafile record-offset stored in each slot,
2298 2298:  *            2.2.2: if fAll==TRUE, print content of datafile record as well.
2299 2299:  * RETURN  
2300 2300:  *    Side effects ........: Contents of <pstDBx->stCache> dumped on stdout.
2301 2301:  *    Function return value: OK if operation succeeded, ERROR otherwise; -
2302 2302:  *                           If ERROR, "Kstat" holds the precise error code.
2303 2303:  *-3*/
2304 2304:     DWORD          dwMax = 0L;         /* #keys currently in cache */
2305 2305:     DWORD          dwCount = 0L;       /* Loop count variable [1...dwMax] */
2306 2306:     eRetType       eRetCode = ERROR;   /* Return code for key.c functions */
2307 2307: 
2308 2308: 
2309 2309:     /* 1: Initialize status variable for dump (current cache length). */
2310 2310:     dwMax = pstDBx->stCache.dwCused;
2311 2311:     assert(dwMax >= 0L);
2312 2312: 
2313 2313: 
2314 2314:     /* 2: Dump cache to stdout: header & contents */
2315 2315:     fputs("\n========== DUMP OF CACHE ==========\n", stdout);
2316 2316:     if (dwMax == 0L)
2317 2317:        /* 2.1: Cache empty, - report to stdout */
2318 2318: 	fputs("CACHE:\tis currently empty !\n", stdout);
2319 2319: 
2320 2320:     else
2321 2321:        /* 2.2: Cache contains data; - LOOP through cache array ... */
2322 2322: 	for (dwCount = 1; dwCount <= dwMax; dwCount++) {
2323 2323: 
2324 2324: 	    /* 2.2.1: Dump contents of cache slot */
2325 2325: 	    fprintf(stdout, "CACHE:\tIndex[%4lu] : Offset[%lu]\n",
2326 2326: 		    dwCount, (*(pstDBx->stCache.padwData))[dwCount] );
2327 2327: 
2328 2328: 	    /* 2.2.2: If fAll==TRUE, dump contents of datarec's as well */
2329 2329: 	    if (fAll) {
2330 2330:               eRetCode = eKeyDatDump(pstDBx->fdData,

XC ... 'C' Concordance Utility   KEY.c                      Page 43

2331 2331:                          (*(pstDBx->stCache.padwData))[dwCount]);
2332 2332:               KRET_ERR(eRetCode == ERROR, Kstat, 1500)
2333 2333: 	    }
2334 2334: 	    /* else (!fAll): ignore contents of datarecord */
2335 2335: 
2336 2336: 	} /* END [2.2]: LOOP through cache */
2337 2337: 
2338 2338: 
2339 2339:     /* Function complete : return ok */
2340 2340:     STCK("eKeyCacheDump");
2341 2341:     KRET_OK
2342 2342: 
2343 2343: } /* END function eKeyCacheDump() */
2344 2344: 
2345 2345: 
2346 2346: 
2347 2347: /*+3 MODULE KEY.C ----------------------------------------------------------*/
2348 2348: /*   NAME   16                    eKeyRecDump                               */
2349 2349: /*-- SYNOPSIS --------------------------------------------------------------*/
2350 2350: PRIVATE   eRetType
2351 2351: eKeyRecDump(key, dwFileOffset)
2352 2352:     char     *key;             /* Key string */
2353 2353:     DWORD    dwFileOffset;     /* Datafile offset */
2354 2354: {
2355 2355: /* DESCRIPTION
2356 2356:  *    Dump one key keyvalue and its associated datafile offset, 
2357 2357:  *    both passed as parameters.
2358 2358:  *-3*/
2359 2359: 
2360 2360:     printf("Key[%s]-(lookup)->FlatfileOffset[%lu]\n", key, dwFileOffset);
2361 2361: 
2362 2362:     /* Function complete : return ok */
2363 2363:     STCK("eKeyRecDump");
2364 2364:     KRET_OK
2365 2365: }
2366 2366: 
2367 2367: 
2368 2368: 
2369 2369: /*+3 MODULE KEY.C ----------------------------------------------------------*/
2370 2370: /*   NAME   17                    eKeyDatDump                               */
2371 2371: /*-- SYNOPSIS --------------------------------------------------------------*/
2372 2372: #define      LINELEN 1024          /* Max linelength in datafile */
2373 2373: PRIVATE char aDatBuf[LINELEN + 1]; /* Linebuffer for dump of datarec. */
2374 2374: 
2375 2375: PRIVATE   eRetType
2376 2376: eKeyDatDump(fdDataFile, dwFileOffset)
2377 2377:     FILE *fdDataFile;              /* Datafile handle */
2378 2378:     DWORD dwFileOffset;            /* Datafile offset */
2379 2379: {
2380 2380: /* DESCRIPTION
2381 2381:  *    Dump the datafile record identified by file-handle and -offset,
2382 2382:  *    both passed as parameters.
2383 2383:  *    1: Set filepointer on datarecord, using <dwFileOffset>
2384 2384:  *    2: Read datarecord line-by-line, and print on stdout.
2385 2385:  *-3*/
2386 2386:     int       iSkip;               /* Skip KEYMARK (1. byte) in datarecord */

XC ... 'C' Concordance Utility   KEY.c                      Page 44

2387 2387:     eRetType  eRetCode = ERROR;    /* Return code for key.c functions */
2388 2388: 
2389 2389: 
2390 2390:     /* 1: Set filepointer on datarecord, using <dwFileOffset> */
2391 2391:     eRetCode = fseek(fdDataFile, dwFileOffset, SEEK_SET);
2392 2392:     KRET_ERR(eRetCode != 0, K_DATSEEK, 1700)
2393 2393: 
2394 2394: 
2395 2395:     /* 2: Read datarecord line-by-line, and print on stdout */
2396 2396:     for ( iSkip = 1;                /* iSkip: ignore 1.pos, 1.line! */
2397 2397:           (fgets(aDatBuf, LINELEN, fdDataFile) != (char *) NULL) &&
2398 2398:           (*(aDatBuf+iSkip) != KEYMARK);
2399 2399:           iSkip = 0)                /* iSkip: test 1.pos, next lines */
2400 2400:        fputs(aDatBuf, stdout);
2401 2401: 
2402 2402: 
2403 2403:     /* Function complete : return ok */
2404 2404:     STCK("eKeyDatDump");
2405 2405:     KRET_OK
2406 2406: 
2407 2407: } /* END function eKeyDatDump() */
2408 2408: 
2409 2409: #endif /* -DEBUG-DEBUG-DEBUG-DEBUG-DEBUG-DEBUG-DEBUG-DEBUG-DEBUG-DEBUG- */
2410 2410: 
2411 2411: 
2412 2412: 
2413 2413: /*+1 MODULE KEY.C ==========================================================*/
2414 2414: /*   NAME   18                    eKeyBufDump                               */
2415 2415: /*== SYNOPSIS ==============================================================*/
2416 2416: #define    VDULIN  75              /* Length of one line dump'ed to VDU */
2417 2417: #define    RAW     FALSE           /* Dump mode : raw or formatted */
2418 2418: 
2419 2419: PUBLIC    eRetType
2420 2420: eKeyBufDump(pstBF, fAll)
2421 2421:     BUFFER   *pstBF;               /* Pointer to BUFFER structure to dump */
2422 2422:     FLAG     fAll;                 /* Dump whole buffer, - not just datacontent */
2423 2423: {
2424 2424: /* DESCRIPTION
2425 2425:  *    Dump the contents of the bufferarea <pstBF->pzBaddr> to stdout.
2426 2426:  *    (Obs. PUBLIC function made accessible to user programs).
2427 2427:  *
2428 2428:  *    1: Initialize status variables for dump (buffer pointer & length).
2429 2429:  *    2: Dump buffer to stdout: print header & dump buffer contents [...]
2430 2430:  *       according to parameter fAll and compile-time switch RAW :
2431 2431:  *       2.1: Catch & report empty buffer; otherwise 
2432 2432:  *       2.2: fAll [FALSE]: dump only the (zero terminated!) string of data.
2433 2433:  *                 [TRUE ]: dump the whole bufferarea (cf. pstBF->wBsize),
2434 2434:  *                          RAW [TRUE ]: dump buffer as one long string
2435 2435:  *                              [FALSE]: insert linebreaks for each VDULIN chr.
2436 2436:  * RETURN
2437 2437:  *    Side effects ........: Buffer contents (if any) dumped on stdout.
2438 2438:  *    Function return value: OK (operation succeeded).
2439 2439:  *-1*/
2440 2440:     WORD      wLeft = 0;       /* #chars left in buffer for dumping to VDU */
2441 2441:     char      *pB1 = NULL;     /* Scratch buffer pointer */
2442 2442:     char      *pB2 = NULL;     /* Scratch buffer pointer */

XC ... 'C' Concordance Utility   KEY.c                      Page 45

2443 2443: 
2444 2444: 
2445 2445:     /* 1: Initialize dump status variables */
2446 2446:     pB1 = pstBF->pzBaddr;      /* Initialize start pointer for dumping */ 
2447 2447:     wLeft = pstBF->wBsize;     /* Initialize startsize for dumping */
2448 2448:     assert(wLeft >= 0);
2449 2449: 
2450 2450: 
2451 2451:     /* 2: Dump buffer to stdout: header & contents */
2452 2452:     D(fputs("\n========== DUMP OF BUFFER =========\n", stdout));
2453 2453:     D(fputc('[', stdout));
2454 2454: 
2455 2455:     if (wLeft == 0)
2456 2456:        /* 2.1: Buffer empty, - report to stdout */
2457 2457:        fputs("BUFFER:\tis currently empty !\n", stdout);
2458 2458: 
2459 2459:     else
2460 2460: 
2461 2461:        /* 2.2: Buffer contains data ... */
2462 2462:        /* Dump only datarecords (zero terminated!),- cf. flag param. */
2463 2463:        if (!fAll)
2464 2464:            fputs(pstBF->pzBaddr, stdout);
2465 2465:        else
2466 2466:        /* Dump whole buffer, - cf. comp.time switch: RAW [TRUE|FALSE] */
2467 2467:            if (RAW)             /*CONSTVAL*/
2468 2468:                /* Fast dump of whole buffer area, rely on terminal autowrap */
2469 2469:                fwrite(pstBF->pzBaddr, sizeof(char), wLeft, stdout);
2470 2470:            else {
2471 2471:                /* Dump whole buffer area, insert own linebreaks (more general) */
2472 2472:                for (pB2=pB1+wLeft; pB1+VDULIN < pB2; pB1 += VDULIN) {
2473 2473:                    fwrite(pB1, sizeof(char), VDULIN, stdout);
2474 2474:                    fputc('\n', stdout);
2475 2475:                }
2476 2476:                fwrite(pB1, sizeof(char), pB2-pB1, stdout);
2477 2477:            }
2478 2478: 
2479 2479:     D(fputs("]\n", stdout));
2480 2480: 
2481 2481: 
2482 2482:     /* Function complete : return ok */
2483 2483:     STCK("eKeyBufDump");
2484 2484:     KRET_OK
2485 2485: 
2486 2486: } /* END function eKeyBufDump() */
2487 2487: 
2488 2488: 
2489 2489: 
2490 2490: /* END module key.c                                                         */
2491 2491: /*==========================================================================*/
XC ... 'C' Concordance Utility                              Page 46

_IOFBF              :  890 
_KEY_ALLOC          :  264 
A_NOTFOUND          : 1255 
A_OK                : 1255 1258 
Astat               : 1255 1255 1258 
aDatBuf             : 2373 2397 2398 2400 
aIdxFile            :  829  859  860  861  861  867  871 
acAlnum             : 1564 1567 1568 1568 
argc                :  367  368 
argv                :  367  369 
assert              : 1163 1446 1706 2074 2075 2076 2311 2448 
BLKSIZ              : 2098 2098 
BUFFER              :  275  278  290  304  307  313  350  481  549  588  785  939 1013 1304 1917 
                      2002 2186 2421 
BUFLEN              :  352  471 
BYTE                : 1349 1364 1945 1945 1978 1980 
bPeek               : 1945 1978 1980 
CACHE               :  293  296 1414 1504 
CHRPOS              : 1567 1726 1732 1738 1797 1798 1822 1823 
c                   : 1567 1567 
calloc              :  905 
cb                  : 1690 1793 1797 
ce                  : 1690 1794 1798 
clearerr            : 2105 
const               :  355 1564 
cw                  : 1690 1792 1793 1793 1793 1793 1794 1794 1794 1794 
D                   :  472  482  489  498  564  568  572  915 1251 1270 1271 1285 1365 1375 1395 
                      1461 1487 1744 1845 1871 1896 1974 1985 1986 2051 2068 2069 2078 2099 2151 
                      2452 2453 2479 
DBASE               :  275  278  287  290  301  304  313  316  319  346  347  548  587  782  938 
                      1012 1191 1303 1582 2001 2185 2235 2287 
DEBUG               :  311  833  874 2177 
DWORD               :  304  307  322  325  613  614  615  616  617  752  834  835 1086 1167 1230 
                      1231 1338 1339 1340 1341 1369 1385 1385 1389 1389 1394 1436 1437 1438 1448 
                      1448 1458 1459 1464 1464 1476 1918 2003 2051 2052 2053 2304 2305 2353 2378 
                      
define              :  258  259 
dwCbwin             :  623  624  626  626  849  850 1118 1122 1126 2068 2069 2159 2160 
dwCbwinNew          :  304 2000 2003 2072 2073 
dwCfree             : 1341 1378 1385 1386 1389 1390 1394 1394 
dwCindx             : 1338 1353 1354 1354 1357 1369 1378 1379 1379 1382 1386 
dwCoffs             : 1340 1357 1360 1382 1385 1389 1390 
dwCount             : 2305 2322 2322 2322 2326 2326 2331 
dwCsize             :  845 1261 1458 1462 1486 1488 1530 
dwCused             :  625  752  848 1086 1282 1339 1353 1353 1354 1379 1394 1394 1531 2076 2310 
                      
dwDRec              :  307 
dwDatFile           : 1231 1254 1267 1270 1271 
dwFileOffset        :  322  325 2351 2353 2360 2376 2378 2391 
dwIdxSiz            :  834  876  877 
dwIdxUse            :  835  876  877 
dwIsize             : 2269 
dwIused             : 2270 
dwKeyCount          : 1230 1251 1261 1267 1282 
dwMax               :  615  625 1086 1130 1143 1143 1150 1150 1163 1164 2304 2310 2311 2316 2322 
                      

XC ... 'C' Concordance Utility                              Page 47

dwNew               : 2052 2072 2073 2074 2075 2075 2076 2079 2079 2082 2083 2159 
dwNewSize           : 1438 1445 1446 1448 1458 1459 1462 1464 1486 1488 
dwNext              : 2053 2082 2083 2084 2087 2137 2160 
dwOld               : 2051 2068 2069 2079 2079 
dwSetPos            :  616  676  677  683  684 
dwSetSiz            :  617  669  670  683  684 
dwSiz               :  614  626  639  643  647  651  655  659  663  668  677  682  712  713  715 
                       718  719 
dwWin               :  613  623  624  647  655  675  682 
EOF                 : 1978 
ERROR               :  831  872  966  974  979  983  984 1089 1099 1107 1168 1232 1239 1243 1263 
                      1343 1361 2062 2088 2089 2204 2211 2215 2219 2306 2332 2387 
EXIT_FAILURE        :  537 
EXPDEC              : 1577 1826 
eKeyBufDump         :  564  572  753 2218 2420 
eKeyBufFill         :  304 1167 2000 
eKeyBufRead         :  307 1360 1915 
eKeyBufScan         :  301 1248 1581 
eKeyCacheAlloc      :  293 1242 1262 1413 
eKeyCacheDump       :  319  568 1285 1375 1395 2214 2286 
eKeyCacheFill       :  287 1106 1190 
eKeyCacheFree       :  296  973 1238 1475 1503 
eKeyCacheSearch     :  290 1098 1302 
eKeyDBAccess        :  275  475  485  494  547 
eKeyDBClose         :  488  497  532  533  937 
eKeyDBDump          :  313  489  498 2184 
eKeyDBOpen          :  471  481  780 
eKeyDBRead          :  567  571  639  643  647  651  655  659  663  670  677  684  691  699 1011 
                      
eKeyDatDump         :  325 1271 2330 2376 
eKeyIndexDump       :  316  472  482 2210 2234 
eKeyListScroll      :  278  575  586 
eKeyRecDump         :  322 1270 2351 
eKeyStatus          : 2063 
eRetCode            :  831  871  872  966  973  974  978  979  983  984 1089 1098 1099 1106 1107 
                      1167 1168 1232 1238 1239 1242 1243 1262 1263 1343 1360 1361 2062 2087 2089 
                      2204 2210 2211 2214 2215 2218 2219 2306 2330 2332 2387 2391 2392 
eRetType            :  274  277  286  289  292  295  300  303  306  312  315  318  321  324  546 
                       585  779  831  936  966 1010 1089 1189 1232 1301 1343 1412 1502 1580 1914 
                      1999 2062 2183 2204 2233 2285 2306 2350 2375 2387 2419 
eScrCode            : 2063 2139 2165 2165 
envp                :  367  370 
exit                :  537 
FALSE               :  753 1285 1342 1375 1395 1687 1688 1717 1752 2060 2082 2084 2214 2218 2417 
                      
FILE                :  307  325 1916 2059 2377 
FLAG                : 1342 1364 1687 1688 2060 2422 
fAll                :  319 2286 2288 2329 2420 2422 2463 
fDigits             : 1688 1736 1737 1737 1738 1740 
fDone               : 2060 2082 2084 2111 2117 2125 2136 
fKeyExpand          : 1687 1717 1720 1752 1753 1872 
fMatch              : 1342 1364 1365 1368 
fclose              :  983 
fdData              :  457  457  887  888  890  969  983 1271 1360 1915 1916 1950 1953 1956 1967 
                      1968 1978 1978 1980 2059 2330 
fdDataFile          :  325 2059 2087 2105 2106 2109 2110 2376 2377 2391 2397 

XC ... 'C' Concordance Utility                              Page 48

feof                : 1956 1980 2110 
ferror              : 2109 
fgets               : 1967 2397 
filename            : 2266 
fopen               :  887 
fpData              :  307 
fprintf             :  530  704  711  712  713  714  715  716  717  718  719  720  721  722  723 
                       724  725  726  727  728  729  730  731  877  879 1251 1365 1896 2078 2099 
                      2257 2261 2266 2267 2325 
fputc               : 2453 2474 
fputs               :  462  529  531  536  630  710 1985 1986 2207 2253 2315 2318 2400 2452 2457 
                      2464 2479 
fread               : 2106 
free                :  990 1524 
fseek               : 1950 2087 2391 
ftell               : 1953 
fwrite              : 2469 2473 2476 
getc                : 1978 
getchar             :  634  746 
ICLOSED             : 2258 
INITSIZE            : 1408 1445 
IOPEN               : 2260 
i                   : 1568 1568 1568 1684 1723 1723 1723 1726 1726 1727 1731 1731 1732 1732 1733 
                      1736 1736 1752 1770 1770 1770 1771 1771 1789 1789 1789 1792 1797 1797 1798 
                      1801 1802 1802 1821 1821 1821 1822 1822 1822 1823 1823 1829 1829 1829 1831 
                      1831 1831 1834 1834 1835 1835 1836 1836 1840 1840 1840 1840 1840 1840 1844 
                      1844 1844 1846 1846 
iAnswer             :  612  634  635  635  636  705  705  705  706  750  750  750  751  751  755 
                      
iBufLen             :  781  787  900  905  914  915  916  919 
iCB                 : 1574 1740 1771 1840 1844 1844 
iCW                 : 1575 1726 1732 1733 1738 1740 1740 1771 1840 1844 1846 
iRetCode            :  832  890  891 1943 1950 1951 
iSigNum             :  514  515  530 
iSkip               : 2061 2093 2115 2123 2386 2396 2398 2399 
indexmode           : 2262 
indexsize           : 1700 2268 2269 2270 
indexstatus         : 2258 2260 
j                   : 1684 1736 1736 1736 1737 1738 1738 1738 1739 1739 1740 1740 1740 1840 1840 
                      1843 1843 1844 1844 1846 1846 1846 
KCHK_ERR            :  471  481  488  497  567  571  575  639  643  647  651  655  659  663  670 
                       677  684  691  699  876  878 
KEYDGT              : 1568 1736 1737 1831 1835 1840 1843 
KEYEOL              : 1555 1767 1786 1817 1886 
KEYEXP              : 1558 1781 
KEYLEN              : 1704 
KEYMARK             : 1980 2115 2398 
KEYMAX              : 1571 1572 1573 1574 1575 
KEYSEP              : 1554 1786 1817 1869 1876 
KRET_ERR            :  872  888  891  900  906  969  974  979  984 1099 1107 1164 1168 1239 1243 
                      1255 1263 1278 1361 1449 1459 1476 1767 1775 1817 1818 1897 1951 1956 1968 
                      1975 1978 2089 2109 2165 2211 2215 2219 2332 2392 
KRET_OK             :  576  760  927 1001 1100 1108 1173 1290 1399 1493 1536 1754 1905 1990 2166 
                      2224 2276 2341 2364 2405 2484 
K_A                 : 1559 1793 1794 
K_ALL               :  571 

XC ... 'C' Concordance Utility                              Page 49

K_BADALLOC          :  906 1449 1476 
K_BADARGS           :  900  969 1459 
K_BADLIST           :  692  700 1775 1817 1818 1897 
K_BUFOVFL           : 1975 2139 
K_CACEMPTY          : 1164 
K_CONT              :  571  575  639  643  647  651  655  659  663  670  677  684  691  699  876 
                       878 
K_CURR              :  651  670 1121 
K_D                 : 1560 1793 1794 
K_DATCLOSE          :  984 
K_DATEOF            : 1956 
K_DATOPEN           :  888  891 
K_DATREAD           : 1361 1968 1978 2109 
K_DATSEEK           : 1951 2089 2392 
K_EOL               : 1278 1767 
K_EXPR              :  699 1096 
K_FIRST             :  639 1113 
K_IDXCLOSE          :  979 
K_IDXOPEN           :  872 
K_IDXREAD           : 1255 
K_L                 : 1561 1793 1794 
K_LAST              :  663 1129 
K_LIST              :  567  691 1104 
K_NEXT              :  659 1125 
K_OK                : 2063 2165 
K_PREV              :  643 1117 
K_STOP              :  471  481  488  497  567 
Kstat               :  692  700  974 1099 1107 1168 1239 1243 1263 1278 1278 2211 2215 2219 2332 
                      
key                 :  322 2351 2352 2360 
L                   :  571 1142 1142 1146 1147 1149 1149 1353 1378 1486 2074 
LINELEN             : 2372 2373 2397 
L_Again             : 1455 1470 
lNew                : 1087 1114 1118 1122 1126 1130 1135 1142 1142 1143 1143 1148 1148 1149 1149 
                      1150 1150 1153 1153 1154 1155 1155 1156 1167 
lSetPos             : 1011 1014 1093 1135 
lSetSiz             : 1011 1015 1118 1146 1146 1147 1148 
lTmp                : 1088 1154 1156 
MAIN                :  273  331 
MAXPAT              : 1299 1337 1347 1348 
main                :  259 
malloc              : 1448 
memchr              : 2115 
memset              :  914  915 2150 2151 
NEXT                : 1949 
NULL                :  457  458  471  471  481  481  488  533  830  844  857  860  888  890  898 
                       903  906  969  988  991  994 1229 1237 1437 1442 1449 1468 1474 1476 1523 
                      1525 1682 1683 1689 1716 1801 1940 1944 1968 2056 2115 2397 2441 2442 
OK                  :  503  983 1248 2088 
P                   :  275  278  281  287  290  293  296  301  304  307  313  316  319  322  325 
                      
PANIC               : 1409 1468 1469 
PRIVATE             :  274  277  280  286  289  292  295  300  303  306  312  315  318  321  324 
                       342  343  346  347  350  355  513  546  585 1189 1301 1580 1914 1999 2183 
                      2233 2285 2350 2373 2375 
PUBLIC              :  779  936 1010 1412 1502 2419 

XC ... 'C' Concordance Utility                              Page 50

p                   : 1436 1442 1448 1449 1464 1480 1485 
pB                  : 1568 1571 1738 1797 1822 1831 1834 1836 1844 1846 
pB1                 : 2441 2446 2472 2472 2472 2473 2476 2476 
pB2                 : 2442 2472 2472 2476 
pBF0                : 2054 2092 2138 
pBF1                : 2055 2092 2097 2106 2115 2116 2122 2138 2145 2148 2150 2151 
pBF2                : 2056 2115 2116 
pE                  : 1568 1573 1726 1798 1823 1831 1834 1836 1844 1846 
pEnd                : 1689 1726 1727 
pIdx                :  830  860  861  863 
pIndex              :  458  458  871  876  878  978 1254 1700 2258 2260 2262 2266 2268 2269 2270 
                      
pW                  : 1572 1727 1731 1732 1738 1739 1797 1801 1802 1822 
padwData            :  844 1237 1267 1357 1369 1382 1390 1436 1485 1523 1524 1525 2087 2326 2331 
                      
pc                  : 1683 1807 1816 1817 1817 1818 1868 
pcBinp              : 1940 1960 1967 1971 1972 
pcKeySep            : 1682 1774 1775 1779 1786 1786 1807 1816 1823 1864 1878 1882 1891 
pcRetCode           : 1944 1967 1968 
pdwOff              : 1915 1918 1949 1950 1953 
peIdxClose          :  978 
peIdxGetLoad        :  878 
peIdxGetSize        :  876 
peIdxOpen           :  871 
peIdxRead           : 1254 
piRunSearch         : 1364 
ppzKeyList          :  301 1581 1583 1680 1767 1774 1775 1792 1802 1818 1822 1865 1868 1869 1869 
                      1879 1882 1888 1891 1896 
ppzKeyStr           :  301 1581 1584 1716 1731 1739 1744 1865 1871 1879 1888 
printf              :  667  668  674  675  681  682  689  697 1461 1487 1744 1845 1871 1974 2360 
                      
pstBF               :  275  278  290  304  307  313  547  549  563  564  567  571  572  575  586 
                       588  639  643  647  651  655  659  663  670  677  684  690  691  698  699 
                       753  781  785  898  905  906  910  914  915  916  919  937  939  988  990 
                       991  993  994 1011 1013 1098 1106 1167 1302 1304 1347 1360 1364 1364 1915 
                      1917 1960 1961 1986 2000 2002 2054 2055 2097 2097 2148 2148 2155 2155 2184 
                      2186 2218 2420 2421 2446 2447 2464 2469 
pstCache            :  293  296 1413 1414 1436 1458 1462 1475 1485 1486 1488 1503 1504 1523 1524 
                      1525 1530 1531 
pstDBx              :  275  278  287  290  301  304  313  316  319  547  548  567  568  571  575 
                       586  587  623  624  625  626  626  639  643  647  651  655  659  663  670 
                       677  684  691  699  752  780  782  844  845  848  849  850  871  876  878 
                       887  888  890  937  938  969  973  978  983 1011 1012 1086 1098 1106 1118 
                      1122 1126 1167 1190 1191 1237 1238 1242 1248 1254 1261 1262 1267 1271 1282 
                      1285 1302 1303 1353 1357 1360 1369 1375 1382 1390 1394 1395 1581 1582 1700 
                      2000 2001 2059 2068 2069 2076 2087 2159 2160 2184 2185 2210 2214 2234 2235 
                      2258 2260 2262 2266 2268 2269 2270 2286 2287 2310 2326 2330 2331 
pvBldSearch         : 1349 
pzBaddr             :  563  690  698  905  906  910  914  915  916  990  991 1106 1347 1364 1364 
                      1960 1986 2054 2055 2097 2148 2155 2446 2464 2469 
pzDat12             :  342  471  481 
pzDatBuf            :  781  786  903  910 
pzDatFile           :  780  783  859  887 
pzIdx2              :  343  481 
pzIdxFile           :  780  784  857  867 
pzKeyList           :  287 1190 1192 1248 

XC ... 'C' Concordance Utility                              Page 51

pzKeyStr            : 1229 1248 1251 1254 1270 
pzKlist             :  275  547  550  563 
pzPat               : 1337 1347 1348 1349 1349 
q                   : 1437 1464 1468 1474 1476 1480 
RAW                 : 2417 2467 
REAL_MAIN           :  259  367 
RW                  : 2262 
rResize             :  293 1413 1415 1458 1462 1468 1469 1488 
raise               :  738 
realloc             : 1464 
SEEK_SET            : 1950 2087 2391 
SIGINT              :  464 
SIGNON              :  355  462 
SIGTERM             :  465  738 
SS                  : 1698 2255 
STCK                :  258  502  759  926 1000 1172 1289 1398 1492 1535 1904 1989 2164 2223 2275 
                      2340 2363 2404 2483 
scanf               :  669  676  683  690  698 
setvbuf             :  890 
signal              :  464  465 
size_t              : 1448 1464 
stBF                :  350  471  475  485  489  494  497  498  532 
stCache             :  623  624  625  626  626  752  844  845  848  849  850  973 1086 1118 1122 
                      1126 1237 1238 1242 1261 1262 1267 1282 1353 1357 1369 1382 1390 1394 2068 
                      2069 2076 2087 2159 2160 2310 2326 2331 
stDB1               :  346  457  458  471  472  475  494  497  498  532 
stDB2               :  347  457  458  481  482  485  488  489  533 
stderr              :  529  530  531  536  704 1896 
stdout              :  462  630  710  711  712  713  714  715  716  717  718  719  720  721  722 
                       723  724  725  726  727  728  729  730  731  877  879 1251 1365 1985 1986 
                      2078 2099 2207 2253 2257 2261 2266 2267 2315 2318 2325 2400 2452 2453 2457 
                      2464 2469 2473 2474 2476 2479 
strchr              :  860 1567 
strcpy              :  563  863 
strlen              :  861 1349 1364 1680 1971 
strncpy             :  859  867 1347 
TRUE                :  564  568  572 1752 1872 2111 2117 
toupper             :  635 
ULONG_MAX           : 1369 1385 1389 
ungetc              : 1978 
VA                  : 1702 
VDULIN              : 2416 2472 2472 2473 
vSigCatch           :  281  464  465  514 
vSigNum             :  281 
void                :  280  464  465  513  563  738  859  863  867  914 1254 1347 1464 1475 2150 
                      2151 
WORD                :  836 1680 1681 1736 1770 1789 1821 1829 1835 1840 1843 1941 1942 2057 2058 
                      2082 2083 2102 2106 2440 
wBFBlock            : 2058 2098 2099 2102 2106 2106 2115 2116 2122 
wBFRest             : 2057 2082 2083 2097 2098 2098 2099 2125 2136 2148 2149 2150 2151 
wBLlen              : 1942 1971 1972 1973 
wBsiz               : 1941 1961 1967 1973 1974 1975 
wBsize              :  919  993 1961 2097 2148 2155 2447 
wIdxLoad            :  836  878  879 
wKeyLen             : 1681 1700 1704 1706 1723 1736 1770 1774 1789 1816 1821 1829 1835 1840 1843 
                      

XC ... 'C' Concordance Utility                              Page 52

wKsize              : 1700 2268 
wLeft               : 2440 2447 2448 2455 2469 2472 
wListLen            : 1680 1775 1818 
x                   :  258 
YES                 : 1897 


