XC ... 'C' Concordance Utility   ss.c                       Page 1

1       1: /*+1========================================================================*/
2       2: /* MODULE                         HASH.C                                    */
3       3: /*==========================================================================*/
4       4: /* FUNCTION    Toolbox for building diskbased hash-index'es.
5       5:  *             This module contains a collection of basic routines for :
6       6:  *             creating, accessing and maintaining index'es for fast access
7       7:  *             to simple datafiles.
8       8:  *             A datafile must be record-structured (arbitrary record size)
9       9:  *             with each record identified by a unique key-value (a fixed
10     10:  *             length string of arbitrary ASCII chars).
11     11:  *
12     12:  * SYSTEM      Standard Ansi C.
13     13:  *             Tested on UNIX V.3 (DG) and PC/MS DOS V.3.3.
14     14:  *
15     15:  * SEE ALSO    Modules:
16     16:  *             GENERAL.H, ACCESS.H, KEY.H for macros & errorhandling
17     17:  *             INDEX.C/H ................ for building index'es from datafiles.
18     18:  *             KEY.C/H .................. for accessing datarec's via index'es.
19     19:  *
20     20:  * PROGRAMMER  Allan Dystrup
21     21:  *
22     22:  * COPYRIGHT   (c) Allan Dystrup, October 1991.
23     23:  *
24     24:  * VERSION     $Header: d:/cwork/index/RCS/hash.c 0.1 92/07/06 14:28:10
25     25:  *             Allan_Dystrup PREREL Locker: Allan_Dystrup $
26     26:  *             ----------------------------------------------------------
27     27:  *             $Log:	hash.c $
28     28:  *             Revision 0.1  92/07/06  14:28:10  Allan_Dystrup
29     29:  *             PREREL (ALFA1)
30     30:  *
31     31:  * REFERENCES  Knuth, Donald E. [1980,1973] : "The art of computer programing"
32     32:  *                 Vol.2 : "Seminumerical Algortihms"
33     33:  *                 Vol.3 : "Sorting and searching"
34     34:  *                 Addison-Wesley Publishing Company.
35     35:  *             Floyd, E.T. [1987] : "Hashing for high-performance searching",
36     36:  *                 Dr. Dobb's Journal, Feb. 1987
37     37:  *             Lum, V.Y. et.al. [1971] : "Key-to-address transform techniques:
38     38:  *                 A fundamental performance study on large existing formatted
39     39:  *                 files", CACM April 1971, Vol.14, No.4.
40     40:  *             Lum, V.Y. [1973] : "General performance analysis of key-to-
41     41:  *                 address transformation methods using an abstract file
42     42:  *                 concept", CACM October 1973, Vol.16 No.10.
43     43:  *             Maurer, W.D. & Lewis, T.G. [1975] : "Hash table methods",
44     44:  *                 Comp. Surveys, March 1975, Vol.7, No.1.
45     45:  *             Park, Stephen K. & Miller, Keith W. (1988) :
46     46:  *                 "Random number gererators: good ones are hard to find"
47     47:  *                 Communications of the ACM
48     48:  *                 October 1988, Volume 31 Number 10 (pp. 1192-1201)
49     49:  *
50     50:  * USAGE       Module hash.c features the following public routines for
51     51:  *             building and working with indexfiles; - See headerfile hash.h
52     52:  *             and the function documentation for a detailed description of
53     53:  *             the user accesible datastructures and interface functions.
54     54:  *                 eHashIdxCreate()        // Create a new indexfile
55     55:  *                 eHashIdxOpen()          // Open an existing indexfile
56     56:  *                 eHashIdxClose()         // Close an open indexfile

XC ... 'C' Concordance Utility   ss.c                       Page 2

57     57:  *
58     58:  *                 eHashKeyInsert()        // Insert new (key,offset) in index
59     59:  *                 eHashKeyDelete()        // Delete (key,offset) from index
60     60:  *                 eHashKeyFind()          // Look up (key,offset) in index
61     61:  *
62     62:  *                 eHashIdxResize()        // Resize open indexfile
63     63:  *                 eHashIdxGetLoad()       // Get loadfactor for open indexfile
64     64:  *                 eHashIdxGetSize()       // Get size for open indexfile
65     65:  *                 eHashIdxProcess()       // Process all records in indexfile
66     66:  *
67     67:  * DOC         Documentation is incorporated into the module and may be
68     68:  *             selectively extracted (using a utility such as ex.awk) :
69     69:  *                Level 1: Module documentation (history, design, testdriver)
70     70:  *                Level 2: PUBLIC functions (module program interface, "API")
71     71:  *                Level 3: major PRIVATE functions (design)
72     72:  *                Level 4: minor PRIVATE functions (support)
73     73:  *
74     74:  * BUGS        The module is coded in STANDARD C (ANSI/ISO), which is a
75     75:  *             feature! -  It is however prepared to compile under "old"
76     76:  *             K&R C (if you prefer bugs ...)
77     77:  *
78     78:  *
79     79:  * =============================== SEARCHING =================================
80     80:  *
81     81:  *
82     82:  * A fundamental operation intrinsic to a great many computational tasks is
83     83:  * SEARCHING : retrieving some particular information from a large amount of
84     84:  * previously stored data. Normally we think of the information as divided
85     85:  * into smaller BLOCKs, each block having a KEY for use in searching.
86     86:  *
87     87:  * The task may be formulated directly as "find the index of the BLOCK
88     88:  * identified by the KEY K in an array of BLOCKs", or it may be camouflaged
89     89:  * in different ways, for instance as as a request to "retrieve the RECORD in
90     90:  * a file corresponding to the record-KEY K".
91     91:  *
92     92:  * No matter how camouflaged, the task eventually boils down to finding a
93     93:  * solution to the general searching problem, for which we have several well
94     94:  * known algortihms, cf. Knuth[1977].
95     95:  *
96     96:  *
97     97:  *                         Sequential search.
98     98:  * A simple "brute force" method where we simply scan a table of keys from
99     99:  * one end, until we "hit" K (or exhaust the table). Only suitable when the
100   100:  * number of keys is small (< approx. 20).
101   101:  * Worst case.... : n, where n = the table size
102   102:  * Average case.. : (n+1)/2
103   103:  * Example,n=1000 : W=1000, A=500
104   104:  *
105   105:  *                         Binary search.
106   106:  * This method requires an ORDERED table (sorted numerically or alphabetically).
107   107:  * We now recursively look at the middle of the table, each time discarding
108   108:  * the upper/lower half of the table depending on the value of K (less/greater
109   109:  * than the middle entry). The algorithm requires more bookkeeping, but
110   110:  * guaranties a low search time in both the worst and average case (in fact
111   111:  * binary search is provably the best possible algorithm for a COMPARISON
112   112:  * based search).

XC ... 'C' Concordance Utility   ss.c                       Page 3

113   113:  * Worst case.... : k, where k = smallest integer such that 2**k > n
114   114:  * Average case.. : k -[(2**k -k-1)/n] = k-1 for large values of n
115   115:  * Example,n=1000 : W=10, A=9
116   116:  *
117   117:  *                         Binary tree search.
118   118:  * The binary search algorithm implicitly defines a tree structure (on the
119   119:  * stack) during the recursive activation of the search procedure.
120   120:  * This tree structure can be defined explicitly by incorporating a directed
121   121:  * binary graph (where each node has 2 pointers) in the table of keys.
122   122:  * The setuptime of the binary tree is larger than for the simple key table,
123   123:  * but the search is faster since arithmetic calculation is eliminated.
124   124:  * Furthermore the tree may be arranged in an "optimal" way to reflect the
125   125:  * expected frequency of searches for each key (placing the most frequent
126   126:  * keys near the root of the tree).
127   127:  * The basic performance characteristics of Binary tree search are identical
128   128:  * to those stated for Binary search, - searching  an "optimal" Binary tree
129   129:  * however may perform significantly better (depending on the "skewness" of
130   130:  * the searching frequency distribution of the keys).
131   131:  *
132   132:  *
133   133:  *                         Balanced tree search.
134   134:  * The performance measures of the Binary search algorithms described above
135   135:  * rely on the assumption that the search tree (implicit or explicit) is
136   136:  * well balanced, ie. all branches on the same level in the tree have
137   137:  * approximately the same number of descendants.
138   138:  * This assumption can not always be fulfilled : in the case of a dynamic
139   139:  * data store with many insertions and/or deletions a balanced tree quickly
140   140:  * degrades to a skewed datastructure (a "heap") with a bad worst-case
141   141:  * performance.
142   142:  *
143   143:  * The solution to this problem is to "re-balance" the tree whenever skewness
144   144:  * emerges, and several algorithms have been devised for this purpose :
145   145:  * the general idea is to allow more than 2 pointers per node in the tree
146   146:  * to get extra flexibility for the pointer reassignments of the rebalancing
147   147:  * operation. Some well known algorithms are AVL-trees, 2-3-4 trees and
148   148:  * the most general method known as B-trees (M keys per node).
149   149:  * This search strategy leads directly to the concept of index sequential
150   150:  * access method ("ISAM" files) and more complex hierachial databases.
151   151:  *
152   152:  *
153   153:  *                         Hashing
154   154:  * Binary search methods suffer from two general defects that limit their
155   155:  * usability in most simple applications :
156   156:  *    (1) the keyword entries have to be ordered (numerically/alphabetically)
157   157:  *    (2) the ordering implies restructuring of the data in case of updating
158   158:           by addition/deletion
159   159:  *
160   160:  * The search methods known as "hashing" (or scatter storage technique)
161   161:  * solves these two defects, - and usually perform better as well !
162   162:  * Hashing methods are based on the computers ability to do arithmetic at high
163   163:  * speeds. The idea is to treat the letters of words as if they were numbers
164   164:  * and then to "hash" (ie. scramble) the numbers in some way to generate a
165   165:  * single number for each word. In this way each key "maps" to a table address
166   166:  * (index) where the key has been stored, - if it is an element of the table!
167   167:  *
168   168:  *

XC ... 'C' Concordance Utility   ss.c                       Page 4

169   169:  * =============================== HASHING ===================================
170   170:  *
171   171:  *
172   172:  * A hash function allows DIRECT REFERENCING of datablocks by using a simple
173   173:  * arithmetic transformation on the keys into table addresses. The hash table
174   174:  * may store the DATArecords directly, or use "indirect addressing" (ie. the
175   175:  * hashrecords store : the key + a POINTER to the datafile record).
176   176:  * The goal of hashing is to define a function, that will :
177   177:  *  - generate a FULL period (a mapping spanning the whole index range),
178   178:  *  - generate a UNIFORM mapping, ie. an even probability of mapping over the
179   179:  *    whole index range. The hash function should thus approximate a "random"
180   180:  *    function : it should perform as a fast (pseudo-) randomnumber generator
181   181:  *    mapping a large set of key-values into a smaller set of key-record
182   182:  *    index'es. Ideally the mapping should have the property that : h(K1) !=
183   183:  *    h(K2), so that different words K1 and K2 will hash directly to different
184   184:  *    addresses (so called "perfect hashing").
185   185:  *  - generate a UNIQUE mapping, ie. even keys hashing to the same initial
186   186:  *    index-value should trace different probing sequences during rehashing
187   187:  *  - perform FAST and be relatively easy to compute.
188   188:  *
189   189:  *                         Perfect hashing
190   190:  * If we know the key-values in advance, it is always possible to define a
191   191:  * SPECIALLY TAILORED "minimal perfect" (MP) hash function that will locate
192   192:  * any desired table element in a SINGLE probe without requiring extra space
193   193:  * in the table. A MP hash function uses a transformation based on a statis-
194   194:  * tical analysis of the actual set of key values :
195   195:  *  - (1) Digit analysis
196   196:  *    The distribution of values of the keys in each position or digit is
197   197:  *    determined. The positions with the most skewed distributions are then
198   198:  *    deleted from the key until the number of remaining digits is equal to
199   199:  *    the address length.
200   200:  *  - (2) Algebraic coding
201   201:  *    Each digit of a key is considered to be a polynomial coefficient. The
202   202:  *    polynomial so obtained is divided by another polynomial, which is
203   203:  *    invariant for all the keys. The coefficients of the remainder poly-
204   204:  *    nomial form the address. Based on the theory of error-correcting codes
205   205:  *    ("Hamming distances"), the dividing polynomial may be chosen to yield
206   206:  *    a UNIFORM mapping.
207   207:  *
208   208:  * MP hash functions are mostly of theoretical interest. In practice they are
209   209:  * used in situations, where we have a relatively short, static list of keys
210   210:  * (for instance reserved word lists of programming languages). Even in these
211   211:  * special cases, one often uses simpler methods such as :
212   212:  *  - setting up a table of carefully selected CODES derived from empirical
213   213:  *    tests of transforming the actual key-characters to unique index-values
214   214:  *    (as opposed to a complete statistical analysis)
215   215:  *  - using fast and simple arithmetic operations to obtain a "nearly minimal
216   216:  *    perfect" hash function with a single probe and a limited amount of extra
217   217:  *    /unused table space (as opposed to complex polynomial computations).
218   218:  *
219   219:  *
220   220:  *                         General hashing
221   221:  * Perfect hashing is seldom possible for longer lists of keywords : unless
222   222:  * the table size (m) is much larger than the number of keys (n), nearly all
223   223:  * GENERAL hash functions will lead to at least a few "collisions" between
224   224:  * values of h(Ki) and h(Kj).

XC ... 'C' Concordance Utility   ss.c                       Page 5

225   225:  *
226   226:  *
227   227:  *                         Hash functions
228   228:  * General Hash functions must "SCRAMBLE" the key to obtain a more UNIFORM
229   229:  * mapping and "FOLD" the key-values onto the (smaller) set of index-values.
230   230:  * To obtain these goals, two basic functions have been used (with several
231   231:  * variations) : division and multiplication; - In practice one often uses a
232   232:  * combination of these methods :
233   233:  *
234   234:  *    (1) Division method
235   235:  *        H(key) = key MOD table-size
236   236:  *        where table-size must be prime.
237   237:  *         - Radix conversion
238   238:  *           Express the key in radix p, use : p MOD q**m as index.
239   239:  *           p and q must be relatively prime, and m a positive integer.
240   240:  *         - Folding and compression
241   241:  *           Divide ("fold") the key into smaller components - often separate
242   242:  *           characters - , and combine ("compress") these into a final index
243   243:  *           value, - for instance by ADD or XOR operations.
244   244:  *
245   245:  *    (2) Multiplication method
246   246:  *        H(key) = TRUNC( table-size * ((key * R) MOD 1) )
247   247:  *        where R : [0...1],  and ((key*R) MOD 1) = remainder of (key*R)
248   248:  *         - Mid-Square
249   249:  *           Multiply the key by itself (square), and extract the middle bits
250   250:  *           as index value.
251   251:  *         - Shifting
252   252:  *           A simple fold/compress-function does not take into account any
253   253:  *           permutation of key components (the order of characters). To
254   254:  *           counteract this kind of redundancy in the keyword set, we may use
255   255:  *           bit-shifting (=multiplication) of PARTS of the keyword before
256   256:  *           folding/compression.
257   257:  *
258   258:  *
259   259:  *                         Collision resolution.
260   260:  * Collisions are usually handled in one of two ways :
261   261:  *
262   262:  *    (1)  Indirect addressing ("chaining")
263   263:  *         Each entry of the table is treated as the first link in a chain of
264   264:  *         entries, all having keys that hash to the same value.
265   265:  *
266   266:  *    (2)  Open addressing ("rehashing")
267   267:  *         In case of collision we generate another hash code from the same
268   268:  *         key, and then reprobe the table (until key found/or empty entry) :
269   269:  *         REHASH(key, i) =  ( HASH(key) + F(i) ) MOD table-size.
270   270:  *         The reprobing term F(i) can be implemented in various ways to
271   271:  *         obtain (some of) these goals :
272   272:  *            (2.1) Linear probing
273   273:  *                  F(i) = a CONSTANT value added to the hash code each time.
274   274:  *                  To generate a FULL period either F(i) and table-size
275   275:  *                  should be "co-prime" (have no common factor), or the
276   276:  *                  table-size should be prime. Linear probing with F(i) = 1
277   277:  *                  degrades to a simple sequential search.
278   278:  *                  Linear probing is simple, but often produces "primary
279   279:  *                  clustering" (several sequences of collisions are stored
280   280:  *                  in the same range of hashindex locations).

XC ... 'C' Concordance Utility   ss.c                       Page 6

281   281:  *            (2.2) Quadratic probing
282   282:  *                  F(i) = the EXPRESSION : (a + b*i + c * i**2), where a,b,c
283   283:  *                  are constants. This quadratic sequence yields more separated
284   284:  *                  chains of probes for keys hashing to nearby locations; -
285   285:  *                  however keys hashing to exactly the same location will
286   286:  *                  still trace the same probing sequence (known as "secondary
287   287:  *                  clustering"). Quadratic probing requires a table of size
288   288:  *                  of 2**m, - it won't search all locations if the table-size
289   289:  *                  is prime!
290   290:  *            (2.3) Double hashing
291   291:  *                  F(i) = the FUNCTION : (key MOD P2) + 1
292   292:  *                  By letting F(i) depend on the "key", we can effectively
293   293:  *                  reduce secondary clustering. The idea is to chose TWO
294   294:  *                  hash functions :
295   295:  *                     HASH(key) = key MOD tablesize -> [0...tablesize]
296   296:  *                     F(i) = 1+(key MOD (tablesize-2)) -> [1...tablesize-1]
297   297:  *                     REHASH(key) = (HASH(key) + F(i)) MOD tablesize
298   298:  *                  For this scheme to work, we must choose two "TWIN-PRIMES"
299   299:  *                  tablesize and tablesize-2 (example : 1021 and 1019).
300   300:  *            (2.4) Random probing
301   301:  *                  F(i) = a PSEUDO-RANDOM number generator producing a full,
302   302:  *                  uniform and unique mapping.
303   303:  *                  This is the ultimate solution to the collision problem,
304   304:  *                  but parameters for a well suited pseudo-random number
305   305:  *                  generator are not as easy to calculate, as those for a
306   306:  *                  good double hashing function. Furthermore the performance
307   307:  *                  of double hashing closely approximates random probing, so
308   308:  *                  solution 2.3 is often preferred for 2.4
309   309:  *
310   310:  *
311   311:  * ============================== DESIGN =====================================
312   312:  *
313   313:  *                     Primary design decisions
314   314:  * The primary goal of module hash.c has been to provide a set of SIMPLE and
315   315:  * yet GENERAL functions for building and using indexfiles as a means of fast
316   316:  * access to "flat" datafiles (arbitrary length records identified by uniqueue
317   317:  * keys) :
318   318:  *    (1)  SCATTER STORAGE indexing ("hashing") is preferred to the binary
319   319:  *         search techniques, thereby gaining speed in the general case of
320   320:  *         random access and index updating, at the cost of somewhat slower
321   321:  *         performance when sequential access is required.
322   322:  *
323   323:  *    (2)  GENERAL HASHING - as oposed to "perfect hashing" - is nessecitated
324   324:  *         by the dynamic characteristic of the datafiles (and as a conse-
325   325:  *         quence : our inability to determine the key-values in advance).
326   326:  *
327   327:  *    (3)  SEVERAL HASHING TRANSFORMATIONS & COLLISSION RESOLUTION ALGORITHMS
328   328:  *         have been provided in order to enable the user to select a method
329   329:  *         suited to the particular key-characteristic and datafile-size.
330   330:  *         Furthermore the module has been designed in a way that makes it
331   331:  *         very easy to "plug in" new algorithms for hashing and/or collision
332   332:  *         resolution, should the need to do so arise.
333   333:  *
334   334:  *
335   335:  *                     Choice of hash algorithms
336   336:  * Guidelines for the selection of a proper hashing strategy is stated below:

XC ... 'C' Concordance Utility   ss.c                       Page 7

337   337:  *
338   338:  * (1) Hashing transformation.
339   339:  * GENERAL hash transformations must all be "distribution independent", ie.
340   340:  * the transformations can not take into account the actual distribution of
341   341:  * keys over the key space (since the datafiles are not known in advance!).
342   342:  * In many/most cases the key-distributions are NOT uniform, resulting in
343   343:  * more collisions in "dense" areas of the key-space, - regardless of which
344   344:  * hashing transformation we use!
345   345:  * Practical studies as well as theoretical analysis thus indicate that -
346   346:  * faced with an arbitrary key set - the choice of hashing transformation is
347   347:  * of less importance than a good collision resolution method.  Only one
348   348:  * general conclusion can be made [Lum 71/73]: A hash-transformation based
349   349:  * on division gives the best overall performance. All of the following
350   350:  * functions include a division : MOD by the (prime) size of the indextable:
351   351:  * +-------------------------+----------------------------------------------+
352   352:  * | METHOD:                 |            Characteristic                    |
353   353:  * +-------------------------+----------------------------------------------+
354   354:  * | FLL (First+Last+Length) | fast, NOT suited for fixed-length keys       |
355   355:  * | ADD (Sum of chars)      | fast, NOT good if many key-permutations      |
356   356:  * | PJW (P.J.Weinburger)    | slower (approx. 10 x ADD), more general      |
357   357:  * +-------------------------+----------------------------------------------+
358   358:  * The time needed to calculate the hash function is not important in the
359   359:  * context of this module, where the index'es are kept on secondary storage
360   360:  * (disk access time is a factor 10-100 x slower than a hash calculation).
361   361:  * We therefore choose P.J.WEINBURGER (PJW) as default hashing transformation.
362   362:  *
363   363:  * (2) Collision resolution :
364   364:  * Let n=number of keys, m=number of slots in index, L="Loadfactor"=n/m <= 1.
365   365:  * The number of probes required to look up a key in a hash index is then a
366   366:  * function of the Loadfactor, as stated in the following table :
367   367:  * +-------------+--------------------------------------+-------------------+
368   368:  * |      METRIC:|              # Probes                |  Examples: A W    |
369   369:  * | METHOD:     | Average (A)     | Worstcase (W)      | L=0.5   | L=0.75  |
370   370:  * +-------------+-----------------+--------------------+---------+---------+
371   371:  * | Chaining    | 1 + L/2         | e**(-L) + L        | 1.3 1.4 | 1.1 1.2 |
372   372:  * | Linear Prob.| [1 + 1/(1-L)]/2 | [1 + 1/(1-L)**2]/2 | 1.5 2.5 | 2.5 8.5 |
373   373:  * | Double Hash.| -[ln(1-L)] / L  | 1 / (1-L)          | 1.4 1.8 | 2.0 4.0 |
374   374:  * +-------------+-----------------+--------------------+---------+---------+
375   375:  * In general hashing provides VERY FAST CONSTANT search times for L < 0.75,
376   376:  * ie. when space is available for a large enough table; - Contrast this to
377   377:  * linear search with O=n and binary search with O=log2(n). Note however that
378   378:  * the performance degrades rapidly, as the index fills up (L approaches 1).
379   379:  * When this happens, the index should be resized to obtain a lower L factor.
380   380:  *
381   381:  * Chain-based lookup compares favorably to the other collision resolution
382   382:  * strategies, but implies maintenance of linked lists; - this method is well
383   383:  * suited for RAM-based index'es (dynamic storage allocation) with a high data
384   384:  * "turnover rate" and an unpredictable number of keys and updates. It is
385   385:  * however inconvenient for more static index'es placed on secondary storage.
386   386:  * (Chaining is NOT offered as a collision resolution method in this module).
387   387:  *
388   388:  * Linear probing is simple to compute, and the method may be preferable for
389   389:  * small index'es with a low loadfactor. For larger index'es the overhead
390   390:  * imposed by double hashing is justified by a reduced collision rate.
391   391:  * We make DOUBLE HASHING the default choice for collision resolution.
392   392:  *

XC ... 'C' Concordance Utility   ss.c                       Page 8

393   393:  *
394   394:  *                     Multiuser considerations
395   395:  * The file access methods for the hash functions in this module have been
396   396:  * designed with the following goals in mind :
397   397:  *  1  SINGLE USER exclusive access to multiple dynamic hash index'es
398   398:  *     with full (READ/WRITE) permissions.
399   399:  *     This option may be used by a system administrator in a multiuser
400   400:  *     environment to create and maintain hash index'es for subsequent
401   401:  *     sharing by multiple end-users (cf. pt. 2)
402   402:  *  2  MULTIUSER concurrent access to multiple static hash index'es
403   403:  *     with limited (READ-ONLY) permissions.
404   404:  *
405   405:  * TRUE MULTIUSER access with full permissions on hash index'es has NOT
406   406:  * been implemented;  This requires some changes to the design :
407   407:  *  -  the code in the basic hash index write-functions (cf. eWriteIdxHdr,
408   408:  *     eWriteIdxKey) must be "sandwich'ed" between statements for locking
409   409:  *     resp. unlocking the range of bytes to be updated in the file (ie.
410   410:  *     setting up "critical regions" for the basic record-write operations).
411   411:  *     Nb: lock/unlock-functions have not been standardized by ANSI/ISO,
412   412:  *     so a generic interface should be implemented to hide system dependency.
413   413:  *  -  the simple method of checking a "boolean" integrity value (indicating
414   414:  *     proper close of the index) must be substituted by a multivalued
415   415:  *     integrity variable : a count of open-operations on the index-file.
416   416:  *     Updating of the index (cf. eHashKeyInsert, eHashKeyDelete) may then
417   417:  *     be allowed - accompanied by appending of datarecords to the datafile.
418   418:  *     Nb: any restructuring of the datafile or of the hash index (cf.
419   419:  *     eHashIdxResize) should not take place while users are "on line".
420   420:  *
421   421:  *
422   422:  * ============================== MODULE STRUCTURE ===============================
423   423:  *
424   424:  *                     Data model
425   425:  * To define a hashtable on disk and in core we need some datastructures for
426   426:  * size- & statusinfo (one HEADER-record) and for index-values (multiple
427   427:  * KEY-records). These data must be maintained both on disk and in RAM.
428   428:  * The appropriate data-structures are defined in the include-file HASH.H.
429   429:  *                             
430   430:  * (1) Header-record layout
431   431:  *
432   432:  *     DISK (external)                     RAM (incore)
433   433:  *     struct stHdisk                      struct stHcore (*HASH)
434   434:  *     +--------------------+              +----------------------+
435   435:  *     | long     integrity | closed OK?   | enum     indexstatus | [ICLOSED,IOPEN]
436   436:  *     | int      checksum  | of SIZEINFO  | enum     indexmode   | [RW,RO]
437   437:  *     | SIZEINFO indexsize |              | FILE     *fd         | 
438   438:  *     +------------  |  ---+              | char     *filename   |
439   439:  *                    |                    | SIZEINFO indexsize   |
440   440:  *                    |                    +------------  |  -----+
441   441:  *                    |                                   |
442   442:  *                    +---> struct stHsize (SIZEINFO) <---+
443   443:  *                            +---------+
444   444:  *                            | wKsize  | size (#byte) of key
445   445:  *                            | dwIsize | size (#records) of index file
446   446:  *                            | dwIused | usage (#USED records) in index file
447   447:  *                            +---------+
448   448:  *

XC ... 'C' Concordance Utility   ss.c                       Page 9

449   449:  * (2) Key-record layout
450   450:  *
451   451:  *     DISK (external)                 RAM (incore)
452   452:  *     key record                      struct stHkey (KEY)
453   453:  *     +-------------------+           +-------------------+
454   454:  *     | int               |           | enum  status      | [VACANT,USED,DELETED]
455   455:  *     | char[wKsize]      |           | char  *key      --->char[wKsize]
456   456:  *     | DWORD             |           | DWORD dwDatOffset |
457   457:  *     +-------------------+           +-------------------+
458   458:  *
459   459:  *
460   460:  *
461   461:  *                     Function decomposition
462   462:  * The index functions to generate and access these data structures may be
463   463:  * grouped into 3 broad categories : Header operations, Key-record operations
464   464:  * and low level index-file I/O. The main calling hierachy is outlined in the
465   465:  * following diagram :
466   466:  * 
467   467:  * (1) Index header operations     (2) Index key operations
468   468:  *
469   469:  *  +->eHashIdxCreate ---------+       eHashKeyInsert --------------------+
470   470:  *  |   | eHashIdxOpen ------+ |        | eHashKeyDelete ---------+       |
471   471:  *  |   | eHashIdxClose----+ | |        | eHashKeyFind -------+   |       |
472   472:  *  |   |                  | | |        |                     |   |       |
473   473:  *  |  eHashIdxRestore     | | |        |                  eLocateKey     |
474   474:  *  +--eHashIdxResize ---+ | | |        |                     |   |       |
475   475:  *                       | | | |        |                     |   |       |
476   476:  *     eHashIdxGetSize   | | | |        +----> dwHashFunc <---+   |       |
477   477:  *     eHashIdxGetLoad   | | | |        +----> dwRehashFunc <-+   |       |
478   478:  *     eHashIdxProcess <-+ | | |                                  |       |   
479   479:  *                         | | |                                  |       |  
480   480:  *                         | | |                                  |       |  
481   481:  *                         | | |   (3)                            |       |  
482   482:  *                         | | |   Index low-level I/O            |       |
483   483:  *                         | | |                                  |       |
484   484:  *                         | +-|-> eReadIdxHdr                    |       |
485   485:  *                         +-->+-> eWriteIdxHdr                   |       |
486   486:  *                             |                                  |       |
487   487:  *                             |   eReadIdxKey <------------------+<------+
488   488:  *                             +-> eWriteIdxKey <-------------------------+
489   489:  *
490   490:  *
491   491:  *-1========================================================================*/
492   492: 
493   493: 
494   494: /*==========================================================================*/
495   495: /*                                Includes                                  */
496   496: /*==========================================================================*/
497   497: 
498   498: /* Stacdard C (ANSI/ISO) headerfiles */
499   499: #include <stdlib.h>
500   500: #include <stdio.h>
501   501: #include <malloc.h>
502   502: #include <signal.h>
503   503: #include <ctype.h>
504   504: #include <string.h>

XC ... 'C' Concordance Utility   ss.c                       Page 10

505   505: #include <math.h>
506   506:                                                                           
507   507: /* #define S/H-DEBUG: runtime check of stack- and heap on DOS  */
508   508: /* Relies on PC/MS DOS V.3.3 system files which are deprecated */
509   509: //#include "../check/stck/stck.h"
510   510:    # define STCK(x)
511   511:    # define REAL_MAIN	main
512   512: //#include "../check/hpck/hpck.h"
513   513: 
514   514: /* Project headerfile */
515   515: #define _HASH_ALLOC
516   516: #include "SS.H"
517   517: 
518   518: 
519   519: /*==========================================================================*/
520   520: /*                           Defines & Macros                               */
521   521: /*==========================================================================*/
522   522: 
523   523: /* FILE_OFFSET calculates the offset into the file according to  */
524   524: /* the element# (nelem) and the keysize (wKsize)                 */
525   525: #define FILE_OFFSET(nelem,wKsize)               \
526   526:         ( sizeof(struct stHdisk)                \
527   527:           + nelem * ( sizeof( struct stHkey )   \
528   528:           - sizeof( char * ) + wKsize )         \
529   529:         )
530   530: 
531   531: 
532   532: /*==========================================================================*/
533   533: /*                           Function prototypes                            */
534   534: /*==========================================================================*/
535   535: 
536   536: /*-------------------------- Main Testdriver -------------------------------*/
537   537: PRIVATE   void
538   538:           vSigCatch P((int iSigNum));
539   539: 
540   540: PRIVATE   void
541   541:           vKeyGet   P((WORD wKeySize, char *pzKeyBuf));
542   542: 
543   543: PRIVATE   WORD
544   544:           wKeyPrint P((char *pzKeyBuf, DWORD dwDatOff));
545   545: 
546   546: PRIVATE   eRetType
547   547:           eIdxStatPrint P((HASH *pH));
548   548: 
549   549: 
550   550: /*-------------------------- Hashing functions -----------------------------*/
551   551: PRIVATE   DWORD
552   552:           dwHashFunc P((char *pcKeystr, WORD wKsize, DWORD dwMaxSlot));
553   553: 
554   554: PRIVATE   DWORD
555   555:           dwRehashFunc P((char *pcKeystr, WORD wKsize, DWORD dwCurSlot, DWORD dwMaxSlot));
556   556: 
557   557: #ifdef DEBUG
558   558: PRIVATE   void
559   559:           vHashTrace P((char *pcKeystr, WORD wKsize, DWORD dwCurSlot));
560   560: #endif	/* DEBUG */

XC ... 'C' Concordance Utility   ss.c                       Page 11

561   561: 
562   562: 
563   563: /*-------------------------- Hashindex Header Record -----------------------*/
564   564: PRIVATE   eRetType
565   565:           eHashIdxRestore P((HASH * pH));
566   566: 
567   567: PRIVATE   void
568   568:           vUpdate_stHdisk P((HASH H, struct stHdisk * pstIdxHdr, eAnsType eIntegr));
569   569: 
570   570: 
571   571: /*-------------------------- Hashindex Keyrecords --------------------------*/
572   572: PRIVATE   eRetType
573   573:           eLocateKey P((HASH H, char *key, DWORD * pdwKeySlot, DWORD * dwDatOffset));
574   574: 
575   575: 
576   576: /*-------------------------- Hashindex Reorganization ----------------------*/
577   577: PRIVATE   WORD
578   578:           wCopy2New P((char *key, DWORD dwDatOffset));
579   579: 
580   580: 
581   581: /*-------------------------- Hashindex Low Level I/O  ----------------------*/
582   582: PRIVATE   eRetType
583   583:           eWriteIdxHdr P((HASH H, struct stHdisk * pstIdxHdr));
584   584: 
585   585: PRIVATE   eRetType
586   586:           eReadIdxHdr P((HASH H, struct stHdisk * pstIdxHdr));
587   587: 
588   588: PRIVATE   eRetType
589   589:           eWriteIdxKey P((HASH H, DWORD dwSlot, struct stHkey * f));
590   590: 
591   591: PRIVATE   eRetType
592   592:           eReadIdxKey P((HASH H, DWORD dwSlot, struct stHkey * f));
593   593: 
594   594: 
595   595: /*-------------------------- Utility Functions -----------------------------*/
596   596: PRIVATE   void
597   597:           vGetPrime P((DWORD *pdwPrime, int iUpward));
598   598: 
599   599: PRIVATE   FLAG
600   600:           fIsPrime P((DWORD n));
601   601: 
602   602: PRIVATE   double
603   603:           rRandom   P((VOID));
604   604: 
605   605: PRIVATE   WORD
606   606:           wCCITTcrc P((char *pzData, WORD wLength));
607   607: 
608   608: PRIVATE   char *
609   609:           pzStrcpyAlloc P((char **ppzDest, char *pzSrc));
610   610: 
611   611: 
612   612: 
613   613: 
614   614: #ifdef MAIN
615   615: /****************************************************************************/
616   616: /******************************** MAIN **************************************/

XC ... 'C' Concordance Utility   ss.c                       Page 12

617   617: /****************************************************************************/
618   618: 
619   619: /* Define "sigon message" for module hash.c */
620   620: PRIVATE char SIGNON[] =
621   621: 	"\nHashIndex Functions (Testdriver), Version 0.1.0\n"
622   622: 	"MOD[ss.c] VER[0.1.0 Pre] DAT[92/07/10] DEV[ad dec]\n"
623   623: 	"Copyright (c) Allan Dystrup 1992\n\n";
624   624: 
625   625: 
626   626: /* Define initial values for hashindex */
627   627: #define   Ksize   10           /* Keysize */
628   628: #define   HIsize  10L          /* Initial size of hash index (# key-records) */
629   629: HASH      HI   =  NULL;        /* Handle to "In core" index descr.struct. */
630   630: char      pzKBuf[Ksize + 1];   /* Buffer for entering key value */
631   631: 
632   632: 
633   633: /*+1 MODULE HASH.C =========================================================*/
634   634: /*   NAME   01               REAL_MAIN()                                    */
635   635: /*== SYNOPSIS ==============================================================*/
636   636: int
637   637: REAL_MAIN(argc, argv, envp)
638   638:     int       argc;            /* Argument count */
639   639:     char     *argv[];          /* Argument vector */
640   640:     char     *envp[];          /* Environment pointer */
641   641: {
642   642: /* DESCRIPTION
643   643:  *    Testdriver for module hash.c; - exercises the functions in the module
644   644:  *    and validates the functionality through trace-statements when compiled
645   645:  *    with flag "DEBUG".
646   646:  *
647   647:  *   1: Print signon message & setup to catch "break" signals.
648   648:  *
649   649:  *   2: MAKE and fill a new hash index ... :
650   650:  *      2.1: Create & open the new hash index (Read/Write mode), -
651   651:  *           actions 2.x are skipped, if the indexfile already exists.
652   652:  *      2.2: Print initial statistics for the index (size & loadfactor).
653   653:  *      2.3: Fill the hashindex file with: (key,offset) records,
654   654:  *           build by scanning the datafile.
655   655:  *      2.4: Print final statistics for the index (size & loadfactor).
656   656:  *      2.5: Print all (defined) keyrecord entries in the indexfile.
657   657:  *      2.6: Close the hash index gracefully, - NB: the indexfile MUST be
658   658:  *           closed properly to preserve the index integrity in RW mode!
659   659:  *
660   660:  *   3: TEST the hash index by looking up entries in the index file ... :
661   661:  *      3.1: Open the existing hash index (ReadOnly mode).
662   662:  *     [3.2: Optionally print all (defined) keyrecord entries,
663   663:  *           - this function may take some time.]
664   664:  *      3.3: LOOP : Enter keyvalue, lookup in hashindex file, print keyrecord
665   665:  *           UNTILL empty keyvalue entered
666   666:  *      3.4: Close the hash index gracefully
667   667:  *
668   668:  * RETURN
669   669:  *   REAL_MAIN() is a testdriver and not intented to interface with any
670   670:  *   calling program. The return value from REAL_MAIN() is thus insignificant
671   671:  *   in this context.
672   672:  *   You should however notice the checking of error-conditions on return

XC ... 'C' Concordance Utility   ss.c                       Page 13

673   673:  *   from each call to a PUBLIC function defined in hash.c; - This practice
674   674:  *   should also be followed in your application to "catch" and diagnose any
675   675:  *   malfunction in the system or in the services provided by this module.
676   676:  *   (You will probably want to write your own error-handling, though).
677   677:  *
678   678:  * EXAMPLE
679   679:  *   The contents of function REAL_MAIN() demonstrates the basic aspects of
680   680:  *   building and accessing a hashindex using the *LOW LEVEL* public data-
681   681:  *   structures and interface-functions in HASH.C/H.
682   682:  *   The modules INDEX.C/H and KEY.C/H provides more *HIGL LEVEL* interfaces
683   683:  *   for generating and using indexfiles from application programs.
684   684:  *
685   685:  * SEE ALSO
686   686:  *   hash.h for a detailed description of symbolic constants, macro's,
687   687:  *   data structures, return codes and error codes.
688   688:  *-1*/
689   689: 
690   690:     char      cIdxFile[] = "FILE.HSH"; 	/* Name of indexfile to create & test */
691   691:     WORD      wLoad      =  0;         	/* Indexfile load factor */
692   692:     DWORD     dwDatOff   = 0L;         	/* Datafile offset */
693   693:     DWORD     dwCount    = 0L;         	/* Scratch count variable */
694   694:     int       iMaxTry    = 100;		/* Max key lookups */ 
695   695: 
696   696: 
697   697:     /*----------------- 1: Signon and setup signal catcher -----------------*/
698   698: 
699   699:     /* Signon */
700   700:     fputs(SIGNON, stdout);
701   701: 
702   702: 
703   703:     /* Setup to redirect interrupt signals to our own handler */
704   704:     signal(SIGINT, vSigCatch);
705   705:     signal(SIGTERM, vSigCatch);
706   706: 
707   707: 
708   708:     /*----------------- 2: Make & fill a new hash index --------------------*/
709   709: 
710   710:     /* 2.1: Create & open the hash index (Read/Write mode) */
711   711:     if (eHashIdxCreate(&HI, cIdxFile, Ksize, HIsize) != ERROR) {
712   712: 
713   713: 	/* 2.2: Print initial statistics */
714   714: 	ACHK_ERR(eIdxStatPrint(&HI), A_CONT);
715   715: 
716   716: 	/* 2.3: Fill the hashindex file w. (key,offset) pairs from datafile */
717   717: 	for (dwCount = 1L; dwCount <= (HIsize * 10); dwCount++) {
718   718: 	    /* Enter new keyrecord in hashindex file */
719   719: 	    vKeyGet(Ksize, pzKBuf);
720   720: 	    ACHK_ERR(eHashKeyInsert(&HI, pzKBuf, dwCount), A_CONT);
721   721: 
722   722: 	    /* Expand hashindex file (&	print new statistics) if nessecary */
723   723: 	    ACHK_ERR(eHashIdxGetLoad(&HI, &wLoad), A_CONT);
724   724: 	    if (Astat == A_XPAND) {
725   725: 		   eHashIdxResize(&HI, 200);
726   726: 		   ACHK_ERR(eIdxStatPrint(&HI), A_CONT);
727   727: 	    }
728   728: 	}

XC ... 'C' Concordance Utility   ss.c                       Page 14

729   729: 
730   730: 	/* 2.4: Print final statistics */
731   731: 	ACHK_ERR(eIdxStatPrint(&HI), A_CONT);
732   732: 
733   733: 	/* 2.5: Print all valid (USED) keyrecord entries */
734   734: 	ACHK_ERR(eHashIdxProcess(&HI, wKeyPrint), A_CONT);
735   735: 
736   736: 	/* 2.6: Close hashindex gracefully, -NB: file integrity in RW mode! */
737   737: 	ACHK_ERR(eHashIdxClose(&HI), A_CONT);
738   738:     }
739   739:     else
740   740: 	ACHK_ERR(;, A_CONT);
741   741: 
742   742: 
743   743:     /*----------------- 3: Find entries in the hash index ------------------*/
744   744: 
745   745:     /* 3.1: Open the existing hash index (ReadOnly mode) */
746   746:     ACHK_ERR(eHashIdxOpen(&HI, "FILE.HSH", "rb"), A_CONT);
747   747: 
748   748:     /* 3.2: Uncomment to print all valid keyrecord entries, - optional */
749   749:     /* ACHK_ERR(eIdxStatPrint(&HI), A_CONT); */
750   750: 
751   751:     /* 3.3: LOOP enter keyvalue, lookup in hashindex file, print keyrecord */
752   752:     #ifdef RANDOM
753   753:     	iMaxTry = 10;	
754   754:     #endif
755   755:     do {
756   756: 		vKeyGet(Ksize, pzKBuf);
757   757: 		ACHK_ERR(eHashKeyFind(&HI, pzKBuf, &dwDatOff), A_CONT);
758   758: 		wKeyPrint(pzKBuf, dwDatOff);
759   759:     } while (*pzKBuf != '\0' && iMaxTry-- >0); /* until empty keyvalue string */
760   760: 
761   761:     /* 3.4: Close the hash index gracefully */
762   762:     ACHK_ERR(eHashIdxClose(&HI), A_CONT);
763   763: 
764   764: 
765   765:     /* Return status to caller , - not used for this driver program! */
766   766:     return (Astat = A_OK ? 0 : 1);
767   767: 
768   768: }   /* END function REAL_MAIN() */
769   769: 
770   770: 
771   771: 
772   772: /*+4 MODULE HASH.C ---------------------------------------------------------*/
773   773: /*   NAME   01.01                 vSigCatch                                 */
774   774: /*-- SYNOPSIS --------------------------------------------------------------*/
775   775: #define   MAXLINE   81
776   776: 
777   777: PRIVATE void
778   778: vSigCatch(iSigNum)
779   779:     int       iSigNum;
780   780: {
781   781: /* DESCRIPTION
782   782:  *    Support function for REAL_MAIN() test driver.
783   783:  *    Signal handler set up to catch the "break" signals : SIGINT (asynch.
784   784:  *    interactive attention) & SIGTERM (asynch. interactive termination).

XC ... 'C' Concordance Utility   ss.c                       Page 15

785   785:  *    1: Prompt user for break confirmation; We have two possible situations:
786   786:  *       a: break during index generation (INTEGRITY="UNKNOWN"), - will leave
787   787:  *          the index in a not fully generated state, possibly unusable.
788   788:  *          Issue warning if this situation !
789   789:  *       b: break during index test (INTEGRITY="OK"), - no problem!
790   790:  *    2: Depending on user confirmation : [Y]->terminate or [N]->continue
791   791:  *
792   792:  * RETURN
793   793:  *    If break confirmed: program terminated with exit code 'EXIT_FAILURE'
794   794:  *    else: signal 'iSigNum' reset and program execution resumed.
795   795:  *
796   796:  * BUGS
797   797:  *    Asynch. signals don't guarantee access to volatile data at sequence pts;
798   798:  *    Since we restrict our access to READ operations, this shouldn't pose any
799   799:  *    problem, - though not strictly ANSI (cf. type sig_atomic_t).
800   800:  *-4*/
801   801:     char      pzLine[MAXLINE];         /* Line buffer */
802   802: 
803   803:     /* 1: Prompt user for break confirmation; - issue warning if situation 1 ! */
804   804:     fprintf(stdout, "\nINTERRUPT:\tSignal [%d] received\n", iSigNum);
805   805:     fprintf(stdout, "\tCurrent state of indexfile [%s] : INTEGRITY [%s]\n",
806   806: 	    HI->filename, (HI->indexmode == RW ? "UNKNOWN" : "OK"));
807   807:     fprintf(stdout, (HI->indexmode == RW ? "\tIndex not complete!, -" : "\t"));
808   808:     fprintf(stdout, "Sig %d, Abort program? [Y|N] => ", iSigNum);
809   809: 
810   810: 
811   811:     /* 2: Depending on user answer : terminate [Y] or continue [N] */
812   812:     (void) fgets(pzLine, MAXLINE, stdin);
813   813:     if (strchr(pzLine,'y') != NULL || strchr(pzLine, 'Y') != NULL) {
814   814: 	/* 2.1: Terminate program "gracefully" */
815   815: 	eHashIdxClose(&HI);
816   816: 	exit(EXIT_FAILURE);
817   817:     }
818   818:     else
819   819: 	/* 2.2: Continue : reset signal, and continue */
820   820: 	signal(iSigNum, vSigCatch);
821   821: 
822   822: }   /* END function vSigCatch() */
823   823: 
824   824: 
825   825: 
826   826: /*+4 MODULE HASH.C ---------------------------------------------------------*/
827   827: /*   NAME   02                  vKeyGet                                     */
828   828: /*-- SYNOPSIS --------------------------------------------------------------*/
829   829: PRIVATE void
830   830: vKeyGet(wKeySize, pzKeyBuf)
831   831:     WORD      wKeySize;	    /* Size of key (#chars) to generate/read */
832   832:     char     *pzKeyBuf;	    /* Buffer for placing key value */
833   833: {
834   834: /* DESCRIPTION
835   835:  *    Support function for REAL_MAIN() test driver.
836   836:  *    Get a key value of "wKeySize" characters into the buffer "pzKeyBuf"; -
837   837:  *    pzKeyBuf must be at least wKeySize+1 byte wide.
838   838:  *    Depending on the compilation flag "RANDOM", the function will :
839   839:  *    1: [RANDOM defined].. - call rRandom() to create a pseudorandom keyvalue,
840   840:  *    2: [RANDOM undefined] - prompt the user for a keyvalue.

XC ... 'C' Concordance Utility   ss.c                       Page 16

841   841:  *       A keysize < wKeySize is padded with spaces, and a keysize > wKeySize
842   842:  *       is "chopp'd off", so the size of the returned key is always wKeySize.
843   843:  *
844   844:  * RETURN
845   845:  *    Call-by-reference: A keystring of wKeySize chars placed in pzKeyBuf
846   846:  *-4*/
847   847: 
848   848: #ifdef RANDOM
849   849:     /* 1: Create a pseudorandom key value */
850   850:     WORD      wRan  = 0;           /* One random number */
851   851:     WORD      wLet  = 0;               /* One random generated letter in keystr. */
852   852:     WORD      wKsz  = wKeySize;        /* Size of key (# byte) */
853   853:     char     *pzKp  = pzKeyBuf;        /* Pointer to step through keystring */
854   854:     float     fShft = (float) 10000.0; /* Factor for mult. random fraction */
855   855: 
856   856:     while (wKsz-- > 0) {
857   857: 	wRan = (WORD) ((float)rRandom() * fShft);
858   858: 	wLet = (wRan % 26) + 'a';
859   859: 	*pzKp++ = (char) ((wRan % 10) ? wLet : toupper(wLet));
860   860:     }
861   861: #else
862   862:     /* 2: Get a key value from stdin */
863   863:     fprintf(stdout, "\nEnter a key value %d chars -> ", wKeySize);	/* prompt */
864   864:     strncpy(pzKeyBuf, "                              ", wKeySize);	/* clear */
865   865:     fgets(pzKeyBuf, wKeySize, stdin);
866   866:     while (getchar() != '\n')
867   867:        /* eat rest of the line */ ;
868   868: #endif
869   869: 
870   870:     /* Zero-terminate (& "clamp"/chop off) the key value at size "wKeySize" */
871   871:     *(pzKeyBuf + wKeySize) = '\0';
872   872: 
873   873: }   /* END function vKeyGet() */
874   874: 
875   875: 
876   876: 
877   877: /*+4 MODULE HASH.C----------------------------------------------------------*/
878   878: /*   NAME   03                    wKeyPrint                                 */
879   879: /*-- SYNOPSIS --------------------------------------------------------------*/
880   880: PRIVATE   WORD
881   881: wKeyPrint(pzKeyBuf, dwDatOff)
882   882:     char     *pzKeyBuf;	    /* Keystring, - not zero terminated */
883   883:     DWORD     dwDatOff;	    /* Corresponding datafile offset */
884   884: {
885   885: /* DESCRIPTION
886   886:  *    Support function for REAL_MAIN() test driver.
887   887:  *    Print one hashindex key-record: (keyvalue,offset) on stdout; -
888   888:  *    The function may be passed as parameter to function : eHashIdxProcess()
889   889:  *    for looping through the indexfile and printing the contents of all valid
890   890:  *    (ie. USED) indexrecords.
891   891:  * RETURN
892   892:  *    Side effects ........: Hashindex records (key & offset) printed on stdout
893   893:  *    Function return value: '1' indicating to eHashIdxProcess() that printing
894   894:  *                           should continue for ALL all key-records.
895   895:  *-4*/
896   896: 

XC ... 'C' Concordance Utility   ss.c                       Page 17

897   897:     /* Make sure key-string is zero-terminated */
898   898:     strncpy(pzKBuf, pzKeyBuf, Ksize);
899   899:     *(pzKBuf + Ksize) = '\0';
900   900: 
901   901:     /* Print corresponding key-value and datafile offset */
902   902:     fprintf(stdout, "Key[%s]-(lookup)->FlatfileOffset[%lu]\n", pzKBuf, dwDatOff);
903   903: 
904   904:     /* "Again" code : [1] continue, [0] stop - cf. eHashIdxProcess() */
905   905:     return (1);
906   906: 
907   907: }   /* END function wKeyPrint() */
908   908: 
909   909: 
910   910: 
911   911: /*+4 MODULE HASH.C----------------------------------------------------------*/
912   912: /*   NAME   04                    eIdxStatPrint                             */
913   913: /*-- SYNOPSIS --------------------------------------------------------------*/
914   914: PRIVATE   eRetType
915   915: eIdxStatPrint(pH)
916   916:     HASH     *pH;	       /* Handle for hashindex descr.struct */
917   917: {
918   918: /* DESCRIPTION
919   919:  *    Support function for REAL_MAIN() test driver.
920   920:  *    Print size and load-statistics for hashindex file.
921   921:  * RETURN
922   922:  *    Side effects ........: Hashindex status (size & load) printed on stdout
923   923:  *    Function return value: OK if operation succeeded, ERROR otherwise.
924   924:  *                           If ERROR, "Astat" holds the precise error code.
925   925:  *-4*/
926   926: 
927   927:     DWORD     dwSize = 0L;     /* Var. parameter for eHashIdxGetSize */
928   928:     DWORD     dwUsed = 0L;     /* Ditto */
929   929:     WORD      wLoad  = 0;      /* Indexfile load factor */
930   930: 
931   931:     ACHK_ERR(eHashIdxGetSize(pH, &dwSize, &dwUsed), A_STOP)
932   932:     fprintf(stdout, "Hashindex keyrecords : Size=[%lu], Used=[%lu]\n", dwSize, dwUsed);
933   933: 
934   934:     ACHK_ERR(eHashIdxGetLoad(pH, &wLoad), A_STOP)
935   935:     fprintf(stdout, "Loadfactor=%d\n", wLoad);
936   936: 
937   937:     ARET_OK
938   938: 
939   939: }   /* END function eIdxStatPrint() */
940   940: 
941   941: #endif /* MAIN */
942   942: 
943   943: 
944   944: 
945   945: 
946   946: /****************************************************************************/
947   947: /**************************** HASH ALGORITHM ********************************/
948   948: /****************************************************************************/
949   949: 
950   950: /* Define machine-independent percentages of DWORD datatype (cf. general.h) */
951   951: /* obs: LINT may quabble about "Unusual use of Boolean" & "Suspicious cast" */
952   952: PRIVATE DWORD dw12P = ((DWORD)( (NBITS(DWORD)) * 0.125));  /* 12% of dwbits */

XC ... 'C' Concordance Utility   ss.c                       Page 18

953   953: PRIVATE DWORD dw75P = ((DWORD)( (NBITS(DWORD)) * 0.75 ));  /* 75% of dwbits */
954   954: PRIVATE DWORD dwHB  = ((DWORD)(~((DWORD)(~0) >> ((DWORD)( (NBITS(DWORD)) * 0.125)))));
955   955: 
956   956: PRIVATE FLAG  fFirstHash = FALSE;  /* Flag for RF_DBL double hashing method */
957   957: PRIVATE DWORD dwPrime2   = 0L;     /* Calculated prime for Index-size */
958   958: PRIVATE DWORD dwPrime1   = 0L;     /* Twin-prime (dwPrime2-2L) for RF_DBL */
959   959: 
960   960: 
961   961: 
962   962: /*+3 MODULE HASH.C =========================================================*/
963   963: /*   NAME   05               dwHashFunc                                     */
964   964: /*== SYNOPSIS ==============================================================*/
965   965: PRIVATE   DWORD
966   966: dwHashFunc(pcKeystr, wKsize, dwMaxSlot)
967   967:     char     *pcKeystr;        /* Keystring to hash */
968   968:     WORD      wKsize;          /* Size of keystring (# byte) */
969   969:     DWORD     dwMaxSlot;       /* Number of "slots" in target hash-table */
970   970: {
971   971: /* DESCRIPTION
972   972:  *    Hash algorithms. The following transformations are offered :
973   973:  *       1: Cichelli's First+Last+Length - Not usefull for keys of fixed length
974   974:  *       2: Simple Sum-of-chars - Can't handle permutations & large tabels
975   975:  *       3: "P.J.Weinburger" hash - slower but solves the problems [DEFAULT]
976   976:  * RETURN
977   977:  *    Function return value: Hashvalue of pcKeystr, cf function spec: HF_TYPE.
978   978:  *-3*/
979   979: 
980   980:     D(char   *pcKst  = pcKeystr;)   /* Variable for DEBUG trace */
981   981:     D(WORD   wKsz    = wKsize;)     /* Variable for DEBUG trace */
982   982:     int      iKeylen       = 0;     /* Length of keystring */
983   983:     register DWORD dwHval1 = 0L;    /* Scratch hash calc. variables */
984   984:     register DWORD dwHval2 = 0L;    /* Scratch hash calc. variables */
985   985: 
986   986:     assert(HF_TYPE == HF_FLL || HF_TYPE == HF_ADD || HF_TYPE == HF_PJW);
987   987: 
988   988: 
989   989:     switch (HF_TYPE) {
990   990: 
991   991: 	case HF_FLL:
992   992: 	    /* Cichelli's "minimal perfect hash function" candidate :  */
993   993: 	    /* First+Last+Length; Not usefull for keys of fixed length */
994   994: 	    iKeylen = strlen(pcKeystr);
995   995: 	    dwHval1 = (DWORD) ((*pcKeystr << 8) + *(pcKeystr + iKeylen - 1) \
996   996: 			       +iKeylen) % dwMaxSlot;
997   997: 	    break;
998   998: 
999   999: 	case HF_ADD:
1000 1000: 	    /* "Sum-of-chars" hash function */
1001 1001: 	    /* Simple and fast, not good at handling permutations & large tables */
1002 1002: 	    for (dwHval1 = (DWORD) *pcKeystr; wKsize-- > (WORD) 0 && *pcKeystr != '\0'; pcKeystr++)
1003 1003: 		   dwHval1 = ((dwHval1 << 8) + (DWORD) *pcKeystr) % dwMaxSlot;
1004 1004: 	    /* Terminates at keysize or EOS */
1005 1005: 	    break;
1006 1006: 
1007 1007:         default :
1008 1008:             /*FALLTHRU*/

XC ... 'C' Concordance Utility   ss.c                       Page 19

1009 1009:             /* Fall through to default hash method: HF_PJW */
1010 1010: 	case HF_PJW:
1011 1011: 	    /* "P.J.Weinburger" compiler hash func. for C-pgm. identifiers */
1012 1012: 	    /* Somewhat slower than HF_ADD, - but solves the problems      */
1013 1013: 	    for (dwHval1 = (DWORD)0; wKsize-- > (WORD)0 && *pcKeystr != '\0'; pcKeystr++) {
1014 1014:                dwHval1 = (dwHval1 << dw12P) + (DWORD) *pcKeystr;
1015 1015: 	       if ( (dwHval2 = (dwHval1 & dwHB)) > (DWORD)0L )
1016 1016: 	          dwHval1 = ((dwHval1 ^ (dwHval2 >> dw75P)) & ~dwHB);
1017 1017: 	    }
1018 1018: 	    dwHval1 = (DWORD) (dwHval1 % dwMaxSlot);
1019 1019: 	    break;
1020 1020:     }
1021 1021: 
1022 1022:     fFirstHash = TRUE;     /* Raise flag for 1. hashing */
1023 1023: 
1024 1024:     D(vHashTrace(pcKst, wKsz, dwHval1));
1025 1025:     STCK("dwHashFunc");
1026 1026:     return (dwHval1);
1027 1027: 
1028 1028: }   /* END function dwHashFunc() */
1029 1029: 
1030 1030: 
1031 1031: 
1032 1032: /*+3 MODULE HASH.C =========================================================*/
1033 1033: /*   NAME   06               dwRehashFunc                                   */
1034 1034: /*== SYNOPSIS ==============================================================*/
1035 1035: PRIVATE   DWORD
1036 1036: dwRehashFunc(pcKeystr, wKsize, dwCurSlot, dwMaxSlot)
1037 1037:     char     *pcKeystr;        /* Keystring for Re-hash */
1038 1038:     WORD      wKsize;          /* Size of keystring (# byte) */
1039 1039:     DWORD     dwCurSlot;       /* Current "slot" in hash-table for Re-hash */
1040 1040:     DWORD     dwMaxSlot;       /* Number of "slots" in target hash-table */
1041 1041: {
1042 1042: /* DESCRIPTION
1043 1043:  *    Collision-resolution algorithms. The following transformations are offered:
1044 1044:  *    1: Linear rehashing with constant increment = 1
1045 1045:  *   [2: Quadratic rehashing - Not implemented (reserved for future use)]
1046 1046:  *    3: Double hashing with twin primes [DEFAULT]
1047 1047:  * RETURN
1048 1048:  *    Function return value: ReHashvalue of pcKeystr, cf function spec: RF_TYPE.
1049 1049:  *-3*/
1050 1050: 
1051 1051:     register DWORD dwRval  = 0L;     /* Rehash value */
1052 1052:     static   DWORD dwRincr = 0L;     /* Rehash increment, calc. on 1.st RF_DBL */
1053 1053: 
1054 1054:     assert(RF_TYPE == RF_LIN || RF_TYPE == RF_DBL);
1055 1055: 
1056 1056: 
1057 1057:     switch (RF_TYPE) {
1058 1058: 
1059 1059: 	case RF_LIN:
1060 1060:            /* Linear rehashing with constant increment = 1 */
1061 1061:            dwRval = (dwCurSlot + 1) % dwMaxSlot;
1062 1062:            break;
1063 1063: 
1064 1064: 	case RF_QAD:

XC ... 'C' Concordance Utility   ss.c                       Page 20

1065 1065:            /* Quadratic rehashing - reserved for future use */
1066 1066:            /* ---Not implemented, bail out if used!--- */
1067 1067:            assert(TRUE == FALSE);            /* Never! */
1068 1068:            break;
1069 1069: 
1070 1070: 
1071 1071: 	default:
1072 1072:            /*FALLTHRU*/
1073 1073:            /* Fall through to default hash method: RF_DBL */
1074 1074: 	case RF_DBL:
1075 1075:            /* Double hashing with twin primes */
1076 1076:            if (fFirstHash == TRUE) {
1077 1077:               dwRincr = dwHashFunc(pcKeystr, wKsize, dwPrime1) + 1L;
1078 1078:               fFirstHash = FALSE;
1079 1079:            }
1080 1080:            dwRval = (dwCurSlot + dwRincr) % dwMaxSlot;
1081 1081:            break;
1082 1082:     }
1083 1083: 
1084 1084:     STCK("dwRehashFunc");
1085 1085:     return (dwRval);
1086 1086: 
1087 1087: }   /* END function dwRehashFunc() */
1088 1088: 
1089 1089: 
1090 1090: 
1091 1091: #ifdef DEBUG
1092 1092: static char rgcKbf[80];
1093 1093: 
1094 1094: /*+4 MODULE HASH.C ---------------------------------------------------------*/
1095 1095: /*   NAME   07               vHashTrace                                     */
1096 1096: /*-- SYNOPSIS --------------------------------------------------------------*/
1097 1097: PRIVATE void
1098 1098: vHashTrace(pcKeystr, wKsize, dwCurSlot)
1099 1099:     char     *pcKeystr;        /* key value (string) */
1100 1100:     WORD      wKsize;          /* key size (#byte) */
1101 1101:     DWORD     dwCurSlot;       /* Current "slot" in target hash-table */
1102 1102: {
1103 1103: /* DESCRIPTION
1104 1104:  *    Trace a hashing lookup : print (key-string, hashtable-slot)
1105 1105:  *-4*/
1106 1106: 
1107 1107:     char     *pcKst = pcKeystr;
1108 1108: 
1109 1109:     strncpy(rgcKbf, pcKst, wKsize);
1110 1110:     rgcKbf[wKsize] = '\0';
1111 1111: 
1112 1112:     fprintf(stdout, "Key[%s]-(hash)->HashfileKeyRecord[%lu]\n", rgcKbf, dwCurSlot);
1113 1113: 
1114 1114: }   /* END function vHashTrace() */
1115 1115: 
1116 1116: #endif   /* ifdef DEBUG */
1117 1117: 
1118 1118: 
1119 1119: 
1120 1120: 

XC ... 'C' Concordance Utility   ss.c                       Page 21

1121 1121: /****************************************************************************/
1122 1122: /**************************** HASHINDEX HEADER ******************************/
1123 1123: /****************************************************************************/
1124 1124: #define INTEGRITY_UNKNOWN   0L	    /* set when opened for WRITE */
1125 1125: #define INTEGRITY_OK       -1L	    /* set when closed properly */
1126 1126: 
1127 1127: 
1128 1128: /*+2 MODULE HASH.C =========================================================*/
1129 1129: /*   NAME   08               eHashIdxCreate                                 */
1130 1130: /*== SYNOPSIS ==============================================================*/
1131 1131: PUBLIC    eRetType
1132 1132: eHashIdxCreate(pH, pzIdxFile, wKsize, dwIsize)
1133 1133:     HASH     *pH;          /* handle for hashindex descr.struct to create */
1134 1134:     char     *pzIdxFile;   /* name of the physical hashindex (disk file) */
1135 1135:     WORD      wKsize;      /* size of the keys to use (# byte per key) */
1136 1136:     DWORD     dwIsize;     /* size of the hashindex file (# key records) */
1137 1137: {
1138 1138: /* DESCRIPTION
1139 1139:  *    Creates (and opens) a hash-index file in the current directory on disk
1140 1140:  *    with the name of "pzIdxFile". Up to "dwIsize" key records with a key
1141 1141:  *    size of "wKsize" may be inserted into the index (using eHashKeyInsert)
1142 1142:  *    before expansion becomes nessecary.
1143 1143:  *
1144 1144:  *    1.1: Allocates an "incore" hashindex descriptor (struct stHcore), and
1145 1145:  *         "points" the handle (HASH *pH) to this structure.
1146 1146:  *    1.2: Creates a new hashindex file with the name "pzIdxFile", and inserts
1147 1147:  *         the hashindex filedescriptor and filename into the HASH descriptor.
1148 1148:  *    1.3: Adjusts the size of the hashindex to next higher prime (performance).
1149 1149:  *    1.4: Initializes the hashindex size-information (struct stHsize, incor-
1150 1150:  *         porated in the hashindex descriptor).
1151 1151:  *    2.1. Copies the hashindex size-information to a hashindex fileheader
1152 1152:  *         (struct stHdisk), and writes the fileheader to the hashindex.
1153 1153:  *    2.2: Writes "dwIsize" number of empty key records (struct stHkey) to
1154 1154:  *         the hashindex. The key records are allocated "wKsize" bytes for a
1155 1155:  *         keyvalue and a LONG for use as index into a normal flat datafile.
1156 1156:  * RETURN
1157 1157:  *    Call-by-reference ...: Handle pH pointed to incore HASH index descriptor.
1158 1158:  *    Side effects ........: Hashindex "pzIdxFile" created & initialized (open).
1159 1159:  *    Function return value: OK if operation succeeded, ERROR otherwise.
1160 1160:  *                           If ERROR, "Astat" holds the precise error code.
1161 1161:  * EXAMPLE
1162 1162:  *     #include "hash.h"
1163 1163:  *     HASH H;
1164 1164:  *     if (eHashIdxCreate(&H, "HASH.IDX", sizeof(datakey), 100) == ERROR)
1165 1165:  *        fprintf(stderr, "ERROR[%d] : %s\n", Astat, ERRMSG[Astat]);
1166 1166:  * SEE ALSO
1167 1167:  *    hash.h, for a detailed description of data structures and return codes.
1168 1168:  *-2*/
1169 1169: 
1170 1170:     struct   stHdisk stIdxHdr;     /* Hash index header record structure */
1171 1171:     struct   stHkey stKeyRec;      /* Hash index key record structure */
1172 1172:     FILE     *fd      = NULL;      /* Hash index file descriptor */
1173 1173:     eRetType eRetCode = ERROR;     /* Hash function return code */
1174 1174:     register DWORD dwCount = 0L;   /* Scracth count variable */
1175 1175: 
1176 1176: 

XC ... 'C' Concordance Utility   ss.c                       Page 22

1177 1177:     /* 0: Check that indexfile not already exists */
1178 1178:     if ((fd = fopen(pzIdxFile, "r")) != (FILE *) NULL) {
1179 1179: 	(void) fclose(fd);
1180 1180: 	ARET_ERR(TRUE, A_FILEEXIST, 801);
1181 1181:     }
1182 1182:     assert(wKsize >= 1 && dwIsize >= 3);
1183 1183: 
1184 1184: 
1185 1185:     /* ------------------- Hashindex in core ------------------------------- */
1186 1186: 
1187 1187:     /* 1.1: Build "in core" hashindex descriptor struct. */
1188 1188:     *pH = (HASH) malloc(sizeof(struct stHcore));
1189 1189:     ARET_ERR(*pH == NULL, A_BADALLOC, 802);
1190 1190: 
1191 1191:     /* 1.2: Create (and open) the hashindex file, mode read/write */
1192 1192:     (*pH)->fd = fopen(pzIdxFile, "w+b");
1193 1193:     ARET_ERR((*pH)->fd == NULL, A_NOTCREATE, 803);
1194 1194:     ARET_ERR(pzStrcpyAlloc(&(*pH)->filename, pzIdxFile) == NULL, A_BADALLOC, 804);
1195 1195: 
1196 1196:     /* 1.3: Compute prime size of hashindex file (# key records) */
1197 1197:     dwPrime2 = dwIsize + 1L;    /* 1 empty slot required for search termination */
1198 1198:     vGetPrime(&dwPrime2, TRUE);
1199 1199:     if (RF_TYPE == RF_DBL) {    /* Find twin primes if double hashing */
1200 1200: 	while (!fIsPrime(dwPrime2 - 2L)) {
1201 1201: 	    D(fprintf(stdout, "MAXKEY2[%ld]\n", dwPrime2));
1202 1202: 	    dwPrime2++;
1203 1203: 	    vGetPrime(&dwPrime2, TRUE);
1204 1204: 	}
1205 1205: 	dwPrime1 = dwPrime2 - 2L;
1206 1206: 	D(fprintf(stdout, "MAXKEY2[%ld]\n", dwPrime2));
1207 1207: 	D(fprintf(stdout, "MAXKEY1[%ld]\n", dwPrime1));
1208 1208:     }
1209 1209: 
1210 1210:     /* 1.4: Initialize the hashindex size struct */
1211 1211:     (*pH)->indexsize.wKsize = wKsize;
1212 1212:     (*pH)->indexsize.dwIsize = dwPrime2;
1213 1213:     (*pH)->indexsize.dwIused = 0;
1214 1214:     (*pH)->indexstatus = IOPEN;
1215 1215:     (*pH)->indexmode = RW;
1216 1216: 
1217 1217: 
1218 1218:     /* ------------------- Hashindex on disk ------------------------------- */
1219 1219: 
1220 1220:     /* 2.1: Allocate & init a hashindex fileheader, and write it to file */
1221 1221:     vUpdate_stHdisk(*pH, &stIdxHdr, NO);
1222 1222:     eRetCode = eWriteIdxHdr(*pH, &stIdxHdr);
1223 1223:     ARET_ERR(eRetCode == ERROR, Astat, 805);
1224 1224: 
1225 1225: 
1226 1226:     /* 2.2: Write all key-records (ie. create hashindex file in FULL SIZE) */
1227 1227:     stKeyRec.status = VACANT;      /* All records initially empty and free */
1228 1228:     stKeyRec.key = (char *) malloc(wKsize);
1229 1229:     (void) memset(stKeyRec.key, '#', wKsize);
1230 1230:     stKeyRec.dwDatOffset = 0L;
1231 1231: 
1232 1232:     for (dwCount = 0L; dwCount < (*pH)->indexsize.dwIsize; dwCount++) {

XC ... 'C' Concordance Utility   ss.c                       Page 23

1233 1233: 	eRetCode = eWriteIdxKey(*pH, dwCount, &stKeyRec);
1234 1234: 	ARET_ERR(eRetCode == ERROR, Astat, 806);
1235 1235:     }
1236 1236:     free(stKeyRec.key);
1237 1237: 
1238 1238:     STCK("eHashIdxCreate");
1239 1239:     ARET_OK
1240 1240: 
1241 1241: }   /* END function eHashIdxCreate() */
1242 1242: 
1243 1243: 
1244 1244: 
1245 1245: /*+2 MODULE HASH.C =========================================================*/
1246 1246: /*   NAME   09               eHashIdxOpen                                   */
1247 1247: /*== SYNOPSIS ==============================================================*/
1248 1248: PUBLIC    eRetType
1249 1249: eHashIdxOpen(pH, pzIdxFile, pzAccess)
1250 1250:     HASH     *pH;          /* handle for hashindex descr.struct. to create */
1251 1251:     char     *pzIdxFile;   /* name of the physical hashindex (disk file) */
1252 1252:     char     *pzAccess;    /* "rb" (for ReadOnly) or "w+b" (for ReadWrite) */
1253 1253: {
1254 1254: /* DESCRIPTION
1255 1255:  *    Opens an already existing hash-index file in the current directory on
1256 1256:  *    disk with the name of "pzIdxFile" and the open-mode of "pzAccess".
1257 1257:  *    Valid modes are : "rb" (ReadOnly access) and "w+b" (ReadWrite access).
1258 1258:  *
1259 1259:  *    1: Opens an existing hash index "pzIdxFile" in mode "pzAccess" ("rb"/"w+b")
1260 1260:  *    2: Allocates an "in core" hashindex descriptor structure (struct stHcore)
1261 1261:  *       and points the handle passed as parameter (HASH* pH) to this structure.
1262 1262:  *       (The initial parameter-value of the handle is assumed to be NULL).
1263 1263:  *    3: Verifies the hash index header record by calculating a CCITT-CRC of
1264 1264:  *       the embedded struct stHsize, and compares this value with a previ-
1265 1265:  *       ously calculated checksum (also stored in the header).
1266 1266:  *    4: Initializes the "in core" hash index descriptor with basic file
1267 1267:  *       information : open-status, filename, filesize.
1268 1268:  *    5: Verifies the hash index file "integrity" field, which indicates a
1269 1269:  *       succesful close-operation after a Read/Write acces to the hash index.
1270 1270:  *       If the hash index has not been closed properly (bad CRC), the
1271 1271:  *       function restores the essential size-information in the file header.
1272 1272:  *       NB: The integrity-verification is designed for SingleUser creation,
1273 1273:  *       and maintenamce of hashindex'es in acces-mode ReadWrite; - it does
1274 1274:  *       NOT apply (and is not relevant) for multiuser acces in ReadOnly mode.
1275 1275:  *    6: Patch, for "double hashing". This hashing method requires a set of
1276 1276:  *       "twin primes": the table size (T) for hashing, and T-2 for rehashing.
1277 1277:  * RETURN
1278 1278:  *    Call-by-reference ...: Handle pH pointed to incore HASH index descriptor.
1279 1279:  *    Side effects ........: Hashindex "filename" opened in mode "access".
1280 1280:  *    Function return value: OK if operation succeeded, ERROR otherwise.
1281 1281:  *                           If ERROR, "Astat" holds the precise error code.
1282 1282:  * EXAMPLE
1283 1283:  *     #include "hash.h"
1284 1284:  *     HASH H;
1285 1285:  *     if (eHashIdxOpen(&H, "HASH.IDX", "rb") == ERROR)
1286 1286:  *        fprintf(stderr, "ERROR[%d] : %s\n", Astat, ERRMSG[Astat]);
1287 1287:  * SEE ALSO
1288 1288:  *    hash.h, for a detailed description of data structures and return codes.

XC ... 'C' Concordance Utility   ss.c                       Page 24

1289 1289:  *-2*/
1290 1290: 
1291 1291:     struct    stHdisk stIdxHdr;    /* Hash index header record structure */
1292 1292:     FILE      *fd       = NULL;    /* Hash index file descriptor */
1293 1293:     eRetType  eRetCode  = ERROR;   /* Hash function return code  */
1294 1294:     int       iCheckSum = 0;       /* Hash index checksum (CRC)  */
1295 1295: 
1296 1296:     
1297 1297:     D(fprintf(stdout, "Opening SS-file[%s], mode[%s] :\n",
1298 1298: 	     pzIdxFile, (strcmp(pzAccess, "rb") == 0 ? "RO" : "RW"));)
1299 1299: 
1300 1300:     /* 1: Open an existing hash index file */
1301 1301:     ARET_ERR((*pH) != NULL && (*pH)->indexstatus == IOPEN, A_ISOPEN, 901);
1302 1302:     fd = fopen(pzIdxFile, pzAccess);
1303 1303:     ARET_ERR(!fd, A_NOFILE, 902);
1304 1304: 
1305 1305: 
1306 1306:     /* 2: Allocate an "in core" hashindex descriptor structure */
1307 1307:     *pH = (HASH) malloc(sizeof(struct stHcore));
1308 1308:     ARET_ERR(!*pH, A_BADALLOC, 903);
1309 1309: 
1310 1310: 
1311 1311:     /* 3: Verify the hash index file header record (is CRC OK ?) */
1312 1312:     (*pH)->fd = fd;
1313 1313:     eRetCode = eReadIdxHdr(*pH, &stIdxHdr);	/* read the header record */
1314 1314:     ARET_ERR(eRetCode == ERROR, Astat, 904);
1315 1315: 
1316 1316:     iCheckSum = wCCITTcrc((char *) (&stIdxHdr.indexsize), (WORD) sizeof(struct stHsize));
1317 1317:     ARET_ERR(iCheckSum != stIdxHdr.checksum, A_WRONGFILE, 905);
1318 1318: 
1319 1319: 
1320 1320:     /* 4: Initialize the "in core" hash index descriptor with hashfile info */
1321 1321:     (*pH)->indexstatus = IOPEN;
1322 1322:     (*pH)->indexmode = (strcmp(pzAccess, "rb") == 0 ? RO : RW);
1323 1323:     ARET_ERR(pzStrcpyAlloc(&(*pH)->filename, pzIdxFile) == NULL, A_BADALLOC, 906);
1324 1324:     (*pH)->indexsize = stIdxHdr.indexsize;
1325 1325: 
1326 1326:     D(fprintf(stdout, "\tRead SS-header: dwIsize[%ld], dwIused[%ld], wKsize[%d]\n",
1327 1327:        stIdxHdr.indexsize.dwIsize, stIdxHdr.indexsize.dwIused, stIdxHdr.indexsize.wKsize); )
1328 1328: 
1329 1329:     /* 5:  Verify the hash index file integrity (has file been closed OK?) */
1330 1330:     /* NB: Applies only for "SingleUser" mode (ie. file opened READWRITE)  */
1331 1331:     if ((*pH)->indexmode == RW)    /* Multiuser RO : ignore! */
1332 1332: 	if (stIdxHdr.integrity == INTEGRITY_OK) {
1333 1333: 	    /* Indexfile has been closed ok, - now mark it open */
1334 1334: 	    stIdxHdr.integrity = INTEGRITY_UNKNOWN;
1335 1335: 	    eRetCode = eWriteIdxHdr(*pH, &stIdxHdr);
1336 1336: 	    ARET_ERR(eRetCode == ERROR, Astat, 907);
1337 1337: 	}
1338 1338: 	else {
1339 1339: 	    /* Indexfile NOT closed properly, - restore index stIdxHdr */
1340 1340: 	    eRetCode = eHashIdxRestore(pH);
1341 1341: 	    ARET_ERR(eRetCode == ERROR, Astat, 908);
1342 1342: 	}
1343 1343: 
1344 1344:     /* 6: Patch, for double hashing : set global variable for rehash */

XC ... 'C' Concordance Utility   ss.c                       Page 25

1345 1345:     dwPrime1 = (*pH)->indexsize.dwIsize - 2L;
1346 1346: 
1347 1347:     STCK("eHashIdxOpen");
1348 1348:     ARET_OK
1349 1349: 
1350 1350: }   /* END function eHashIdxOpen() */
1351 1351: 
1352 1352: 
1353 1353: 
1354 1354: /*+2 MODULE HASH.C =========================================================*/
1355 1355: /*   NAME   10               eHashIdxClose                                  */
1356 1356: /*== SYNOPSIS ==============================================================*/
1357 1357: PUBLIC    eRetType
1358 1358: eHashIdxClose(pH)
1359 1359:     HASH     *pH;	  /* handle for hashidx descr. w/filename to close */
1360 1360: {
1361 1361: /* DESCRIPTION
1362 1362:  *    Closes an open hashindex file, and releases the resources allocated
1363 1363:  *    for the attached "in core" hashindex descriptor structure.
1364 1364:  *    NB: This function MUST be called before "touching the big red button"
1365 1365:  *    to guarantee validity of the indexfile (if opened in ReadWrite mode).
1366 1366:  *
1367 1367:  *    1: Checks that the hashindex to be closed is in fact open !
1368 1368:  *    2: Updates the hashindex file header record w/ size, CRC and validity.
1369 1369:  *       NB: The indexheader-update is designed for SingleUser creation,
1370 1370:  *       and maintenamce of hashindex'es in acces-mode ReadWrite; - it does
1371 1371:  *       NOT apply (and is not relevant) for multiuser acces in ReadOnly mode.
1372 1372:  *       2.1: Fills in a hashindex header structure (struct stHdisk) with the
1373 1373:  *            current values from the "in core" hashindex descriptor structure
1374 1374:  *            (struct stHcore) pointed to by the handle HASH *pH (parameter).
1375 1375:  *            The actual updating of the header structure is done by calling
1376 1376:  *            the support function vUpdate_stHdisk() to define the header-
1377 1377:  *            values for the hashindex size, header-checksum and file-validity.
1378 1378:  *       2.2: Writes the updated hashindex header structure (struct stHdisk)
1379 1379:  *            as the first record to the hashindex file.
1380 1380:  *    4: Closes the hashindex file.
1381 1381:  *    5: Frees the "in core" hashindex descriptor structure (struct stHcore)
1382 1382:  *       pointed to by the handle HASH *pH (passed as parameter).
1383 1383:  * RETURN
1384 1384:  *    Side effects ........: Hashindex file (*pH)->filename closed.
1385 1385:  *                           Incore HASH index descriptor "free'd" (pH=NULL)
1386 1386:  *    Function return value: OK if operation succeeded, ERROR otherwise.
1387 1387:  *                           If ERROR, "Astat" holds the precise error code.
1388 1388:  * EXAMPLE
1389 1389:  *     #include "hash.h"
1390 1390:  *     HASH H;
1391 1391:  *     if (eHashIdxClose(&H) == ERROR)
1392 1392:  *        fprintf(stderr, "ERROR[%d] : %s\n", Astat, ERRMSG[Astat]);
1393 1393:  * SEE ALSO
1394 1394:  *    hash.h, for a detailed description of data structures and return codes.
1395 1395:  *-2*/
1396 1396: 
1397 1397:     struct stHdisk stIdxHdr;   	/* Hash index header record structure */
1398 1398:     eRetType  eRetCode = ERROR;	/* Hash function return code */
1399 1399: 
1400 1400: 

XC ... 'C' Concordance Utility   ss.c                       Page 26

1401 1401:     /* 1: Check that the hashindex to be closed is actually open by now ! */
1402 1402:     ARET_ERR((*pH)->indexstatus != IOPEN, A_NOTOPEN, 1001);
1403 1403: 
1404 1404: 
1405 1405:     /* 2: Reset the hashindex header : size, checksum and integrity fields */
1406 1406:     /* NB: Applies only for "SingleUser" mode (ie. file opened READWRITE)  */
1407 1407:     if ((*pH)->indexmode == RW) {  /* Multiuser RO : ignore */
1408 1408: 
1409 1409: 	/* 2.1: Fill in a hashindex header from the hashindex descriptor */
1410 1410: 	vUpdate_stHdisk(*pH, &stIdxHdr, YES);
1411 1411: 
1412 1412: 	/* 2.2: Write the updated hashindex header as 1.rec. in indexfile */
1413 1413: 	eRetCode = eWriteIdxHdr(*pH, &stIdxHdr);
1414 1414: 	ARET_ERR(eRetCode == ERROR, Astat, 1002);
1415 1415:     }
1416 1416: 
1417 1417:     /* 3: Close the hashindex file */
1418 1418:     eRetCode = (fclose((*pH)->fd) != 0 ? ERROR : OK);
1419 1419:     ARET_ERR(eRetCode == ERROR, A_FILECLOSE, 1003);
1420 1420:     (*pH)->indexstatus = ICLOSED;
1421 1421: 
1422 1422: 
1423 1423:     /* 4: Free the "in core" hashindex descriptor structure */
1424 1424:     free((*pH)->filename);
1425 1425:     free((char *) (*pH));
1426 1426:     pH = NULL;
1427 1427: 
1428 1428: 
1429 1429:     STCK("eHashIdxClose");
1430 1430:     ARET_OK
1431 1431: 
1432 1432: }   /* END function eHashIdxClose() */
1433 1433: 
1434 1434: 
1435 1435: 
1436 1436: /*+4 MODULE HASH.C ---------------------------------------------------------*/
1437 1437: /*   NAME   11               vUpdate_stHdisk                                */
1438 1438: /*-- SYNOPSIS --------------------------------------------------------------*/
1439 1439: PRIVATE void
1440 1440: vUpdate_stHdisk(H, pstIdxHdr, eIntegr)
1441 1441:     HASH     H;                    /* Addr. of hashindex descr. w/ size info */
1442 1442:     struct   stHdisk *pstIdxHdr;   /* Ptr. to hashindex hdr record structure */
1443 1443:     eAnsType eIntegr;              /* Integrity statys : [YES | NO] */
1444 1444: {
1445 1445: /* DESCRIPTION
1446 1446:  *    Support function (common "Workhorse")
1447 1447:  *    Fills in a hashindex header structure (struct stHdisk) passed as param.
1448 1448:  *    Called from eHashIdxCreate() and eHashIdxClose().
1449 1449:  *
1450 1450:  *    1: Copies INDEXSIZE from the hashindex "in core" descriptor (param H).
1451 1451:  *    2: Calculates CHECKSUM from the fileheader's : struct stHsize.
1452 1452:  *    3: Sets the header integrity depending on the boolean parameter "eIntegr"
1453 1453:  *       -  NO : integrity is NOT guaranteed (for create and open in mode RW)
1454 1454:  *       - YES : integrity is guarenteed     (for open in mode RO)
1455 1455:  *-4*/
1456 1456: 

XC ... 'C' Concordance Utility   ss.c                       Page 27

1457 1457:     /* 1: Copy current hashindex size from index descriptor to header rec. */
1458 1458:     pstIdxHdr->indexsize = H->indexsize;
1459 1459: 
1460 1460:     /* 2: Set header checksum to calculated CRC for file's "struct stHsize" */
1461 1461:     pstIdxHdr->checksum = \
1462 1462: 	wCCITTcrc((char *) (&pstIdxHdr->indexsize), (WORD) sizeof(struct stHsize));
1463 1463: 
1464 1464:     /* 3: set header integrity depending on boolean parameter "eIntegr" */
1465 1465:     pstIdxHdr->integrity = (eIntegr == YES) ? INTEGRITY_OK : INTEGRITY_UNKNOWN;
1466 1466: 
1467 1467: }   /* END function vUpdate_stHdisk() */
1468 1468: 
1469 1469: 
1470 1470: 
1471 1471: 
1472 1472: /****************************************************************************/
1473 1473: /**************************** HASHINDEX KEYRECORDS **************************/
1474 1474: /****************************************************************************/
1475 1475: 
1476 1476: 
1477 1477: /*+2 MODULE HASH.C =========================================================*/
1478 1478: /*   NAME   12            eHashKeyInsert                                    */
1479 1479: /*== SYNOPSIS ==============================================================*/
1480 1480: PUBLIC    eRetType
1481 1481: eHashKeyInsert(pH, key, dwDatOffset)
1482 1482:     HASH     *pH;          /* Handle for hashindex descr. w/ indexfile */
1483 1483:     char     *key;         /* Key string, inserted in hashindex record */
1484 1484:     DWORD     dwDatOffset; /* DataFile offset ins. in hashindex record */
1485 1485: {
1486 1486: /* DESCRIPTION
1487 1487:  *    Insert a key and its corresponding datafile offset into a hashindex.
1488 1488:  *
1489 1489:  *    1: CHECK hashindex-file is open, and there is room for new key-record.
1490 1490:  *    2: FIND FREE SLOT in hashindex-file :
1491 1491:  *       2.1 Hash new key to initial position in hashindex-file.
1492 1492:  *       2.2: LOOP: compare new key to keyvalue of current slot in indexfile,-
1493 1493:  *               If collision (and not duplicate): rehash
1494 1494:  *            UNTIL free slot (ie. [VACANT | EMPTY]) located
1495 1495:  *    3: INSERT NEW KEY-RECORD in the free slot.
1496 1496:  *
1497 1497:  * RETURN
1498 1498:  *    OK if operation succeded, else ERROR (Astat holds precise error-code).
1499 1499:  *
1500 1500:  * BUGS
1501 1501:  *    Duplicate keys are NOT allowed (this is reasonable)
1502 1502:  *-2*/
1503 1503: 
1504 1504:     DWORD    *pdwIsize  = NULL;    /* Ptr. to size of index (# available records) */
1505 1505:     DWORD    *pdwIused  = NULL;    /* Ptr. to # indexrecords used right now */
1506 1506:     WORD     *pwKsize   = NULL;    /* Ptr. to size of key (# chars) */
1507 1507:     DWORD     dwCurSlot = 0L;      /* (Re)hashed slot in indexfile */
1508 1508:     struct stHkey stKeyRec;        /* File entry (key-record) */
1509 1509:     FLAG      fDupkey   = TRUE;    /* Boolean: Duplicate key? [Y|N] */
1510 1510:     FLAG      fAgain    = TRUE;    /* Boolean: Test & Rehash? [Y|N] */
1511 1511:     eRetType  eRetCode  = ERROR;   /* ReturnCode */
1512 1512: 

XC ... 'C' Concordance Utility   ss.c                       Page 28

1513 1513: 
1514 1514:     /*------ 1: CHECK open hashindex-file, and room for new key-record -----*/
1515 1515:     ARET_ERR((*pH)->indexstatus != IOPEN, A_NOTOPEN, 1201);
1516 1516: 
1517 1517:     pdwIsize = &(*pH)->indexsize.dwIsize;
1518 1518:     pdwIused = &(*pH)->indexsize.dwIused;
1519 1519:     pwKsize = &(*pH)->indexsize.wKsize;
1520 1520: 
1521 1521:     /* Check room for new record; - 1 slot reserved for search termination! */
1522 1522:     ARET_ERR(*pdwIused + 2 > *pdwIsize, A_FULL, 1202);
1523 1523: 
1524 1524: 
1525 1525:     /*----------------- 2: FIND FREE SLOT in hashindex-file ----------------*/
1526 1526: 
1527 1527:     /* 2.1 Hash new key to initial position in hashindex-file */
1528 1528:     dwCurSlot = dwHashFunc(key, *pwKsize, *pdwIsize);
1529 1529: 
1530 1530:     /* Allocate room for key read from hashindex-file (for comparing) */
1531 1531:     stKeyRec.key = (char *) malloc(*pwKsize);
1532 1532:     ARET_ERR(stKeyRec.key == NULL, A_BADALLOC, 1203);
1533 1533: 
1534 1534:     /* 2.2: LOOP: comp. key to current slot in indexfile UNTIL empty slot */
1535 1535:     while (fAgain) {
1536 1536: 
1537 1537: 	/* Read current key-record ("slot") in hashindex */
1538 1538: 	eRetCode = eReadIdxKey(*pH, dwCurSlot, &stKeyRec);
1539 1539: 	ARET_ERR(eRetCode == ERROR, A_READ, 1204);
1540 1540: 
1541 1541: 	/* Test if collision (and not duplicate);- if yes: rehash */
1542 1542: 	fDupkey = (strncmp(key, stKeyRec.key, *pwKsize) == 0);
1543 1543: 	if (stKeyRec.status == USED && !fDupkey)
1544 1544: 	    dwCurSlot = dwRehashFunc(key, *pwKsize, dwCurSlot, *pdwIsize);
1545 1545: 	else
1546 1546: 	    fAgain = FALSE;    /* Status VACANT or DELETED */
1547 1547:     }
1548 1548: 
1549 1549:     /* Free room for key read from hashindex-file (for comparing) */
1550 1550:     free(stKeyRec.key);
1551 1551: 
1552 1552: 
1553 1553:     /*---- 3: Free slot (VACANT|DELETED) located, INSERT NEW KEY-RECORD ----*/
1554 1554:     if (!fDupkey) {
1555 1555: 	stKeyRec.key = key;
1556 1556: 	stKeyRec.status = USED;
1557 1557: 	stKeyRec.dwDatOffset = dwDatOffset;
1558 1558: 
1559 1559: 	eRetCode = eWriteIdxKey(*pH, dwCurSlot, &stKeyRec);
1560 1560: 	ARET_ERR(eRetCode == ERROR, A_WRITE, 1205);
1561 1561: 	(*pdwIused)++;
1562 1562:     }
1563 1563:     else
1564 1564: 	ARET_ERR(TRUE, A_DUPLICATE, 1206);
1565 1565: 
1566 1566: 
1567 1567:     STCK("eHashKeyInsert");
1568 1568:     ARET_OK

XC ... 'C' Concordance Utility   ss.c                       Page 29

1569 1569: 
1570 1570: }   /* END function eHashKeyInsert() */
1571 1571: 
1572 1572: 
1573 1573: 
1574 1574: /*+2 MODULE HASH.C =========================================================*/
1575 1575: /*   NAME   13            eHashKeyDelete                                    */
1576 1576: /*== SYNOPSIS ==============================================================*/
1577 1577: PUBLIC    eRetType
1578 1578: eHashKeyDelete(pH, key)
1579 1579:     HASH     *pH;             /* Handle for hashindex descriptor */
1580 1580:     char     *key;            /* Keystring defining rec. in hashindex to delete */
1581 1581: {
1582 1582: /* DESCRIPTION
1583 1583:  *    Deletes a hashindex entry by marking it "DELETED"; -
1584 1584:  *
1585 1585:  *    NB: we can't simply mark the entry "VACANT" (for reuse), since  there
1586 1586:  *    may be items that have previously collided with the item to be deleted,
1587 1587:  *    and these items would then become unreachable via. rehash-chains!
1588 1588:  *
1589 1589:  * RETURN
1590 1590:  *    OK when item found and marked "DELETED",
1591 1591:  *    else ERROR (Astat holds precise error-code).
1592 1592:  *-2*/
1593 1593: 
1594 1594:     DWORD    dwDatOffset = 0L;     /* Var param, - NOT actually used here */
1595 1595:     DWORD    dwCurSlot   = 0L;     /* Slot in indexfile for current key-record */
1596 1596:     struct   stHkey stKeyRec;      /* Structure holding current key record */
1597 1597:     eRetType eRetCode    = ERROR;  /* ReturnCode */
1598 1598: 
1599 1599: 
1600 1600:     /* 1: Locate key-record in index-file */
1601 1601:     eRetCode = eLocateKey(*pH, key, &dwCurSlot, &dwDatOffset);
1602 1602: 
1603 1603:     /* 2: Mark key-record "DELETED" */
1604 1604:     if (eRetCode == OK) {
1605 1605: 	stKeyRec.status = DELETED;
1606 1606: 	eRetCode = eWriteIdxKey(*pH, dwCurSlot, &stKeyRec);
1607 1607: 	ARET_ERR(eRetCode == ERROR, Astat, 1301);
1608 1608: 	(*pH)->indexsize.dwIused--;
1609 1609:     }
1610 1610:     else
1611 1611: 	ARET_ERR(TRUE, A_NOTFOUND, 1302);
1612 1612: 
1613 1613:     STCK("eHashKeyDelete");
1614 1614:     ARET_OK
1615 1615: 
1616 1616: }   /* END function eHashKeyDelete() */
1617 1617: 
1618 1618: 
1619 1619: 
1620 1620: /*+2 MODULE HASH.C =========================================================*/
1621 1621: /*    NAME   14           eHashKeyFind                                      */
1622 1622: /*== SYNOPSIS ==============================================================*/
1623 1623: PUBLIC    eRetType
1624 1624: eHashKeyFind(pH, key, pdwDatOffset)

XC ... 'C' Concordance Utility   ss.c                       Page 30

1625 1625:     HASH     *pH;              /* Handle for hashindex descriptor */
1626 1626:     char     *key;             /* Keystring defining rec. in hashindex to find */
1627 1627:     DWORD    *pdwDatOffset;    /* Ptr to var. for returning datafile offset */
1628 1628: {
1629 1629: /* DESCRIPTION
1630 1630:  *    Find the datafile-offset associated with a given key-value
1631 1631:  *    by looking up the key-record in the indexfile
1632 1632:  *
1633 1633:  * RETURN
1634 1634:  *    OK when key is found, else ERROR (Astat holds precise error-code)
1635 1635:  *-2*/
1636 1636: 
1637 1637:     DWORD     dwKeySlot = 0L;       /* Var param, -NOT actually used here */
1638 1638: 
1639 1639:     return (eLocateKey(*pH, key, &dwKeySlot, pdwDatOffset));
1640 1640: 
1641 1641: }   /* END function eHashKeyFind() */
1642 1642: 
1643 1643: 
1644 1644: 
1645 1645: /*+3 MODULE HASH.C =========================================================*/
1646 1646: /*    NAME   15              eLocateKey                                     */
1647 1647: /*=== SYNOPSIS =============================================================*/
1648 1648: PRIVATE   eRetType
1649 1649: eLocateKey(H, key, pdwKeySlot, pdwDatOffset)
1650 1650:     HASH    H;             /* Hashindex descriptor */
1651 1651:     char    *key;          /* Keystring defining rec. in hashindex to locate */
1652 1652:     DWORD   *pdwKeySlot;   /* Ptr to var. for returning keyrecord slot */
1653 1653:     DWORD   *pdwDatOffset; /* Ptr to var. for returning datafile offset */
1654 1654: {
1655 1655: /* DESCRIPTION
1656 1656:  *    Locate a key-record in index H
1657 1657:  *
1658 1658:  *   [0: If DEBUG mode, define statistic variables for tuning and debugging]
1659 1659:  *    1: Get index- and key-size from "in core" hash descriptor
1660 1660:  *    2: Hash key to initial position in hashindex-file
1661 1661:  *    3: LOOP: compare key to keyvalue of current slot in indexfile, -
1662 1662:  *          If (DELETED) or (USED and different key), then rehash key
1663 1663:  *       UNTIL key found or VACANT entry (ie. key not in index!)
1664 1664:  *    4: Set up key-slot and datafile-offset in var-params.
1665 1665:  *   [5: If DEBUG mode, print statistics]
1666 1666:  *
1667 1667:  * RETURN
1668 1668:  *    Key found : OK w/ side-effects dwCurSlot & pdwDatOffset set,
1669 1669:  *    else ERROR (Astat holds precise error-code)
1670 1670:  *-3*/
1671 1671: 
1672 1672:     DWORD     dwCurSlot = 0L;      /* (Re)hashed slot in indexfile */
1673 1673:     DWORD     dwIsize   = 0L;      /* Size of index (total # key-records) */
1674 1674:     WORD      wKsize    = 0;       /* Size of keystring (# byte) */
1675 1675:     struct stHkey stKeyRec;        /* Structure for hashindex key-record */
1676 1676:     FLAG      fAgain    = TRUE;    /* Boolean: Test & Rehash? [Y|N] */
1677 1677:     int       iCompare  = 0;       /* Result of compare lookup-key w. index-key */
1678 1678:     eRetType  eRetCode  = ERROR;   /* Return code for HASH.C function */
1679 1679:     eRetType  eRetFound = ERROR;   /* Return code for eLocateKey: key found? */
1680 1680: 

XC ... 'C' Concordance Utility   ss.c                       Page 31

1681 1681: 
1682 1682:     /* 0: If debug-mode, define statistic variables for tuning & dbg */
1683 1683:     D(static int sum_lookup_all = 1;
1684 1684:     static int sum_probe_all = 1;
1685 1685:     static int sum_lookup_ok = 1;
1686 1686:     static int sum_probe_ok  = 1;
1687 1687:     int    probes = 0;
1688 1688:     );
1689 1689: 
1690 1690:     /* 1: Get index- and key-size from "in core" hash descriptor */
1691 1691:     ARET_ERR(H->indexstatus != IOPEN, A_NOTOPEN, 1501);
1692 1692:     dwIsize = H->indexsize.dwIsize;
1693 1693:     wKsize = H->indexsize.wKsize;
1694 1694: 
1695 1695:     /* 2: Hash key to initial position in hashindex-file */
1696 1696:     dwCurSlot = dwHashFunc(key, wKsize, dwIsize);
1697 1697: 
1698 1698:     /* allocate room for key read from hashindex-file */
1699 1699:     stKeyRec.key = (char *) malloc(wKsize);
1700 1700:     ARET_ERR(stKeyRec.key == NULL, A_BADALLOC, 1502);
1701 1701: 
1702 1702: 
1703 1703:     /* 3: LOOP Lookup key, - rehash if not found */
1704 1704:     while (fAgain) {
1705 1705: 
1706 1706: 	eRetCode = eReadIdxKey(H, dwCurSlot, &stKeyRec);
1707 1707: 	ARET_ERR(eRetCode == ERROR, Astat, 1503);
1708 1708: 	D(probes++);
1709 1709: 
1710 1710: 	switch (stKeyRec.status) {
1711 1711: 	    case VACANT:
1712 1712: 		fAgain = FALSE;
1713 1713: 		eRetFound = ERROR;
1714 1714: 		break;
1715 1715: 
1716 1716: 	    case USED:
1717 1717: 		iCompare = strncmp(key, stKeyRec.key, wKsize);
1718 1718: 		if (iCompare == 0) {	/* found */
1719 1719: 		    fAgain = FALSE;
1720 1720: 		    eRetFound = OK;
1721 1721: 		}
1722 1722: 		else
1723 1723: 		    dwCurSlot = dwRehashFunc(key, wKsize, dwCurSlot, dwIsize);
1724 1724: 		break;
1725 1725: 
1726 1726: 	    case DELETED:
1727 1727: 		dwCurSlot = dwRehashFunc(key, wKsize, dwCurSlot, dwIsize);
1728 1728: 		break;
1729 1729: 
1730 1730: 	    default:
1731 1731: 		ARET_ERR(TRUE, A_OTHER, 1504);
1732 1732: 	}
1733 1733:     }
1734 1734: 
1735 1735:     /* 4: Set up key-slot and datafile-offset in var-params. */
1736 1736:     *pdwKeySlot = dwCurSlot;   /* only valid when found is true */

XC ... 'C' Concordance Utility   ss.c                       Page 32

1737 1737:     *pdwDatOffset = stKeyRec.dwDatOffset;	/* ditto */
1738 1738: 
1739 1739:     free(stKeyRec.key);
1740 1740: 
1741 1741: 
1742 1742:     /* 5: If DEBUG mode: print statistics */
1743 1743: 	D(if (eRetFound == OK) {
1744 1744: 	sum_lookup_ok++;
1745 1745: 	sum_probe_ok += probes;
1746 1746: 	}
1747 1747:     sum_lookup_all++;
1748 1748:     sum_probe_all += probes;
1749 1749:     );
1750 1750: 
1751 1751:     D(fprintf(stdout, "SUM OK : lookup=[%d], probe=[%d], probe/lookup=[%.2f]\n", \
1752 1752: 	      sum_lookup_ok, sum_probe_ok, \
1753 1753: 	      ((float) sum_probe_ok) / ((float) sum_lookup_ok)));
1754 1754: 
1755 1755:     D(fprintf(stdout, "SUM ALL: lookup=[%d], probe=[%d], probe/lookup=[%.2f]\n", \
1756 1756: 	      sum_lookup_all, sum_probe_all, \
1757 1757: 	      ((float) sum_probe_all) / ((float) sum_lookup_all)));
1758 1758: 
1759 1759: 
1760 1760:     STCK("eLocateKey");
1761 1761:     Aid = 1505;
1762 1762:     Astat = (eRetFound == OK ? A_OK : A_NOTFOUND);
1763 1763:     return (eRetFound);
1764 1764: 
1765 1765: }   /* END function eLocateKey() */
1766 1766: 
1767 1767: 
1768 1768: 
1769 1769: 
1770 1770: /****************************************************************************/
1771 1771: /**************************** HASHINDEX REORGANIZE **************************/
1772 1772: /****************************************************************************/
1773 1773: 
1774 1774: 
1775 1775: /*+3 MODULE HASH.C =========================================================*/
1776 1776: /*   NAME   16               eHashIdxRestore                                */
1777 1777: /*== SYNOPSIS ==============================================================*/
1778 1778: PRIVATE   eRetType
1779 1779: eHashIdxRestore(pH)
1780 1780:     HASH     *pH;	       /* Handle for "in core" hashindex descr. */
1781 1781: {
1782 1782: /* DESCRIPTION
1783 1783:  *    Restore index-information of an "in core" hashindex descriptor
1784 1784:  *    by recalculating the total number of keyrecordes in the indexfile
1785 1785:  *    and counting the number of used records in the file.
1786 1786:  *
1787 1787:  *    1: Find the current size (#byte) of the hashindex file
1788 1788:  *    2: Compute the total # hashindex keyrecords from the filesize
1789 1789:  *    3: Scan the hashindex file and count all USED key-entries
1790 1790:  *    4: Update the hashindex "in core" structure with info from 1 & 3
1791 1791:  *
1792 1792:  * RETURN

XC ... 'C' Concordance Utility   ss.c                       Page 33

1793 1793:  *    OK if operation succeded, else ERROR (Astat holds precise error-code).
1794 1794:  *-3*/
1795 1795: 
1796 1796:     WORD      wKsize   = (*pH)->indexsize.wKsize; /* Keysize, - assumed OK! */
1797 1797:     DWORD     dwIsize  = 0L;       /* Hashindex size (# keyrecords) */
1798 1798:     DWORD     dwIused  = 0L;       /* Hashindex usage (# USED keyrecords) */
1799 1799:     register  DWORD dwCount = 0L;  /* Scratch count variable */
1800 1800:     FILE      *F = (*pH)->fd;      /* Handle of hashindex file */
1801 1801:     struct    stHkey stKeyRec;     /* Structure for hashindex key-record */
1802 1802:     long      filesize = 0L;       /* Size of hashindex file (# byte) */
1803 1803:     eRetType  eRetCode = ERROR;    /* Return code for HASH.C function */
1804 1804: 
1805 1805: 
1806 1806:     /* 1: Find hashindex filesize (#byte) */
1807 1807:     eRetCode = (fseek(F, 0L, SEEK_END) != 0 ? ERROR : OK);
1808 1808:     ARET_ERR(eRetCode == ERROR, A_SEEK, 1601);
1809 1809: 
1810 1810:     filesize = ftell(F);
1811 1811:     ARET_ERR(filesize == -1L, A_READ, 1602);
1812 1812: 
1813 1813: 
1814 1814:     /* 2: Compute hashindex keyrecords (TOTAL number); - wKsize assumed OK. */
1815 1815:     /* NB: the index is always created in full size by eHashIdxCreate() */
1816 1816:     dwIsize = (filesize - sizeof(struct stHdisk)) /
1817 1817: 	(sizeof(struct stHkey) - sizeof(char *) + wKsize);
1818 1818: 
1819 1819: 
1820 1820:     /* 3: Scan hashindex file and count USED key-entries */
1821 1821:     stKeyRec.key = (char *) malloc(wKsize);
1822 1822:     ARET_ERR(stKeyRec.key == NULL, A_BADALLOC, 1603);
1823 1823: 
1824 1824:     for (dwCount = 0L; dwCount < dwIsize; dwCount++) {
1825 1825: 	eRetCode = eReadIdxKey(*pH, dwCount, &stKeyRec);
1826 1826: 	ARET_ERR(eRetCode == ERROR, Astat, 1604);
1827 1827: 
1828 1828: 	if (stKeyRec.status == USED)
1829 1829: 	    dwIused++;
1830 1830:     }
1831 1831: 
1832 1832:     free(stKeyRec.key);
1833 1833: 
1834 1834: 
1835 1835:     /* 4: Restore (update) hashindex index-info structure */
1836 1836:     (*pH)->indexsize.dwIsize = dwIsize;
1837 1837:     (*pH)->indexsize.dwIused = dwIused;
1838 1838: 
1839 1839:     STCK("eHashIdxRestore");
1840 1840:     ARET_OK
1841 1841: 
1842 1842: }   /* END function eHashIdxRestore() */
1843 1843: 
1844 1844: 
1845 1845: 
1846 1846: /* Temporary (scratch) HASH handle used by eHashIdxResize() & wCopy2New() */
1847 1847: static HASH Temp_hash;
1848 1848: 

XC ... 'C' Concordance Utility   ss.c                       Page 34

1849 1849: 
1850 1850: /*+2 MODULE HASH.C =========================================================*/
1851 1851: /*   NAME   17            eHashIdxResize                                    */
1852 1852: /*== SYNOPSIS ==============================================================*/
1853 1853: PUBLIC    eRetType
1854 1854: eHashIdxResize(pH, iResize)
1855 1855:     HASH     *pH;          /* Handle for "in core" hashindex descr. */
1856 1856:     int       iResize;     /* Factor for resizing the hashindex */
1857 1857: {
1858 1858: /* DESCRIPTION
1859 1859:  *    Resize a hashindex file, - Must be called when index is nearly full.
1860 1860:  *    iRezize is the percentage the index will be resized by, ie :
1861 1861:  *    iResize>100 : expansion of index, and iResize<100 : shrinking of index.
1862 1862:  *
1863 1863:  *    When eHashIdxGetLoad sets Astat to A_XPAND, is it recommended to call
1864 1864:  *    this function with a resize factor ("iResize") of 200, thus doubling
1865 1865:  *    the index file to keep performance high.
1866 1866:  *    The index can NOT be shrinked to less than it's actual size of used
1867 1867:  *    keyrecords, - when trying to do so, you will get an unchanged index.
1868 1868:  *
1869 1869:  *    PREPARE OLD
1870 1870:  *       1.1: Check old hashindex file is open and RW
1871 1871:  *       1.2: Save name of old hashindex file (from index descriptor)
1872 1872:  *    PREPARE NEW
1873 1873:  *       2.1: Set temporary name for new hashindex file
1874 1874:  *       2.2: Calculate new (prime) size of hashindex file
1875 1875:  *       2.3: Create & open new hashindex file (as temporary file)
1876 1876:  *    COPY OLD -> NEW
1877 1877:  *       3: Copy all key-records from old to new hashindex file
1878 1878:  *    CLEAN UP
1879 1879:  *       4.1: Close old and new hashindex descriptors & files
1880 1880:  *       4.2: Remove old file, rename new to old, and open new file as old
1881 1881:  *
1882 1882:  * RETURN
1883 1883:  *    OK if operation succeded, else ERROR (Astat holds precise error-code).
1884 1884:  *-2*/
1885 1885: 
1886 1886:     DWORD     dwIsize = (*pH)->indexsize.dwIsize;    /* # keyrecords) */
1887 1887:     DWORD     dwIused = (*pH)->indexsize.dwIused;    /* # USED keyrecords) */
1888 1888:     WORD      wKsize  = (*pH)->indexsize.wKsize;     /* # byte in keystring */
1889 1889:     DWORD     dwNewsize = 0L;      /* New size of index - after resizing */
1890 1890:     char     *pzOldFile = NULL;    /* Name of current indexfile */
1891 1891:     char     *pzNewFile = NULL;    /* Name of new (resized) indexfile */
1892 1892:     eRetType  eRetCode = ERROR;    /* Return code for HASH.C function */
1893 1893:     int       iRes = 0;	           /* Resultcode for file operation */
1894 1894: 
1895 1895: 
1896 1896:     /* 1.1: Check old hashindex file is open and RW */
1897 1897:     ARET_ERR((*pH)->indexstatus != IOPEN, A_NOTOPEN, 1701);
1898 1898:     ARET_ERR((*pH)->indexmode != RW, A_OTHER, 1702);
1899 1899: 
1900 1900:     /* 1.2: Save name of old hashindex file (from index descriptor) */
1901 1901:     pzOldFile = malloc(strlen((*pH)->filename) + 1);
1902 1902:     ARET_ERR(!pzOldFile, A_BADALLOC, 1703);
1903 1903:     (void) strcpy(pzOldFile, (*pH)->filename);
1904 1904: 

XC ... 'C' Concordance Utility   ss.c                       Page 35

1905 1905: 
1906 1906:     /* 2.1: Set temporary name for new hashindex file */
1907 1907:     pzNewFile = "HASH_TMP";
1908 1908:     (void) remove(pzNewFile);  /* just in case ... */
1909 1909: 
1910 1910:     /* 2.2: Calculate new (prime) size of hashindex file */
1911 1911:     dwNewsize = dwIsize * iResize / 100;
1912 1912:     if (dwNewsize < dwIused)
1913 1913: 	dwNewsize = dwIused;
1914 1914:     vGetPrime(&dwNewsize, TRUE);
1915 1915: 
1916 1916:     /* 2.3: Create & open new hashindex file (as temporary file) */
1917 1917:     eRetCode = eHashIdxCreate(&Temp_hash, pzNewFile, wKsize, dwNewsize);
1918 1918:     ARET_ERR(eRetCode == ERROR, Astat, 1704);
1919 1919: 
1920 1920: 
1921 1921:     /* 3: Copy all key-records from old to new hashindex file */
1922 1922:     eRetCode = eHashIdxProcess(pH, wCopy2New);
1923 1923:     ARET_ERR(eRetCode == ERROR, Astat, 1705);
1924 1924: 
1925 1925: 
1926 1926:     /* 4.1: Close old and new hashindex descriptors & files */
1927 1927:     eRetCode = eHashIdxClose(pH);
1928 1928:     ARET_ERR(eRetCode == ERROR, Astat, 1706);
1929 1929: 
1930 1930:     eRetCode = eHashIdxClose(&Temp_hash);
1931 1931:     ARET_ERR(eRetCode == ERROR, Astat, 1707);
1932 1932: 
1933 1933: 
1934 1934:     /* 4.2: Remove old file, rename new to old, and open new file as old */
1935 1935:     iRes = remove(pzOldFile);
1936 1936:     ARET_ERR(iRes != 0, A_NOTCREATE, 1708);
1937 1937: 
1938 1938:     iRes = rename(pzNewFile, pzOldFile);
1939 1939:     ARET_ERR(iRes != 0, A_NOTCREATE, 1709);
1940 1940: 
1941 1941:     eRetCode = eHashIdxOpen(pH, pzOldFile, "r+b");
1942 1942:     ARET_ERR(eRetCode == ERROR, Astat, 1710);
1943 1943: 
1944 1944:     free(pzOldFile);
1945 1945: 
1946 1946: 
1947 1947:     STCK("eHashIdxResize");
1948 1948:     ARET_OK
1949 1949: 
1950 1950: }   /* END function eHashIdxResize() */
1951 1951: 
1952 1952: 
1953 1953: 
1954 1954: /*+4 MODULE HASH.C ---------------------------------------------------------*/
1955 1955: /*   NAME   18               wCopy2New                                   */
1956 1956: /*-- SYNOPSIS --------------------------------------------------------------*/
1957 1957: PRIVATE   WORD
1958 1958: wCopy2New(key, dwDatOffset)
1959 1959:     char     *key;
1960 1960:     DWORD     dwDatOffset;

XC ... 'C' Concordance Utility   ss.c                       Page 36

1961 1961: {
1962 1962: /* DESCRIPTION
1963 1963:  *    This function is passed as parameter to function "eHashIdxProcess"
1964 1964:  *    called by eHashIdxResize to regenerate a hash indexfile.
1965 1965:  *-4*/
1966 1966:     eRetType  eRetCode = ERROR;
1967 1967: 
1968 1968:     eRetCode = eHashKeyInsert(&Temp_hash, key, dwDatOffset);
1969 1969: 
1970 1970:     return (eRetCode != ERROR ? 1 : 0);	/* 1 means continue */
1971 1971: 
1972 1972: }   /* END function wCopy2New() */
1973 1973: 
1974 1974: 
1975 1975: 
1976 1976: 
1977 1977: /****************************************************************************/
1978 1978: /**************************** STATISTICS & TRAVERSAL ************************/
1979 1979: /****************************************************************************/
1980 1980: 
1981 1981: 
1982 1982: /*+2 MODULE HASH.C =========================================================*/
1983 1983: /*   NAME   19               eHashIdxGetSize                                    */
1984 1984: /*== SYNOPSIS ==============================================================*/
1985 1985: PUBLIC    eRetType
1986 1986: eHashIdxGetSize(pH, pdwSize, pdwUsed)
1987 1987:     HASH     *pH;          /* Handle for "in core" hashindex descr. */
1988 1988:     DWORD    *pdwSize;     /* Ptr. to var for returning total # records */
1989 1989:     DWORD    *pdwUsed;     /* Ptr. to var for returning used # records */
1990 1990: {
1991 1991: /* DESCRIPTION
1992 1992:  *    Extracts the size of the hashindex (# records, total & used)
1993 1993:  *    from the hashindex descriptor to the var. parameters.
1994 1994:  * RETURN
1995 1995:  *    OK if operation succeded, else ERROR (Astat holds precise error-code).
1996 1996:  *-2*/
1997 1997: 
1998 1998:     ARET_ERR((*pH)->indexstatus != IOPEN, A_NOTOPEN, 1901);
1999 1999: 
2000 2000:     *pdwSize = (*pH)->indexsize.dwIsize;
2001 2001:     *pdwUsed = (*pH)->indexsize.dwIused;
2002 2002: 
2003 2003:     STCK("eHashIdxGetSize");
2004 2004:     ARET_OK
2005 2005: 
2006 2006: }   /* END function eHashIdxGetSize() */
2007 2007: 
2008 2008: 
2009 2009: 
2010 2010: /*+2 MODULE HASH.C =========================================================*/
2011 2011: /*   NAME   20               eHashIdxGetLoad                                */
2012 2012: /*== SYNOPSIS ==============================================================*/
2013 2013: PUBLIC eRetType
2014 2014: eHashIdxGetLoad(pH, pwLoad)
2015 2015:     HASH     *pH;          /* Handle for "in core" hashindex descr. */
2016 2016:     WORD     *pwLoad;      /* Ptr. to var for returning index load factor */

XC ... 'C' Concordance Utility   ss.c                       Page 37

2017 2017: {
2018 2018: /* DESCRIPTION
2019 2019:  *    Calculates the load percentage (ie: 100 * used/total) for index H.
2020 2020:  *    When the load factor exceeds 80%, Astat is set to A_XPAND to indicate
2021 2021:  *    that expansion of the index is recommened.
2022 2022:  *
2023 2023:  * RETURN
2024 2024:  *    returns OK  when loadfactor < 80%,
2025 2025:  *    else ERROR (Astat holds precise error-code).
2026 2026:  *-2*/
2027 2027: 
2028 2028:     /* Check index is open */
2029 2029:     ARET_ERR( (*pH)->indexstatus != IOPEN,	A_NOTOPEN, 2001);
2030 2030: 
2031 2031: 
2032 2032:     /* Calculate loadfactor, and return A_XPAND if >= 80% */
2033 2033:     *pwLoad = (WORD) (100 * (*pH)->indexsize.dwIused / ((*pH)->indexsize.dwIsize - 1));
2034 2034:     ARET_ERR( *pwLoad >= 80, A_XPAND, 2002);
2035 2035: 
2036 2036: 
2037 2037:     STCK("eHashIdxGetLoad");
2038 2038:     ARET_OK
2039 2039: 
2040 2040: }   /* END function eHashIdxGetLoad() */
2041 2041: 
2042 2042: 
2043 2043: 
2044 2044: /*+2 MODULE HASH.C =========================================================*/
2045 2045: /*   NAME   21               eHashIdxProcess                               */
2046 2046: /*== SYNOPSIS ==============================================================*/
2047 2047: PUBLIC    eRetType
2048 2048: eHashIdxProcess(pH, ufunc)
2049 2049:     HASH   *pH;                            /* Handle for "in core" H.descr. */ 
2050 2050:     WORD   (*ufunc) P((char *, DWORD));    /* Ptr to function */
2051 2051: {
2052 2052: /* DESCRIPTION
2053 2053:  *    This function is called to process all the key-records in a hashindex.
2054 2054:  *    The function passed as parameter ('ufunc') is called once for each record,
2055 2055:  *    with the keystring and dwDatOffset extracted from the record as parameters.
2056 2056:  *    eHashIdxProcess expects the user-function 'ufunc' to return a value:
2057 2057:  *       0.   if processing must stop
2058 2058:  *       1.   to continue processsing
2059 2059:  *    Normally (1) is returned every time, which means that the processing
2060 2060:  *    will proceed until all records have been processed.
2061 2061:  *
2062 2062:  *    1: Check hashindex is open
2063 2063:  *    2: LOOP: Read next keyrecord from indexfile
2064 2064:  *             call ufunc(keystring, datafileoffset)
2065 2065:  *       UNTIL all records (dwIsize) processed OR break (again = 0)
2066 2066:  *
2067 2067:  * RETURN
2068 2068:  *    OK if all records processed, else ERROR with Astat=A_MOREDATA
2069 2069:  *-2*/
2070 2070: 
2071 2071:     WORD      wKsize  = (*pH)->indexsize.wKsize;    /* Size of keystring */
2072 2072:     struct    stHkey stKeyRec;     /* Structure for hashindex key-record */

XC ... 'C' Concordance Utility   ss.c                       Page 38

2073 2073:     register  DWORD dwCount = 0L;  /* Scratch count variable */
2074 2074:     WORD      wAgain        = 0;   /* Returncode for user-function 'ufunc' */
2075 2075:     eRetType  eRetCode  = ERROR;   /* Return code for HASH.C function */
2076 2076: 
2077 2077: 
2078 2078:     /* 1: Check hashindex is open */
2079 2079:     ARET_ERR((*pH)->indexstatus != IOPEN, A_NOTOPEN, 2101);
2080 2080: 
2081 2081:     /* 2: LOOP: Read next keyrecord, and call ufunc(keystring, datafileoffset) */
2082 2082:     stKeyRec.key = (char *) malloc(wKsize);
2083 2083:     ARET_ERR(stKeyRec.key == NULL, A_BADALLOC, 2102);
2084 2084: 
2085 2085:     for (dwCount = 0L; dwCount < (*pH)->indexsize.dwIsize; dwCount++) {
2086 2086: 
2087 2087: 	eRetCode = eReadIdxKey(*pH, dwCount, &stKeyRec);
2088 2088: 	ARET_ERR(eRetCode == ERROR, Astat, 2103);
2089 2089: 
2090 2090: 	if (stKeyRec.status == USED) {
2091 2091: 	    wAgain = (*ufunc) (stKeyRec.key, stKeyRec.dwDatOffset);
2092 2092: 	    if (!wAgain)
2093 2093: 		break;
2094 2094: 	}
2095 2095:     }
2096 2096: 
2097 2097:     free(stKeyRec.key);
2098 2098: 
2099 2099:     /* 3: Ret OK if all records processed, else ERROR with Astat=A_MOREDATA */
2100 2100:     if (!wAgain) {
2101 2101: 	Astat = A_MOREDATA;
2102 2102: 	return (ERROR);
2103 2103:     }
2104 2104: 
2105 2105:     STCK("eHashIdxProcess");
2106 2106:     ARET_OK
2107 2107: 
2108 2108: }   /* END function eHashIdxProcess() */
2109 2109: 
2110 2110: 
2111 2111: 
2112 2112: /****************************************************************************/
2113 2113: /**************************** LOW LEVEL HASHFILE I/O ************************/
2114 2114: /****************************************************************************/
2115 2115: 
2116 2116: 
2117 2117: /*+3 MODULE HASH.C =========================================================*/
2118 2118: /*   NAME   22               eWriteIdxHdr                                   */
2119 2119: /*== SYNOPSIS ==============================================================*/
2120 2120: PRIVATE   eRetType
2121 2121: eWriteIdxHdr(H, pstHdrRec)
2122 2122:     HASH      H;	       /* Hash index "in core" descriptor structure */
2123 2123:     struct stHdisk *pstHdrRec; /* Structure holding headerrecord to write */
2124 2124: {
2125 2125: /* DESCRIPTION
2126 2126:  *    Write (immediate) index header-record (stHdisk) to hash index H :
2127 2127:  *    0: Check index open-mode = ReadOnly
2128 2128:  *    1: Set filepointer on header-record (offset 0)

XC ... 'C' Concordance Utility   ss.c                       Page 39

2129 2129:  *    2: Write header-record from struct stHdisk to indexfile H->fd
2130 2130:  * RETURN
2131 2131:  *    OK if operation succeded, else ERROR (Astat holds precise error-code).
2132 2132:  *-3*/
2133 2133:     int       iRetCode = 0;     /* Return code for file operation */
2134 2134: 
2135 2135:     /* 0: Check index open-mode = ReadOnly */
2136 2136:     ARET_ERR(H->indexmode == RO, A_READONLY, 2201);
2137 2137: 
2138 2138:     /* 1: Set filepointer on header-record (offset 0) */
2139 2139:     (void) fseek(H->fd, 0, SEEK_SET);
2140 2140: 
2141 2141:     /* 2: Write header-record from struct stHdisk to indexfile H->fd */
2142 2142:     iRetCode = fwrite(pstHdrRec, sizeof(struct stHdisk), 1, H->fd);
2143 2143:     ARET_ERR(iRetCode == 0, A_WRITE, 2202);
2144 2144: 
2145 2145:     iRetCode = fflush(H->fd);
2146 2146:     ARET_ERR(iRetCode == EOF, A_WRITE, 2203);
2147 2147: 
2148 2148: 
2149 2149:     STCK("eWriteIdxHdr");
2150 2150:     ARET_OK
2151 2151: 
2152 2152: }   /* END function eWriteIdxHdr() */
2153 2153: 
2154 2154: 
2155 2155: 
2156 2156: /*+3 MODULE HASH.C =========================================================*/
2157 2157: /*   NAME   23               eReadIdxHdr                                    */
2158 2158: /*== SYNOPSIS ==============================================================*/
2159 2159: PRIVATE   eRetType
2160 2160: eReadIdxHdr(H, pstHdrRec)
2161 2161:     HASH      H;               /* Hash index "in core" descriptor structure */
2162 2162:     struct stHdisk *pstHdrRec; /* Structure holding headerrecord to write */
2163 2163: {
2164 2164: /* DESCRIPTION
2165 2165:  *    Read index header-record (stHdisk) from hash index H
2166 2166:  *    1: Set filepointer on header-record (offset 0)
2167 2167:  *    2: Read header-record from indexfile H->fd to struct stHdisk
2168 2168:  * RETURN
2169 2169:  *    OK if operation succeded, else ERROR (Astat holds precise error-code).
2170 2170:  *-3*/
2171 2171:     int       iRetCode = 0;    /* Return code for file operation */
2172 2172: 
2173 2173:     /* 1: Set filepointer on header-record (offset 0) */
2174 2174:     (void) fseek(H->fd, 0, SEEK_SET);
2175 2175: 
2176 2176:     /* 2: Read header-record from indexfile H->fd to struct stHdisk */
2177 2177:     iRetCode = fread(pstHdrRec, sizeof(struct stHdisk), 1, H->fd);
2178 2178:     ARET_ERR(iRetCode == 0, A_READ, 2301);
2179 2179: 
2180 2180: 
2181 2181:     STCK("eReadIdxHdr");
2182 2182:     ARET_OK
2183 2183: 
2184 2184: }   /* END function eReadIdxHdr() */

XC ... 'C' Concordance Utility   ss.c                       Page 40

2185 2185: 
2186 2186: 
2187 2187: 
2188 2188: /*+3 MODULE HASH.C =========================================================*/
2189 2189: /*   NAME   24               eWriteIdxKey                                   */
2190 2190: /*== SYNOPSIS ==============================================================*/
2191 2191: PRIVATE   eRetType
2192 2192: eWriteIdxKey(H, dwSlot, pstKeyRec)
2193 2193:     HASH      H;               /* Hash index "in core" descriptor structure */
2194 2194:     DWORD     dwSlot;          /* Slot in hash indexfile for keyrecord write */
2195 2195:     struct stHkey *pstKeyRec;  /* Structure holding keyrecord to write */
2196 2196: {
2197 2197: /* DESCRIPTION
2198 2198:  *    Write a key-record (stHkey) to hash index H, slot dwSlot :
2199 2199:  *    0: Check index open-mode = ReadOnly
2200 2200:  *    1: Set filepointer on key-record according to "dwOffset"
2201 2201:  *    2: Write record-status, key-string & datafile-offset
2202 2202:  *       from struct stHkey to indexfile H->fd (keyrecord dwSlot)
2203 2203:  * RETURN
2204 2204:  *    OK if operation succeded, else ERROR (Astat holds precise error-code).
2205 2205:  *-3*/
2206 2206:     WORD      wKsiz    = H->indexsize.wKsize;          /* Size of keystring */
2207 2207:     DWORD     dwOffset = FILE_OFFSET(dwSlot, wKsiz);   /* Datafile offset   */
2208 2208:     int       iRetCode = 0;               /* Return code for file operation */
2209 2209: 
2210 2210: 
2211 2211:     /* 0: Check index open-mode = ReadOnly */
2212 2212:     ARET_ERR((H->indexmode == RO), A_READONLY, 2401);
2213 2213: 
2214 2214: 
2215 2215:     /* 1: Set filepointer on key-record according to "dwOffset" */
2216 2216:     iRetCode = fseek(H->fd, dwOffset, SEEK_SET);
2217 2217:     ARET_ERR(iRetCode, A_SEEK, 2402);
2218 2218: 
2219 2219: 
2220 2220:     /* 2: Write record-status, key-string & datafile-offset */
2221 2221:     /* from struct stHkey to indexfile H->fd (keyrecord dwSlot) */
2222 2222:     iRetCode = fwrite(&pstKeyRec->status, sizeof(pstKeyRec->status), 1, H->fd);
2223 2223:     ARET_ERR(iRetCode == 0, A_WRITE, 2403);
2224 2224: 
2225 2225:     iRetCode = fwrite(pstKeyRec->key, wKsiz, 1, H->fd);
2226 2226:     ARET_ERR(iRetCode == 0, A_WRITE, 2404);
2227 2227: 
2228 2228:     iRetCode = fwrite(&pstKeyRec->dwDatOffset, sizeof(pstKeyRec->dwDatOffset), 1, H->fd);
2229 2229:     ARET_ERR(iRetCode == 0, A_WRITE, 2405);
2230 2230: 
2231 2231: 
2232 2232:     STCK("eWriteIdxKey");
2233 2233:     ARET_OK
2234 2234: 
2235 2235: }   /* END function eWriteIdxKey() */
2236 2236: 
2237 2237: 
2238 2238: 
2239 2239: /*+3 MODULE HASH.C =========================================================*/
2240 2240: /*   NAME   25               eReadIdxKey                                    */

XC ... 'C' Concordance Utility   ss.c                       Page 41

2241 2241: /*== SYNOPSIS ==============================================================*/
2242 2242: PRIVATE   eRetType
2243 2243: eReadIdxKey(H, dwSlot, pstKeyRec)
2244 2244:     HASH      H;               /* Hash index "in core" descriptor structure */
2245 2245:     DWORD     dwSlot;          /* Slot in hash indexfile for keyrecord read */
2246 2246:     struct stHkey *pstKeyRec;  /* Structure for reading keyrecord into */
2247 2247: {
2248 2248: /* DESCRIPTION
2249 2249:  *    Read a key-record (stHkey) from hash index H, slot dwSlot.
2250 2250:  *    1: Set filepointer on key-record according to "dwOffset"
2251 2251:  *    2: Read record-status, key-string & datafile-offset
2252 2252:  *       from indexfile H->fd (keyrecord dwSlot) to struct stHkey
2253 2253:  * RETURN
2254 2254:  *    OK if operation succeded, else ERROR (Astat holds precise error-code).
2255 2255:  *-3*/
2256 2256: 
2257 2257:     WORD      wKsiz    = H->indexsize.wKsize;          /* Size of keystring */
2258 2258:     DWORD     dwOffset = FILE_OFFSET(dwSlot, wKsiz);   /* Datafile offset   */
2259 2259:     int       iRetCode = 0;               /* Return code for file operation */
2260 2260: 
2261 2261:     D(fprintf(stdout, "\t\t\tHashfileKeyOffset[%lo]\n", dwOffset));
2262 2262: 
2263 2263:     /* 1: Set filepointer on key-record according to "dwOffset" */
2264 2264:     iRetCode = fseek(H->fd, dwOffset, SEEK_SET);
2265 2265:     ARET_ERR(iRetCode, A_SEEK, 2501);
2266 2266: 
2267 2267: 
2268 2268:     /* 2: Read record-status, key-string & datafile-offset */
2269 2269:     /* from indexfile H->fd (keyrecord dwSlot) to struct stHkey */
2270 2270:     iRetCode = fread(&pstKeyRec->status, sizeof(pstKeyRec->status), 1, H->fd);
2271 2271:     ARET_ERR(iRetCode == 0, A_READ, 2502);
2272 2272: 
2273 2273:     iRetCode = fread(pstKeyRec->key, (int) wKsiz, 1, H->fd);
2274 2274:     ARET_ERR(iRetCode == 0, A_READ, 2503)
2275 2275: 	iRetCode = fread(&pstKeyRec->dwDatOffset, sizeof(pstKeyRec->dwDatOffset), 1, H->fd);
2276 2276:     ARET_ERR(iRetCode == 0, A_READ, 2504);
2277 2277: 
2278 2278: 
2279 2279:     STCK("eReadIdxKey");
2280 2280:     ARET_OK
2281 2281: 
2282 2282: }   /* END function eReadIdxKey() */
2283 2283: 
2284 2284: 
2285 2285: 
2286 2286: /****************************************************************************/
2287 2287: /********************************** UTILITY *********************************/
2288 2288: /****************************************************************************/
2289 2289: 
2290 2290: /* Global "dwSeed" value for random number calculator */
2291 2291: static DWORD dwSeed = 53600520L;  /* Default initialization, any number will do */
2292 2292: 
2293 2293: 
2294 2294: 
2295 2295: /*+4 MODULE HASH.C ---------------------------------------------------------*/
2296 2296: /*   NAME   26               vGetPrime                                      */

XC ... 'C' Concordance Utility   ss.c                       Page 42

2297 2297: /*-- SYNOPSIS --------------------------------------------------------------*/
2298 2298: PRIVATE void
2299 2299: vGetPrime(pdwPrime, iUpward)
2300 2300:     DWORD    *pdwPrime;    /* Initial & final value for prime search */
2301 2301:     int       iUpward;     /* Search direction: TRUE=up, FALSE=down */
2302 2302: {
2303 2303: /* DESCRIPTION
2304 2304:  *    Search for nearest prime number; Parameter "*pdwPrime" is the initial value,
2305 2305:  *    and parameter "iUpward" is used to specify the search direction :
2306 2306:  *       if iUpward==TRUE we scan "up" (higher numbers), else we scan "down".
2307 2307:  *    The function calls fIsPrime() to perform a probabilistic primality test.
2308 2308:  * RETURN
2309 2309:  *    The first prime number found (starting from *pdwPrime) is returned in *pdwPrime.
2310 2310:  *-4*/
2311 2311: 
2312 2312:     D(static char m0[] =   "%10ld\b\b\b\b\b\b\b\b\b\b";)
2313 2313:     D(static char m1[] =   "%10ld prime!\n";)
2314 2314:     FLAG fGotPrime     =   FALSE;
2315 2315: 
2316 2316: 
2317 2317:     /* 1: Get initial (ODD) number to start downward search for prime */
2318 2318:     /* & initialize random seed, used by rRandom() called from fIsPrime() */
2319 2319:     if (ISEVEN(*pdwPrime))
2320 2320: 	*pdwPrime += (iUpward ? 1 : -1);
2321 2321:     dwSeed = 571925350L + *pdwPrime;    /* any random number will do */
2322 2322: 
2323 2323:     /* 2: Test initial number, - and successively smaller/greater (odd) numbers */
2324 2324:     do {
2325 2325: 	/* Test *pdwPrime for primality */
2326 2326: 	fGotPrime = fIsPrime(*pdwPrime);
2327 2327: 
2328 2328: 	/* If not prime, proceed with next odd number > *pdwPrime or < *pdwPrime */
2329 2329: 	if (!fGotPrime)
2330 2330: 	    *pdwPrime += (iUpward ? 2 : -2);
2331 2331: 
2332 2332: 	/* Report progress on stdout */
2333 2333: 	D(fprintf(stdout, (!fGotPrime ? m0 : m1), *pdwPrime));
2334 2334: 
2335 2335:     } while (!fGotPrime);
2336 2336: 
2337 2337: }   /* END function vGetPrime() */
2338 2338: 
2339 2339: 
2340 2340: 
2341 2341: /*+4 MODULE HASH.C ---------------------------------------------------------*/
2342 2342: /*   NAME   27               fIsPrime                                       */
2343 2343: /*-- SYNOPSIS --------------------------------------------------------------*/
2344 2344: PRIVATE   FLAG
2345 2345: fIsPrime(n)
2346 2346:     DWORD n;
2347 2347: {
2348 2348: /* DESCRIPTION
2349 2349:  *    Probabilistic test of "primality" : is number n prime ? (Y/N)
2350 2350:  *    References : Knuth [1980]
2351 2351:  *
2352 2352:  *                      Pierre de Fermat's theorem (1643) :

XC ... 'C' Concordance Utility   ss.c                       Page 43

2353 2353:  *    Given an odd number : n = 1 + 2**k * q,   where q is odd
2354 2354:  *    If n is NOT prime, it is always possible to find a value : 1 < x < n
2355 2355:  *    such that :     x ** (n-1) mod n != 1
2356 2356:  *    If n IS prime, then the following expression :
2357 2357:  *                    x ** (n-1) mod n,   where	1 < x < n
2358 2358:  *    will yield 1 with probability p >= 3/4.
2359 2359:  *
2360 2360:  *                      Knuth's probabilistic primality test.
2361 2361:  *    The expression: x ** (n-1) mod n,   where	1 < x < n
2362 2362:  *                =   x ** ((2**k) * q) mod n
2363 2363:  *    can be calculated in  O(log n)  steps :
2364 2364:  *                    x ** ((2**j) * q) mod n,    where   j = 0,1, ... n-1
2365 2365:  *    If this procedure is repeated t times, and every time yields 1 as result,
2366 2366:  *    then n can be concluded to be prime with probability p = (1/4) ** t.
2367 2367:  *    For t=25 we have p = (1/4) ** 25 < 1E-15 ( which is less probable than a
2368 2368:  *    hardware failure ! ).
2369 2369:  *
2370 2370:  * RETURN
2371 2371:  *    TRUE if n is prime, FALSE otherwise.
2372 2372:  *-4*/
2373 2373:     DWORD     p = 0L;
2374 2374:     double    x = 0L;
2375 2375:     double    y = 0L;
2376 2376:     WORD      wCount = 0;      /* scratch count variable */
2377 2377:     WORD      wTests = 25;     /* # times to perform primality test */
2378 2378: 
2379 2379: 
2380 2380:     for (wCount = 1; wCount < wTests; wCount++) {
2381 2381: 	x = 2 + (unsigned long) ((float) (n - 2) * (float) rRandom());
2382 2382: 	y = 1;
2383 2383: 	p = n - 1;
2384 2384: 
2385 2385: 	do {
2386 2386: 	    if (!ISEVEN(p))    /* if p is even : skip 	 */
2387 2387: 		y = fmod((y * x), (double) n);
2388 2388: 
2389 2389: 	    x = fmod((x * x), (double) n);	/* x =  (x ** 2) % n */
2390 2390: 
2391 2391: 	    p = p / 2;
2392 2392: 
2393 2393: 	} while (p > (DWORD)0L);
2394 2394: 
2395 2395: 	if (y != 1)	       /* OOPS : definitely NOT prime! */
2396 2396: 	    break;
2397 2397:     }
2398 2398: 
2399 2399:     return (y == 1 ? TRUE : FALSE);
2400 2400: 
2401 2401: }   /* END function fIsPrime() */
2402 2402: 
2403 2403: 
2404 2404: 
2405 2405: /*+4 MODULE HASH.C ---------------------------------------------------------*/
2406 2406: /*   NAME   28               rRandom                                        */
2407 2407: /*-- SYNOPSIS --------------------------------------------------------------*/
2408 2408: /*+0 Define the "magic numbers" for PMMLCG random number generator */

XC ... 'C' Concordance Utility   ss.c                       Page 44

2409 2409: PRIVATE DWORD a = 16807;       /* multiplier : a long [2...m-1] */
2410 2410: PRIVATE DWORD m = 2147483647;  /* modulus .. : a large prime */
2411 2411: PRIVATE DWORD q = 127773;      /* quotient . : (m div a) */
2412 2412: PRIVATE DWORD r = 2836;        /* rest ..... : (m mod a) */
2413 2413: 
2414 2414: /*-0*/
2415 2415: PRIVATE double
2416 2416: rRandom(VOID)
2417 2417: {			
2418 2418: /* DESCRIPTION
2419 2419:  *    Prime Modulus Multiplicative Linear Congruential Generator (PMMLCG),
2420 2420:  *    using Lehmers algorithm implemented by Schrage's method.
2421 2421:  *    References : Knuth [1980], Park et.al. [1988]
2422 2422:  *
2423 2423:  *                      D. H. Lehmer's algorithm.
2424 2424:  *    The generating function :   f(X) = a*X mod m
2425 2425:  *    gives a repeated sequence (cycle, period) of statistically independent
2426 2426:  *    random numbers, with appropriate choice of :
2427 2427:  *    modulus  m : should be large, to permit a LONG period
2428 2428:  *                 should be prime, to permit a FULL period (cf multiplier a)
2429 2429:  *    multipl. a : should be a "primitive root" of prime m to permit a FULL
2430 2430:  *                 period, ie. :   a**(m-1) mod m = 1 (Fermats theorem).
2431 2431:  *    The following choice of parameters passes tests of random distribution
2432 2432:  *    and permits implementation with 32-bit arithmetic (C "long" data type) :
2433 2433:  *                    m   =   (2**31 - 1) =   2147483647
2434 2434:  *                    a   =   (7**5)      =   16807
2435 2435:  *                    X0  =   initial seed in the range [ 1 ... (m-1) ]
2436 2436:  *    The PMMLCG with these parameters is recommended as a minimal standard
2437 2437:  *    for a reliable and portable random number generator (see references).
2438 2438:  *
2439 2439:  *                      Schrage's Method.
2440 2440:  *    An algorithm, that evaluates expressions in the PMMLCG in such a way,
2441 2441:  *    that all intermediate results are bounded by (m-1).
2442 2442:  *    Given :     f(X)    =   a*X mod m
2443 2443:  *                        =   a*X - m ( a*X div m )
2444 2444:  *    we can use an "approximate" factoring of m : 	m = aq + r
2445 2445:  *    with the quotient q = (m div a) and the rest r = (m mod a)
2446 2446:  *    to transcribe f(X) to :
2447 2447:  *                f(X)    =   a(X mod q) -  r(X div q) +
2448 2448:  *                            (X div q) - (a*X div m)
2449 2449:  *                        =   y(X) + z(X)
2450 2450:  *    where :     y(X) > 0  =>  z(X) = 0
2451 2451:  *                y(X) = 0  =>  z(X) = m
2452 2452:  *
2453 2453:  * RETURN
2454 2454:  *    A (pseudo-)random float value, normalized to the range [0 - 0.999...]
2455 2455:  *-4*/
2456 2456: 
2457 2457:     /* Assume a "globally defined X-value : static DWORD dwSeed */
2458 2458:     long      hi = 0L;         /* Scratch variables */
2459 2459:     long      lo = 0L;
2460 2460:     long      yx = 0L;
2461 2461: 
2462 2462:     /* 1: Calculate Lehmer's expression : f(X) = a*X mod m */
2463 2463:     /* (using Schrage's method to eliminate potential overflow by a*X) */
2464 2464:     lo = dwSeed % q;           /* (X mod q) */

XC ... 'C' Concordance Utility   ss.c                       Page 45

2465 2465:     hi = dwSeed / q;           /* (X div q) */
2466 2466:     yx = (a * lo) - (r * hi);  /* a * (X mod q) - r * (X div q) */
2467 2467:     /* always in the range [0...m-1] */
2468 2468: 
2469 2469:     /* 2: Reset seed for next call, and return (pseudo-)random value */
2470 2470:     dwSeed = (yx > 0 ? yx : yx + m);               /* always in range [0...2m-1] */
2471 2471:     return (double)((float) dwSeed / (float) m);   /* normalize to range [1/m...1-1/m] */
2472 2472: 
2473 2473: }   /* END function rRandom() */
2474 2474: 
2475 2475: 
2476 2476: 
2477 2477: /*+4 MODULE HASH.C ---------------------------------------------------------*/
2478 2478: /*   NAME   29               wCCITTcrc                                      */
2479 2479: /*-- SYNOPSIS --------------------------------------------------------------*/
2480 2480: #define POLY   0x8408
2481 2481: #define CRCOK  0x470F
2482 2482: #define PRESET 0xFFFF
2483 2483: 
2484 2484: PRIVATE   WORD
2485 2485: wCCITTcrc(pzData, wLength)
2486 2486:     char     *pzData;      /* Address of start of data block  */
2487 2487:     WORD      wLength;     /* Length of data block (in bytes) */
2488 2488: {
2489 2489: /* DESCRIPTION
2490 2490:  *    This routine generates the 16-bit remainder of a block of data, using
2491 2491:  *    the 16-bit CCITT polynomial generator. The basic idea is to treat the
2492 2492:  *    entire message as a (rather long) binary number; the crc checksum is
2493 2493:  *    then obtained by taking the one's complement of the remainder after the
2494 2494:  *    modulo 2 division by a generator polynomial.
2495 2495:  *                           16   12   5
2496 2496:  *    The CCITT-CRC uses: ( X  + X  + X + 1 ) for the generator polynomial.
2497 2497:  *    This may also be expressed as :  position   16   12        5     0
2498 2498:  *     - in binary :                               1 0001 0000 0010 0001
2499 2499:  *     - in hex    :                               1        10        21
2500 2500:  *    In computing the crc, a 17-bit dataregister is simulated by testing the
2501 2501:  *    MSB before shifting the data. This affords us the luxury of specifying
2502 2502:  *    the polynomial as a 16-bit value : 0x1021.
2503 2503:  *    The crc is generated in "LSB->MSB" order, so the bits of the polynomial
2504 2504:  *    are also stored in reverse order : 0x8408.
2505 2505:  * RETURN
2506 2506:  *    16-bit CCITT-reverse of block pointed to by pzData, length wLength byte.
2507 2507:  *-4*/
2508 2508:     WORD      wData = 0;   /* One byte of data */
2509 2509:     WORD      wCrc = 0;    /* Accumulator for 16-bit CRC-value */
2510 2510:     BYTE      bBit = 0;    /* Counter for bits in a byte */
2511 2511: 
2512 2512: 
2513 2513:     /* 1: "Preset" crc to -1 (=binary all 1's), and check wLength > 0 */
2514 2514:     wCrc = PRESET;	       /* Avoid problem of leading zero'es in data */
2515 2515:     if (wLength <= (WORD)0)
2516 2516: 	return (~wCrc);
2517 2517: 
2518 2518: 
2519 2519:     /* 2: For each BYTE (8 bit) in the data block ... */
2520 2520:     do {

XC ... 'C' Concordance Utility   ss.c                       Page 46

2521 2521: 
2522 2522: 	/* For each bit in the data BYTE ... */
2523 2523: 	for (bBit = 0, wData = (WORD) 0xFF & *pzData++;
2524 2524: 	     bBit < 8; bBit++, wData >>= 1) {
2525 2525: 
2526 2526: 	    /* (LSBit of crc) XOR (LSBit of data */
2527 2527: 	    if ((wCrc & 0x0001) ^ (wData & 0x0001))
2528 2528: 		wCrc = (wCrc >> 1) ^ POLY;	/* (crc/2) XOR polynomial */
2529 2529: 	    else
2530 2530: 		wCrc >>= 1;     /* (crc/2) */
2531 2531: 	}
2532 2532: 
2533 2533:     } while (--wLength);
2534 2534: 
2535 2535: 
2536 2536:     /* 3: Do 1's complement and swap bytes in final crc */
2537 2537:     /* If a crc is itself included in the calculation, the valid values are: */
2538 2538:     /* Final crc: 0xF0B8, After complement: 0x0F47, After byte swap: 0x470F */
2539 2539:     wCrc = ~wCrc;
2540 2540:     wData = wCrc;
2541 2541:     wCrc = (wCrc << 8) | (wData >> 8 & 0xFF);
2542 2542: 
2543 2543:     return (wCrc);
2544 2544: 
2545 2545: }   /* END function wCCITTcrc() */
2546 2546: 
2547 2547: 
2548 2548: 
2549 2549: /*+4 MODULE HASH.C ---------------------------------------------------------*/
2550 2550: /*   NAME   30               pzStrcpyAlloc                                  */
2551 2551: /*-- SYNOPSIS --------------------------------------------------------------*/
2552 2552: PRIVATE char *
2553 2553: pzStrcpyAlloc(ppzDest, pzSrc)
2554 2554:     char    **ppzDest;     /* Pointer to destination-string */
2555 2555:     char     *pzSrc;       /* Source-string */
2556 2556: {
2557 2557: /* DESCRIPTION
2558 2558:  *    Transfer a string to dynamic (heap-)space.
2559 2559:  *    1.  Allocate a new destination-string of size strlen(source-string),
2560 2560:  *    2.  Copy source-string to destination-string (on the heap).
2561 2561:  * RETURN
2562 2562:  *    Address of destination-string.
2563 2563:  *    NB: Memory allocated by pzStrcpyAlloc must be free'd after use.
2564 2564:  *-4 */
2565 2565: 
2566 2566:     /* 1: Allocate destination string */
2567 2567:     *ppzDest = (char *) malloc(strlen(pzSrc) + 1);
2568 2568: 
2569 2569: 
2570 2570:     /* 2: Copy source-string to destination-string */
2571 2571:     if (*ppzDest != NULL)
2572 2572: 	(void) strcpy(*ppzDest, pzSrc);
2573 2573: 
2574 2574:     /* 3: Return address of destination-string (NULL if bad alloc) */
2575 2575:     return (*ppzDest);
2576 2576: 

XC ... 'C' Concordance Utility   ss.c                       Page 47

2577 2577: }   /* END function pzStrcpyAlloc() */
2578 2578: 
2579 2579: 
2580 2580: 
2581 2581: /* END module hash.c                                                        */
2582 2582: /*==========================================================================*/
2583 2583: 
XC ... 'C' Concordance Utility                              Page 48

_HASH_ALLOC         :  515 
ACHK_ERR            :  714  720  723  726  731  734  737  740  746  757  762  931  934 
ARET_ERR            : 1180 1189 1193 1194 1223 1234 1301 1303 1308 1314 1317 1323 1336 1341 1402 1414 1419 1515 1522 1532 
                      1539 1560 1564 1607 1611 1691 1700 1707 1731 1808 1811 1822 1826 1897 1898 1902 1918 1923 1928 1931 
                      1936 1939 1942 1998 2029 2034 2079 2083 2088 2136 2143 2146 2178 2212 2217 2223 2226 2229 2265 2271 
                      2274 2276 
ARET_OK             :  937 1239 1348 1430 1568 1614 1840 1948 2004 2038 2106 2150 2182 2233 2280 
A_BADALLOC          : 1189 1194 1308 1323 1532 1700 1822 1902 2083 
A_CONT              :  714  720  723  726  731  734  737  740  746  757  762 
A_DUPLICATE         : 1564 
A_FILECLOSE         : 1419 
A_FILEEXIST         : 1180 
A_FULL              : 1522 
A_ISOPEN            : 1301 
A_MOREDATA          : 2101 
A_NOFILE            : 1303 
A_NOTCREATE         : 1193 1936 1939 
A_NOTFOUND          : 1611 1762 
A_NOTOPEN           : 1402 1515 1691 1897 1998 2029 2079 
A_OK                :  766 1762 
A_OTHER             : 1731 1898 
A_READ              : 1539 1811 2178 2271 2274 2276 
A_READONLY          : 2136 2212 
A_SEEK              : 1808 2217 2265 
A_STOP              :  931  934 
A_WRITE             : 1560 2143 2146 2223 2226 2229 
A_WRONGFILE         : 1317 
A_XPAND             :  724 2034 
Aid                 : 1761 
Astat               :  724  766 1223 1234 1314 1336 1341 1414 1607 1707 1762 1826 1918 1923 1928 1931 1942 2088 2101 
a                   : 2409 2466 
argc                :  637  638 
argv                :  637  639 
assert              :  986 1054 1067 1182 
BYTE                : 2510 
bBit                : 2510 2523 2524 2524 
CRCOK               : 2481 
cIdxFile            :  690  711 
checksum            : 1317 1461 
D                   :  980  981 1024 1201 1206 1207 1297 1326 1683 1708 1743 1751 1755 2261 2312 2313 2333 
DEBUG               :  557 1091 
DELETED             : 1605 1726 
DWORD               :  544  551  552  554  555  555  559  573  573  578  589  592  597  600  692  693  883  927  928  952 
                       952  952  953  953  953  954  954  954  954  954  957  958  965  969  983  984  995 1002 1003 1013 
                      1014 1015 1018 1035 1039 1040 1051 1052 1101 1136 1174 1484 1504 1505 1507 1594 1595 1627 1637 1652 
                      1653 1672 1673 1797 1798 1799 1886 1887 1889 1960 1988 1989 2050 2073 2194 2207 2245 2258 2291 2300 
                      2346 2373 2393 2409 2410 2411 2412 
define              :  510  511 
dw12P               :  952 1014 
dw75P               :  953 1016 
dwCount             :  693  717  717  717  720 1174 1232 1232 1232 1233 1799 1824 1824 1824 1825 2073 2085 2085 2085 2087 
                      
dwCurSlot           :  555  559 1036 1039 1061 1080 1098 1101 1112 1507 1528 1538 1544 1544 1559 1595 1601 1606 1672 1696 
                      1706 1723 1723 1727 1727 1736 
dwDatOff            :  544  692  757  758  881  883  902 
dwDatOffset         :  573  578 1230 1481 1484 1557 1557 1594 1601 1737 1958 1960 1968 2091 2228 2228 2275 2275 

XC ... 'C' Concordance Utility                              Page 49

dwHB                :  954 1015 1016 
dwHashFunc          :  552  966 1077 1528 1696 
dwHval1             :  983  995 1002 1003 1003 1013 1014 1014 1015 1016 1016 1018 1018 1024 1026 
dwHval2             :  984 1015 1016 
dwIsize             : 1132 1136 1182 1197 1212 1232 1327 1345 1517 1673 1692 1692 1696 1723 1727 1797 1816 1824 1836 1836 
                      1886 1886 1911 2000 2033 2085 
dwIused             : 1213 1327 1518 1608 1798 1829 1837 1837 1887 1887 1912 1913 2001 2033 
dwKeySlot           : 1637 1639 
dwMaxSlot           :  552  555  966  969  996 1003 1018 1036 1040 1061 1080 
dwNewsize           : 1889 1911 1912 1913 1914 1917 
dwOffset            : 2207 2216 2258 2261 2264 
dwPrime1            :  958 1077 1205 1207 1345 
dwPrime2            :  957 1197 1198 1200 1201 1202 1203 1205 1206 1212 
dwRehashFunc        :  555 1036 1544 1723 1727 
dwRincr             : 1052 1077 1080 
dwRval              : 1051 1061 1080 1085 
dwSeed              : 2291 2321 2464 2465 2470 2471 
dwSize              :  927  931  932 
dwSlot              :  589  592 2192 2194 2207 2243 2245 2258 
dwUsed              :  928  931  932 
EOF                 : 2146 
ERROR               :  711 1173 1223 1234 1293 1314 1336 1341 1398 1414 1418 1419 1511 1539 1560 1597 1607 1678 1679 1707 
                      1713 1803 1807 1808 1826 1892 1918 1923 1928 1931 1942 1966 1970 2075 2088 2102 
EXIT_FAILURE        :  816 
eAnsType            :  568 1443 
eHashIdxClose       :  737  762  815 1358 1927 1930 
eHashIdxCreate      :  711 1132 1917 
eHashIdxGetLoad     :  723  934 2014 
eHashIdxGetSize     :  931 1986 
eHashIdxOpen        :  746 1249 1941 
eHashIdxProcess     :  734 1922 2048 
eHashIdxResize      :  725 1854 
eHashIdxRestore     :  565 1340 1779 
eHashKeyDelete      : 1578 
eHashKeyFind        :  757 1624 
eHashKeyInsert      :  720 1481 1968 
eIdxStatPrint       :  547  714  726  731  915 
eIntegr             :  568 1440 1443 1465 
eLocateKey          :  573 1601 1639 1649 
eReadIdxHdr         :  586 1313 2160 
eReadIdxKey         :  592 1538 1706 1825 2087 2243 
eRetCode            : 1173 1222 1223 1233 1234 1293 1313 1314 1335 1336 1340 1341 1398 1413 1414 1418 1419 1511 1538 1539 
                      1559 1560 1597 1601 1604 1606 1607 1678 1706 1707 1803 1807 1808 1825 1826 1892 1917 1918 1922 1923 
                      1927 1928 1930 1931 1941 1942 1966 1968 1970 2075 2087 2088 
eRetFound           : 1679 1713 1720 1743 1762 1763 
eRetType            :  546  564  572  582  585  588  591  914 1131 1173 1248 1293 1357 1398 1480 1511 1577 1597 1623 1648 
                      1678 1679 1778 1803 1853 1892 1966 1985 2013 2047 2075 2120 2159 2191 2242 
eWriteIdxHdr        :  583 1222 1335 1413 2121 
eWriteIdxKey        :  589 1233 1559 1606 2192 
envp                :  637  640 
exit                :  816 
F                   : 1800 1807 1810 
FALSE               :  956 1067 1078 1546 1712 1719 2314 2399 
FILE                : 1172 1178 1292 1800 
FILE_OFFSET         :  525 2207 2258 
FLAG                :  599  956 1509 1510 1676 2314 2344 

XC ... 'C' Concordance Utility                              Page 50

f                   :  589  592 
fAgain              : 1510 1535 1546 1676 1704 1712 1719 
fDupkey             : 1509 1542 1543 1554 
fFirstHash          :  956 1022 1076 1078 
fGotPrime           : 2314 2326 2329 2333 2335 
fIsPrime            :  600 1200 2326 2345 
fShft               :  854  857 
fclose              : 1179 1418 
fd                  : 1172 1178 1179 1192 1193 1292 1302 1303 1312 1312 1418 1800 2139 2142 2145 2174 2177 2216 2222 2225 
                      2228 2264 2270 2273 2275 
fflush              : 2145 
fgets               :  812  865 
filename            :  806 1194 1323 1424 1901 1903 
filesize            : 1802 1810 1811 1816 
fmod                : 2387 2389 
fopen               : 1178 1192 1302 
fprintf             :  804  805  807  808  863  902  932  935 1112 1201 1206 1207 1297 1326 1751 1755 2261 2333 
fputs               :  700 
fread               : 2177 2270 2273 2275 
free                : 1236 1424 1425 1550 1739 1832 1944 2097 
fseek               : 1807 2139 2174 2216 2264 
ftell               : 1810 
fwrite              : 2142 2222 2225 2228 
getchar             :  866 
H                   :  568  573  583  586  589  592 1440 1441 1458 1649 1650 1691 1692 1693 1706 2121 2122 2136 2139 2142 
                      2145 2160 2161 2174 2177 2192 2193 2206 2212 2216 2222 2225 2228 2243 2244 2257 2264 2270 2273 2275 
                      
HASH                :  547  565  568  573  583  586  589  592  629  916 1133 1188 1250 1307 1359 1441 1482 1579 1625 1650 
                      1780 1847 1855 1987 2015 2049 2122 2161 2193 2244 
HF_ADD              :  986  999 
HF_FLL              :  986  991 
HF_PJW              :  986 1010 
HF_TYPE             :  986  986  986  989 
HI                  :  629  711  714  720  723  725  726  731  734  737  746  757  762  806  806  807  815 
HIsize              :  628  711  717 
hi                  : 2458 2465 2466 
ICLOSED             : 1420 
INTEGRITY_OK        : 1125 1332 1465 
INTEGRITY_UNKNOWN   : 1124 1334 1465 
IOPEN               : 1214 1301 1321 1402 1515 1691 1897 1998 2029 2079 
ISEVEN              : 2319 2386 
iCheckSum           : 1294 1316 1317 
iCompare            : 1677 1717 1718 
iKeylen             :  982  994  995  996 
iMaxTry             :  694  753  759 
iRes                : 1893 1935 1936 1938 1939 
iResize             : 1854 1856 1911 
iRetCode            : 2133 2142 2143 2145 2146 2171 2177 2178 2208 2216 2217 2222 2223 2225 2226 2228 2229 2259 2264 2265 
                      2270 2271 2273 2274 2275 2276 
iSigNum             :  538  778  779  804  808  820 
iUpward             :  597 2299 2301 2320 2330 
indexmode           :  806  807 1215 1322 1331 1407 1898 2136 2212 
indexsize           : 1211 1212 1213 1232 1316 1324 1324 1327 1327 1327 1345 1458 1458 1462 1517 1518 1519 1608 1692 1693 
                      1796 1836 1837 1886 1887 1888 2000 2001 2033 2033 2071 2085 2206 2257 
indexstatus         : 1214 1301 1321 1402 1420 1515 1691 1897 1998 2029 2079 
integrity           : 1332 1334 1465 

XC ... 'C' Concordance Utility                              Page 51

Ksize               :  627  630  711  719  756  898  899 
key                 :  573  578 1228 1229 1236 1481 1483 1528 1531 1532 1542 1542 1544 1550 1555 1555 1578 1580 1601 1624 
                      1626 1639 1649 1651 1696 1699 1700 1717 1717 1723 1727 1739 1821 1822 1832 1958 1959 1968 2082 2083 
                      2091 2097 2225 2273 
L                   :  717 1077 1125 1197 1200 1205 1345 1811 
lo                  : 2459 2464 2466 
MAIN                :  614 
MAXLINE             :  775  801  812 
m                   : 2410 2470 2471 
m0                  : 2312 2333 
m1                  : 2313 2333 
main                :  511 
malloc              : 1188 1228 1307 1531 1699 1821 1901 2082 2567 
memset              : 1229 
NBITS               :  952  953  954 
NO                  : 1221 
NULL                :  629  813  813 1172 1178 1189 1193 1194 1292 1301 1323 1426 1504 1505 1506 1532 1700 1822 1890 1891 
                      2083 2571 
n                   :  600 2345 2346 2381 2383 2387 2389 
nelem               :  525  527 
OK                  : 1418 1604 1720 1743 1762 1807 
P                   :  538  541  544  547  552  555  559  565  568  573  578  583  586  589  592  597  600  603  606  609 
                      2050 
POLY                : 2480 2528 
PRESET              : 2482 2514 
PRIVATE             :  537  540  543  546  551  554  558  564  567  572  577  582  585  588  591  596  599  602  605  608 
                       620  777  829  880  914  952  953  954  956  957  958  965 1035 1097 1439 1648 1778 1957 2120 2159 
                      2191 2242 2298 2344 2409 2410 2411 2412 2415 2484 2552 
PUBLIC              : 1131 1248 1357 1480 1577 1623 1853 1985 2013 2047 
p                   : 2373 2383 2386 2391 2391 2393 
pH                  :  547  565  915  916  931  934 1132 1133 1188 1189 1192 1193 1194 1211 1212 1213 1214 1215 1221 1222 
                      1232 1233 1249 1250 1301 1301 1307 1308 1312 1313 1321 1322 1323 1324 1331 1335 1340 1345 1358 1359 
                      1402 1407 1410 1413 1418 1420 1424 1425 1426 1481 1482 1515 1517 1518 1519 1538 1559 1578 1579 1601 
                      1606 1608 1624 1625 1639 1779 1780 1796 1800 1825 1836 1837 1854 1855 1886 1887 1888 1897 1898 1901 
                      1903 1922 1927 1941 1986 1987 1998 2000 2001 2014 2015 2029 2033 2033 2048 2049 2071 2079 2085 2087 
                      
pcKeystr            :  552  555  559  966  967  980  994  995  995 1002 1002 1002 1003 1013 1013 1014 1036 1037 1077 1098 
                      1099 1107 
pcKst               :  980 1024 1107 1109 
pdwDatOffset        : 1624 1627 1639 1649 1653 1737 
pdwIsize            : 1504 1517 1522 1528 1544 
pdwIused            : 1505 1518 1522 1561 
pdwKeySlot          :  573 1649 1652 1736 
pdwPrime            :  597 2299 2300 2319 2320 2321 2326 2330 2333 
pdwSize             : 1986 1988 2000 
pdwUsed             : 1986 1989 2001 
ppzDest             :  609 2553 2554 2567 2571 2572 2575 
probes              : 1687 1708 1745 1748 
pstHdrRec           : 2121 2123 2142 2160 2162 2177 
pstIdxHdr           :  568  583  586 1440 1442 1458 1461 1462 1465 
pstKeyRec           : 2192 2195 2222 2222 2225 2228 2228 2243 2246 2270 2270 2273 2275 2275 
pwKsize             : 1506 1519 1528 1531 1542 1544 
pwLoad              : 2014 2016 2033 2034 
pzAccess            : 1249 1252 1298 1302 1322 
pzData              :  606 2485 2486 2523 
pzIdxFile           : 1132 1134 1178 1192 1194 1249 1251 1298 1302 1323 

XC ... 'C' Concordance Utility                              Page 52

pzKBuf              :  630  719  720  756  757  758  759  898  899  902 
pzKeyBuf            :  541  544  830  832  853  864  865  871  881  882  898 
pzKp                :  853  859 
pzLine              :  801  812  813  813 
pzNewFile           : 1891 1907 1908 1917 1938 
pzOldFile           : 1890 1901 1902 1903 1935 1938 1941 1944 
pzSrc               :  609 2553 2555 2567 2572 
pzStrcpyAlloc       :  609 1194 1323 2553 
q                   : 2411 2464 2465 
RANDOM              :  752  848 
REAL_MAIN           :  511  637 
RF_DBL              : 1054 1074 1199 
RF_LIN              : 1054 1059 
RF_QAD              : 1064 
RF_TYPE             : 1054 1054 1057 1199 
RO                  : 1322 2136 2212 
RW                  :  806  807 1215 1322 1331 1407 1898 
r                   : 2412 2466 
rRandom             :  603  857 2381 2416 
remove              : 1908 1935 
rename              : 1938 
rgcKbf              : 1092 1109 1110 1112 
SEEK_END            : 1807 
SEEK_SET            : 2139 2174 2216 2264 
SIGINT              :  704 
SIGNON              :  620  700 
SIGTERM             :  705 
STCK                :  510 1025 1084 1238 1347 1429 1567 1613 1760 1839 1947 2003 2037 2105 2149 2181 2232 2279 
signal              :  704  705  820 
stHcore             : 1188 1307 
stHdisk             :  526  568  583  586 1170 1291 1397 1442 1816 2123 2142 2162 2177 
stHkey              :  527  589  592 1171 1508 1596 1675 1801 1817 2072 2195 2246 
stHsize             : 1316 1462 
stIdxHdr            : 1170 1221 1222 1291 1313 1316 1317 1324 1327 1327 1327 1332 1334 1335 1397 1410 1413 
stKeyRec            : 1171 1227 1228 1229 1230 1233 1236 1508 1531 1532 1538 1542 1543 1550 1555 1556 1557 1559 1596 1605 
                      1606 1675 1699 1700 1706 1710 1717 1737 1739 1801 1821 1822 1825 1828 1832 2072 2082 2083 2087 2090 
                      2091 2091 2097 
status              : 1227 1543 1556 1605 1710 1828 2090 2222 2222 2270 2270 
stdin               :  812  865 
stdout              :  700  804  805  807  808  863  902  932  935 1112 1201 1206 1207 1297 1326 1751 1755 2261 2333 
strchr              :  813  813 
strcmp              : 1298 1322 
strcpy              : 1903 2572 
strlen              :  994 1901 2567 
strncmp             : 1542 1717 
strncpy             :  864  898 1109 
sum_lookup_all      : 1683 1747 1756 1757 
sum_lookup_ok       : 1685 1744 1752 1753 
sum_probe_all       : 1684 1748 1756 1757 
sum_probe_ok        : 1686 1745 1752 1753 
TRUE                : 1022 1067 1076 1180 1198 1203 1509 1510 1564 1611 1676 1731 1914 2399 
Temp_hash           : 1847 1917 1930 1968 
toupper             :  859 
USED                : 1543 1556 1716 1828 2090 
ufunc               : 2048 2050 2091 
VACANT              : 1227 1711 

XC ... 'C' Concordance Utility                              Page 53

VOID                :  603 2416 
vGetPrime           :  597 1198 1203 1914 2299 
vHashTrace          :  559 1024 1098 
vKeyGet             :  541  719  756  830 
vSigCatch           :  538  704  705  778  820 
vUpdate_stHdisk     :  568 1221 1410 1440 
void                :  537  540  558  567  596  777  812  829 1097 1179 1229 1439 1903 1908 2139 2174 2298 2572 
WORD                :  541  543  552  555  559  577  605  606  691  831  850  851  852  857  880  929  968  981 1002 1013 
                      1038 1100 1135 1316 1462 1506 1674 1796 1888 1957 2016 2033 2050 2071 2074 2206 2257 2376 2377 2484 
                      2487 2508 2509 2515 2523 
wAgain              : 2074 2091 2092 2100 
wCCITTcrc           :  606 1316 1462 2485 
wCopy2New           :  578 1922 1958 
wCount              : 2376 2380 2380 2380 
wCrc                : 2509 2514 2516 2527 2528 2528 2530 2539 2539 2540 2541 2541 2543 
wData               : 2508 2523 2524 2527 2540 2541 
wKeyPrint           :  544  734  758  881 
wKeySize            :  541  830  831  852  863  864  865  871 
wKsiz               : 2206 2207 2225 2257 2258 2273 
wKsize              :  525  528  552  555  559  966  968  981 1002 1013 1036 1038 1077 1098 1100 1109 1110 1132 1135 1182 
                      1211 1211 1228 1229 1327 1519 1674 1693 1693 1696 1699 1717 1723 1727 1796 1796 1817 1821 1888 1888 
                      1917 2071 2071 2082 2206 2257 
wKsz                :  852  856  981 1024 
wLength             :  606 2485 2487 2515 2533 
wLet                :  851  858  859  859 
wLoad               :  691  723  929  934  935 
wRan                :  850  857  858  859 
wTests              : 2377 2380 
x                   :  510 2374 2381 2387 2389 2389 2389 
YES                 : 1410 1465 
y                   : 2375 2382 2387 2387 2395 2399 
yx                  : 2460 2466 2470 2470 2470 


