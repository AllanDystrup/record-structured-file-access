XC ... 'C' Concordance Utility   crc.c                      Page 1

1       1: /*+1========================================================================*/
2       2: /* MODULE                          CRC.C                                    */
3       3: /*==========================================================================*/
4       4: /* FUNCTION    Compute CCITT-CRC-16 checksum "on-the-fly".
5       5:  *                  The module contains a function : wCCITTcrc() for computing
6       6:  *             the checksum of a block of data.  The function may be compiled
7       7:  *             to a standard subroutine, which may then be called from another
8       8:  *             module (#include headerfile crc.h).  Alternatively the module
9       9:  *             crc.c can compile to a "standalone" program (compiler switch
10     10:  *             -DMAIN) for calculating checksums of arbitrary files.
11     11:  *                  wCCITTcrc() computes a "Cyclic Redundancy Check", using
12     12:  *             the CCITT polynomial as "generator".  The error detection rate
13     13:  *             is guaranteed to be 99.9984%, worst case.  The checksum utility
14     14:  *             may be used to verify the integrity of any block of data in
15     15:  *             memory or on disk (file validation).
16     16:  *
17     17:  * SYSTEM      STANDARD C.
18     18:  *             Tested on UNIX V.3 and PC/MS DOS 3.3
19     19:  *
20     20:  * PROGRAMMER  Allan Dystrup
21     21:  *
22     22:  * COPYRIGHT   (c) Allan Dystrup, Sept.1991
23     23:  *
24     24:  * VERSION     $Header: d:/cwork/chb/ux/RCS/crc.c 1.1
25     25:  *             91/09/19 23:18:30 Allan_Dystrup Exp $
26     26:  *             ---------------------------------------------------------------
27     27:  *             $Log:	crc.c $
28     28:  * 			Revision 1.1  91/09/23  11:31:20  Allan_Dystrup
29     29:  * 			Initial revision
30     30:  *
31     31:  * REFERENCES  Theory : Schwaderer, W.D. [1988]
32     32:  *                "C Programmer's guide to NetBIOS"
33     33:  *                Howard W. Sams & Company.
34     34:  *             Implementation: Several sources, notably credit to :
35     35:  *                Joe Campbell, Bob Felice, Nigel Cort,
36     36:  *                William Hunt & Andrew Chalk, PhD.
37     37: 
38     38:  * USAGE       1. as a standard subroutine :
39     39:  *                   #include <crc.h>
40     40:  *                   char *pzData = "Data for validation"; // data buffer
41     41:  *                   WORD wLength = strlen(pzData);        // length of buffer
42     42:  *                   WORD crc = PRESET;                    // initial crc preset
43     43:  *                   crc = wCCITTcrc(*pzData, wLength, crc);
44     44:  *             2. as a standalone program :
45     45:  *                   crc <filename> [optional tracelevel]
46     46: 
47     47:  * BUGS        1. Works only in a STANDARD C environment
48     48:  *                (Will not compile under K&R C without some massaging)
49     49:  *             2. On-the-fly crc calculation is relativevely slow, -
50     50:  *                might be speeded up by a table look-up approach.
51     51:  *                (This is primarily a demo-program).
52     52:  *
53     53:  *-1========================================================================*/
54     54: 
55     55: 
56     56: 

XC ... 'C' Concordance Utility   crc.c                      Page 2

57     57: /*--------------------------------------------------------------------------*/
58     58: /*                             Include files                                */
59     59: /*--------------------------------------------------------------------------*/
60     60: 
61     61: /* Include standard C headers */
62     62: #include <stdio.h>
63     63: #include <stdlib.h>
64     64: #include <string.h>
65     65: #include <ctype.h>
66     66: #include <malloc.h>
67     67: #include <assert.h>
68     68: #include <stdarg.h>
69     69: 
70     70: /* Include project header */
71     71: #define CRC_ALLOC
72     72: #include "crc.h"
73     73: 
74     74: 
75     75: /*--------------------------------------------------------------------------*/
76     76: /*                     Switch for program trace                             */
77     77: /*--------------------------------------------------------------------------*/
78     78: int       trace;
79     79: 
80     80: #define    LEVEL0     0		       /* Ignore all trace */
81     81: #define    LEVEL1     1		       /* Highlevel trace */
82     82: #define    LEVEL2     2		       /* Mediumlev. trace */
83     83: #define    LEVEL3     4		       /* Lowlevel trace */
84     84: 
85     85: #ifdef NTRACE
86     86: #define    T(level,stmt)	       /* Don't expand trace statements */
87     87: #else
88     88: #define    T(level,stmt)       { if (trace & level) stmt; }
89     89: #endif
90     90: 
91     91: 
92     92: /*--------------------------------------------------------------------------*/
93     93: /*                     Global Constants & (proto)types                      */
94     94: /*--------------------------------------------------------------------------*/
95     95: #define BUFSZ  (32*1024)
96     96: #define POLY   0x8408
97     97: #define PRESET 0xFFFF
98     98: #define CRCOK  0x470F
99     99: 
100   100: typedef enum {
101   101:     fFalse,
102   102:     fTrue
103   103: }         eBOOL;
104   104: 
105   105: PRIVATE WORD
106   106:        wPOSTSETcrc(WORD wCrc);
107   107: 
108   108: 
109   109: 
110   110: /*--------------------------------------------------------------------------*/
111   111: /*                     Global def's for error handling                      */
112   112: /*--------------------------------------------------------------------------*/

XC ... 'C' Concordance Utility   crc.c                      Page 3

113   113: typedef enum {
114   114:     EARGS,
115   115:     EOPEN,
116   116:     EMEM,
117   117:     EREAD
118   118: }         eERRNO;
119   119: 
120   120: PRIVATE const char *rgpchErrmsg[] = {
121   121:     "Missing filename - Usage: crc <filename>\n",   /* EARGS */
122   122:     "Can't open file[%s] - Check file exists\n",    /* EOPEN, <filename> */
123   123:     "Out of memory - Need [%d]KB free ram\n",	    /* EMEM,  <ramsize>  */
124   124:     "Error reading file[%s] - Check disk\n"	    /* EREAD, <filename> */
125   125: };
126   126: 
127   127: PRIVATE void vChkErr(eBOOL cond, eERRNO err,...);
128   128: 
129   129: 
130   130: 
131   131: #ifdef MAIN
132   132: /*+1 MODULE CRC.C ==========================================================*/
133   133: /*   NAME                          main                                     */
134   134: /*== SYNOPSIS ==============================================================*/
135   135: void
136   136: main(int argc,			       /* Argument count */
137   137:      char *argv[]		       /* Argument vector */
138   138: )
139   139: {
140   140: /* DESCRIPTION
141   141:  *    This main function may act as both a testdriver for module CRC.C and as
142   142:  *    a small application program for calculating file checksums.
143   143:  *    1    If MAIN is not defined, the module compiles function wCCITTcrc to
144   144:  *         a "standard subroutine", which may be accessed by including the
145   145:  *         the headerfile crc.h in your application module.
146   146:  *    2    If MAIN is defined (compiler flag -DMAIN), the module compiles to
147   147:  *         2.1   If NDEBUG is not defined : a testdriver for module CRC.C
148   148:  *         2.2   If NDEBUG is defined (compiler flag -DNDEBUG) : a standalone
149   149:  *               application for computing file checksums.
150   150:  *-1*/
151   151:     FILE     *hInFile;             /* Handle for input file */
152   152:     BYTE     *rgchFbuf;            /* Buffer for reading input file */
153   153:     DWORD     dwCount;             /* Counter of bytes in rgchFbuf */
154   154:     WORD      wCRC;                /* The crc value being computed */
155   155: 
156   156: 
157   157: #ifdef DEBUG			   /* If debug! */
158   158:     /*----------------------------------------------------------------------*/
159   159:     /*                 Test driver part of main()                           */
160   160:     /*----------------------------------------------------------------------*/
161   161:     BYTE      rgchTbuf[40];	       /* Allocate Test-buffer for int. tests */
162   162: 
163   163:     trace = LEVEL1 | LEVEL2;	       /* Raise trace level */
164   164: 
165   165:     fputs("Module CRC.C, internal test :\n", stdout);
166   166: 
167   167:     fputs("   1. Functionality test\n", stdout);
168   168:     rgchTbuf[0] = 'T';                /* One ASCII char */

XC ... 'C' Concordance Utility   crc.c                      Page 4

169   169:     rgchTbuf[1] = (BYTE) 0xD9;	       /* crc for 'T' - 1. byte */
170   170:     rgchTbuf[2] = (BYTE) 0xE4;	       /* crc for 'T' - 2. byte */
171   171:     rgchTbuf[3] = (BYTE) NULL;
172   172: 
173   173:     wCRC = PRESET;
174   174:     fprintf(stdout, "TEST [T],\t\t\t\t expected:0xD9E4 - got:0x%X\n\n",
175   175: 	    wPOSTSETcrc(wCCITTcrc(rgchTbuf, 1, wCRC)));
176   176: 
177   177:     wCRC = PRESET;
178   178:     fprintf(stdout, "TEST [T <CRC>],\t\t\t\t expected:0x%X - got:0x%X\n\n",
179   179: 	    wPOSTSETcrc(wCCITTcrc(rgchTbuf, 3, wCRC)), CRCOK);
180   180: 
181   181:     wCRC = PRESET;
182   182:     strcpy((char *) rgchTbuf, "THE,QUICK,BROWN,FOX,0123456789");
183   183:     fprintf(stdout, "TEST [%s],\t expected:0x6E20 - got:0x%X\n\n",
184   184: 	    rgchTbuf, wPOSTSETcrc(wCCITTcrc(rgchTbuf, strlen((char *) rgchTbuf), wCRC)));
185   185: 
186   186:     fputs("   2. Range test\n", stdout);
187   187:     wCRC = PRESET;
188   188:     rgchTbuf[0] = (BYTE) '\0';	       /* Empty string */
189   189:     fprintf(stdout, "TEST [],\t\t\t\t expected:0x0000 - got:0x%0.4X\n\n",
190   190: 	    wPOSTSETcrc(wCCITTcrc(rgchTbuf, strlen((char *) rgchTbuf), wCRC)));
191   191: 
192   192:     rgchTbuf[0] = (BYTE) 0x00;	       /* Lower limit ASCII */
193   193:     rgchTbuf[1] = (BYTE) 0x7F;
194   194:     rgchTbuf[2] = (BYTE) 0xFF;	       /* Upper limit ASCII */
195   195:     rgchTbuf[3] = (BYTE) 0xB8;	       /* crc for [0x00 0x7F 0xFF], 1. byte */
196   196:     rgchTbuf[4] = (BYTE) 0xBA;	       /* crc for [0x00 0x7F 0xFF], 2. byte */
197   197:     rgchTbuf[5] = (BYTE) NULL;
198   198:     wCRC = PRESET;
199   199:     fprintf(stdout, "TEST [0x00 0x7F 0xFF <CRC>],\t\t expected:0x%X - got:0x%X\n\n\n",
200   200: 	    wPOSTSETcrc(wCCITTcrc(rgchTbuf, 5, wCRC)), CRCOK);
201   201: #endif
202   202: 
203   203:     /*----------------------------------------------------------------------*/
204   204:     /*                 Application part of main()                           */
205   205:     /*----------------------------------------------------------------------*/
206   206:     /* Check valid call format : crc filename [trace-level] */
207   207:     vChkErr(argc < 2, EARGS);
208   208:     trace = (argc > 2 && isdigit(*argv[2]) ? atoi(argv[2]) : LEVEL0);
209   209: 
210   210:     /* Open input file, mode read-binary */
211   211:     hInFile = fopen(argv[1], "rb");
212   212:     vChkErr(hInFile == NULL, EOPEN, argv[1]);
213   213: 
214   214:     /* Set up a large buffer */
215   215:     rgchFbuf = (BYTE *) malloc(BUFSZ);
216   216:     vChkErr(rgchFbuf == NULL, EMEM, BUFSZ);
217   217: 
218   218:     /* "Preset" crc to binary all 1's (avoids problem of leading 0 in data) */
219   219:     wCRC = PRESET;
220   220: 
221   221: 
222   222:     /* Calculate crc of file */
223   223:     while (fTrue) {
224   224: 

XC ... 'C' Concordance Utility   crc.c                      Page 5

225   225: 	/* Read next chunk of the inputfile */
226   226: 	dwCount = fread(rgchFbuf, 1, BUFSZ, hInFile);
227   227: 
228   228: 	/* If End-Of-File, print crc & terminate */
229   229: 	if (dwCount == 0) {
230   230: 	    vChkErr(!feof(hInFile), EREAD, argv[1]);
231   231: 
232   232: 	    wCRC = wPOSTSETcrc(wCRC);
233   233: 	    printf("CCITT CRC (REVERSE) for %8s   is\t[%04X]\n", argv[1], wCRC);
234   234: 	    exit(0);
235   235: 	}
236   236: 	/* Update crc with value calculated from contents of buffer */
237   237: 	T(LEVEL1, printf("Main calling wCCITTcrc with dwCount=%lu, crc=0x%X\n", dwCount, wCRC));
238   238: 	wCRC = wCCITTcrc(rgchFbuf, dwCount, wCRC);
239   239:     }
240   240: 
241   241: } /* END function main */
242   242: #endif
243   243: 
244   244: 
245   245: 
246   246: /*+2 MODULE ================================================================*/
247   247: /*   NAME                      wCCITTcrc                                    */
248   248: /*== SYNOPSIS ==============================================================*/
249   249: PUBLIC    WORD
250   250: wCCITTcrc(BYTE * pszData,      /* Pointer to databuffer */
251   251: 	  DWORD dwLength,       /* Length of databuffer */
252   252: 	  WORD wCrc             /* Current value of crc, to be updated */
253   253: )
254   254: {
255   255: /* DESCRIPTION
256   256:  *    This routine generates the 16-bit remainder of a block of data,
257   257:  *    using the 16-bit CCITT polynomial generator.  The basic idea is to
258   258:  *    treat the entire message as a (rather long) binary number; the crc
259   259:  *    checksum is then obtained by taking the one's complement of the
260   260:  *    remainder after the modulo 2 division by a generator polynomial.
261   261:  *                           16   12   5
262   262:  *    The CCITT-CRC uses: ( X  + X  + X + 1 ) for the generator polynomial.
263   263:  *    This may also be expressed as :
264   264:  *         bit position     16   12        5     0
265   265:  *       - in binary :       1 0001 0000 0010 0001
266   266:  *       - in hex    :       1    1    0    2    1
267   267:  *    In computing the crc, a 17-bit dataregister is simulated by testing
268   268:  *    the MostSignificantBit before shifting the data.  This affords us the
269   269:  *    luxury of specifying the polynomial as a 16-bit value : 0x1021.
270   270:  *    The crc is generated in "LSB->MSB" order, so the bits of the polynomial
271   271:  *    are also stored in reverse order : POLY = 0x8408.
272   272:  *-2*/
273   273:     WORD      wData;		       /* One word of data */
274   274:     BYTE      chBit;		       /* Counter for each bit in char */
275   275:     DWORD     dwCount = 0;	       /* Counter for each buffer run */
276   276: 
277   277: 
278   278:     /* Check actual parameters */
279   279:     assert(pszData != NULL);
280   280: 

XC ... 'C' Concordance Utility   crc.c                      Page 6

281   281:     /* Make it roubust : define crc to zero for empty buffer */
282   282:     if (dwLength == 0 && wCrc == PRESET)
283   283: 	return (wCrc);
284   284: 
285   285:     /* For each BYTE (8 bit) in the wData block ... */
286   286:     do {
287   287: 
288   288: 	/* For each bit in the wData BYTE ... */
289   289: 	for (chBit = 0, wData = (WORD) 0xFF & *pszData++;
290   290: 	     chBit < 8;
291   291: 	     chBit++, wData >>= 1) {   /* move up next bit for XOR */
292   292: 
293   293: 	    if ((wCrc & 0x0001) ^ (wData & 0x0001))
294   294: 		/* If msb of (crc XOR data) is on, shift & subtract poly */
295   295: 		wCrc = (wCrc >> 1) ^ POLY;
296   296: 	    else
297   297: 		/* Otherwise, transparent shift */
298   298: 		wCrc >>= 1;
299   299: 	}
300   300: 
301   301: 	T(LEVEL2, ((dwCount++ % 10) == 0 ?
302   302: 		   printf("\n[%05lu]:  %04X", dwCount - 1, wCrc) : printf("  %04X", wCrc)));
303   303: 
304   304:     } while (--dwLength);
305   305: 
306   306:     return (wCrc);
307   307: 
308   308: } /* END function wCCITTcrc */
309   309: 
310   310: 
311   311: 
312   312: /*+3 MODULE ----------------------------------------------------------------*/
313   313: /*   NAME                      wPOSTSETcrc                                  */
314   314: /*-- SYNOPSIS --------------------------------------------------------------*/
315   315: PRIVATE   WORD
316   316: wPOSTSETcrc(WORD wCrc)        /* Crc value to be "post-conditioned" */
317   317: {
318   318: /* DESCRIPTION
319   319:  *    CRC postconditioning  :  Do 1's complement and swap bytes in wCrc.
320   320:  *    When a crc is itself included in the calculation, the valid crc is :
321   321:  *    Final wCrc:0xF0B8, After complement:0x0F47, After byte swap:0x470F
322   322:  *-3*/
323   323:     WORD      wSwap;		       /* Word for swapping crc HI/LO */
324   324: 
325   325:     T(LEVEL2, printf("\nFinal CRC : %04X", wCrc));
326   326: 
327   327:     wCrc = ~wCrc;
328   328:     T(LEVEL2, printf("\nComplement: %04X", wCrc));
329   329: 
330   330:     wSwap = wCrc;
331   331:     wCrc = (wCrc << 8) | (wSwap >> 8 & 0xFF);
332   332:     T(LEVEL2, printf("\nByte Swap : %04X\n", wCrc));
333   333: 
334   334:     return (wCrc);
335   335: 
336   336: } /* END function wPOSTSETcrc */

XC ... 'C' Concordance Utility   crc.c                      Page 7

337   337: 
338   338: 
339   339: 
340   340: /*+3 MODULE ----------------------------------------------------------------*/
341   341: /*   NAME                          vChkErr                                  */
342   342: /*-- SYNOPSIS --------------------------------------------------------------*/
343   343: PRIVATE void
344   344: vChkErr(eBOOL cond,		   /* Error-condition to check (TRUE=error) */
345   345: 	eERRNO err,		   /* Errornumber if error-condition TRUE */
346   346: 	...			   /* Var. number of args for error-msg. */
347   347: )
348   348: {
349   349: /* DESCRIPTION
350   350:  *    Simple error handler.
351   351:  *    All errors are fatal (ie cause program termination).
352   352:  *    Error messages are written to stderr, and may be redirected to a file.
353   353:  *       Alternatively you might want to log error msg directly in an err-file.
354   354:  *    Error-messages are "hard coded" into array rgpchErrmsg[], -
355   355:  *       In a larger application they would be initialized from a file,
356   356:  *       and moved to its own source module together with function vChkErr().
357   357:  *-3*/
358   358:     va_list   ap;		       /* argument pointer */
359   359: 
360   360:     if (cond) {
361   361: 
362   362: 	/* Print error header identifying module */
363   363: 	fprintf(stderr, "\nMODULE: File[%s] - Line[%d]" \
364   364: 		"\n\tVersion: Date[%s] - Time[%s]" \
365   365: 		"\n\tError..: Number[%02d] - ", \
366   366: 		__FILE__, __LINE__, __DATE__, __TIME__, err);
367   367: 
368   368: 	/* Point ap to 1. var arg, Print error-message & Clean up */
369   369: 	va_start(ap, err);
370   370: 	(void) vfprintf(stderr, rgpchErrmsg[err], ap);
371   371: 	fflush(stderr);
372   372: 	va_end(ap);
373   373: 
374   374: 	/* Exit module */
375   375: 	abort();
376   376:     }
377   377: 
378   378: } /* END function vChkErr */
379   379: 
380   380: 
381   381: 
382   382: /* END module CRC.C                                                         */
383   383: /*==========================================================================*/
384   384: 
XC ... 'C' Concordance Utility                              Page 8

__DATE__            :  366 
__FILE__            :  366 
__LINE__            :  366 
__TIME__            :  366 
abort               :  375 
ap                  :  358  369  370  372 
argc                :  136  207  208 
argv                :  137  208  208  211  212  230  233 
assert              :  279 
atoi                :  208 
BUFSZ               :   95  215  216  226 
BYTE                :  152  161  169  170  171  188  192  193  194  195  196  197  215  250  274 
                      
CRCOK               :   98  179  200 
CRC_ALLOC           :   71 
chBit               :  274  289  290  291 
cond                :  127  344  360 
const               :  120 
DEBUG               :  157 
DWORD               :  153  251  275 
dwCount             :  153  226  229  237  238  275  301  302 
dwLength            :  251  282  304 
EARGS               :  114  207 
EMEM                :  116  216 
EOPEN               :  115  212 
EREAD               :  117  230 
eBOOL               :  103  127  344 
eERRNO              :  118  127  345 
enum                :  100  113 
err                 :  127  345  366  369  370 
exit                :  234 
FILE                :  151 
fFalse              :  101 
fTrue               :  102  223 
feof                :  230 
fflush              :  371 
fopen               :  211 
fprintf             :  174  178  183  189  199  363 
fputs               :  165  167  186 
fread               :  226 
hInFile             :  151  211  212  226  230 
isdigit             :  208 
LEVEL0              :   80  208 
LEVEL1              :   81  163  237 
LEVEL2              :   82  163  301  325  328  332 
LEVEL3              :   83 
level               :   86   88   88 
MAIN                :  131 
main                :  136 
malloc              :  215 
NTRACE              :   85 
NULL                :  171  197  212  216  279 
POLY                :   96  295 
PRESET              :   97  173  177  181  187  198  219  282 
PRIVATE             :  105  120  127  315  343 
PUBLIC              :  249 

XC ... 'C' Concordance Utility                              Page 9

printf              :  233  237  302  302  325  328  332 
pszData             :  250  279  289 
rgchFbuf            :  152  215  216  226  238 
rgchTbuf            :  161  168  169  170  171  175  179  182  184  184  184  188  190  190  192 
                       193  194  195  196  197  200 
rgpchErrmsg         :  120  370 
stderr              :  363  370  371 
stdout              :  165  167  174  178  183  186  189  199 
stmt                :   86   88   88 
strcpy              :  182 
strlen              :  184  190 
T                   :   86   88  237  301  325  328  332 
trace               :   78   88  163  208 
vChkErr             :  127  207  212  216  230  344 
va_end              :  372 
va_list             :  358 
va_start            :  369 
vfprintf            :  370 
void                :  127  135  343  370 
WORD                :  105  106  154  249  252  273  289  315  316  323 
wCCITTcrc           :  175  179  184  190  200  238  250 
wCRC                :  154  173  175  177  179  181  184  187  190  198  200  219  232  232  233 
                       237  238  238 
wCrc                :  106  252  282  283  293  295  295  298  302  302  306  316  325  327  327 
                       328  330  331  331  332  334 
wData               :  273  289  291  293 
wPOSTSETcrc         :  106  175  179  184  190  200  232  316 
wSwap               :  323  330  331 


