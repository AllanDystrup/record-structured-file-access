XC ... 'C' Concordance Utility   ../XRF.C                   Page 1

1       1: /**********************************************************
2       2:       XC  -  A 'C' Concordance Utility
3       3:       Version 1.0   January, 1982
4       4:       Copyright (c) 1982 by Philip N. Hisley
5       5:               Philip N. Hisley
6       6:               548H Jamestown Court
7       7:               Edgewood, Maryland 21040
8       8:               (301) 679-4606
9       9: 
10     10:       Released for non-commercial distribution only
11     11:       Converted to IBM/PC CI/C86 by David N. Smith, May/June 1983
12     12:       with enhancements and Lattice compiler support in Dec. 1983.
13     13:               David N. Smith
14     14:               44 Ole Musket Lane
15     15:               Danbury, CT 06810
16     16:               (203) 748-5934
17     17: 
18     18:       Changes Copyright (c) 1983 by David N. Smith
19     19:       PC Enhancements include:
20     20:            1)  Nested #INCLUDE statements
21     21:            2)  Single spaced cross-reference list
22     22:            3)  Removal of tabbing on output device
23     23:                (Since many printers don't support it)
24     24:            4)  #INCLUDE statements with both "--" and <-->
25     25:                syntax and with a full fileid in the quotes.
26     26:            5)  Multiple input filenames on command line.
27     27: 
28     28:         // -------------------------------------------------------
29     29:         Changes (no copyright) Feb. 2026 by Allan Dystrup [AD]
30     30:         Ported to C11 on WSL Ubuntu LINUX:
31     31:             1) #included some C11 header files
32     32:             2) defined function prototypes
33     33:             3) increased some const values (MAX_REF, MAX_ALPHA)
34     34:             4) some optional DEBUG output to troubleshoot faults
35     35:             5) removed deprecated 'Lattice' compiler support
36     36:             5) a bit of code reformatting, to make it (sort of) read
           able
37     37:             DISCLAIMER: The code does what is described in the Abstr
           act
38     38:             BUT: It needs restructuring and robust memory handling!
39     39:         // --------------------------------------------------------
40     40: 
41     41:       Abstract:
42     42:       'XC' is a cross-reference utility for 'C' programs.
43     43:       Its has the ability to handle nested include files
44     44:       to a depth of 8 levels and properly processes nested
45     45:       comments as supported by BDS C. Option flags support
46     46:       the following features:
47     47:       - Routing of list output to disk
48     48:       - Cross-referencing of reserved words
49     49:       - Processing of nested include files
50     50:       - Generation of listing only
51     51:       Usage: xc <filename> <flag(s)>
52     52:       Flags: -i            = Enable file inclusion
53     53:              -l            = Generate listing only
54     54:              -r            = Cross-ref reserved words

XC ... 'C' Concordance Utility   ../XRF.C                   Page 2

55     55:              -o <filename> = Write output to named file
56     56: ***********************************************************/
57     57: 
58     58: #include <stdio.h>
59     59: #include <stdlib.h>
60     60: #include <string.h>
61     61: #include <ctype.h>
62     62: 
63     63: //#define DEBUG
64     64: #ifdef DEBUG
65     65: #   define  D(x) x              /* define debug trace */
66     66: #   else
67     67: #   define  D(x)                /* ignore debug trace  */
68     68: #endif  /* DEBUG */
69     69: 
70     70: #ifndef  TRUE
71     71: #define  TRUE        1
72     72: #define  FALSE       0
73     73: #endif
74     74: 
75     75: // Const Values (Redefined [AD] ------------------------------------
           -------
76     76: #define  ERROR      -1
77     77: #define  MAX_REF     40       /* maximum refs per ref-block */
78     78: #define  MAX_LEN     20       /* maximum identifier length  */
79     79: #define  MAX_WRD    749       /* maximum number of identifiers */
80     80: #define  MAX_ALPHA  200       /* maximum alpha chain heads */
81     81: #define  REFS_PER_LINE  10    /* maximum refs per line */
82     82: #define  LINES_PER_PAGE 60
83     83: #define  MAXCOL     78         /* default maximum column number for 
           listing line */
84     84: #define  MINCOL     30         /* minimum value for -w option */
85     85: #define  FF         0x0C       /* formfeed */
86     86: 
87     87: 
88     88: // Structure types -------------------------------------------------
           -------
89     89: struct  rf_blk {
90     90:                  int  ref_item[MAX_REF];
91     91:                  int  ref_cnt;
92     92:                } onerf;
93     93: 
94     94: struct  id_blk {
95     95:                  char  id_name[MAX_LEN];
96     96:                  struct id_blk *alpha_lnk;
97     97:                  struct rf_blk *top_lnk;
98     98:                  struct rf_blk *lst_lnk;
99     99:                } oneid;
100   100: 
101   101: struct id_blk *id_vector[MAX_WRD];
102   102: 
103   103: struct alpha_hdr { struct id_blk *alpha_top;
104   104:                    struct id_blk *alpha_lst;
105   105:                  };
106   106: 
107   107: struct alpha_hdr alpha_vector[MAX_ALPHA];

XC ... 'C' Concordance Utility   ../XRF.C                   Page 3

108   108: 
109   109: 
110   110: // Global Variables (Hmmmmm...) ------------------------------------
           ----
111   111: int     linum;          /* line number */
112   112: int     edtnum;         /* edit line number */
113   113: int     fil_cnt;        /* active file index */
114   114: int     wrd_cnt;        /* token count */
115   115: int     pagno;          /* page number */
116   116: int     id_cnt;         /* number of unique identifiers */
117   117: int     rhsh_cnt;       /* number of conflict hits */
118   118: int     filevl;         /* file level  */
119   119: int     paglin;         /* page line counter */
120   120: int     dummy;          /* dummy integer */
121   121: int     maxcol=MAXCOL;  /* maximum right column for listing line */
122   122: int     prt_ref;
123   123: char    act_fil[MAX_LEN];
124   124: char    lst_fil[MAX_LEN];
125   125: char    gbl_fil[MAX_LEN];
126   126: FILE    *f_lst_fil;
127   127: int     i_flg,
128   128:         o_flg,
129   129:         r_flg,
130   130:         l_flg;
131   131: //long atoi();
132   132: 
133   133: char*   MyAlloc(int i);   // malloc "i" # bytes
134   134: 
135   135: 
136   136: 
137   137: // Function prototypes (AD) ----------------------------------------
           ---------
138   138: void    use_err();
139   139: char*   MyAlloc(int i);             // malloc "i" # bytes
140   140: int     proc_file(char*, int);
141   141: void    prnt_tbl();
142   142: int     lst_err();
143   143: void    get_include_fileid(char*, FILE*);
144   144: int     chk_token(char*);
145   145: void    nl();
146   146: void    prt_hdr();
147   147: int     get_token(FILE*, char*, int*, int*, int);
148   148: void    put_token(char*, int);
149   149: void    echo(char);
150   150: void    echochar(char);
151   151: char    rdchr(FILE*, int*, int);
152   152: int     fil_chr(FILE*, int*);
153   153: void    chain_alpha(struct id_blk*, char*);
154   154: int     abs(int);
155   155: 
156   156: 
157   157: 
158   158: /*******************************************************************
           ******/
159   159: /*                              MAIN                                
                */

XC ... 'C' Concordance Utility   ../XRF.C                   Page 4

160   160: /*******************************************************************
           ******/
161   161: int
162   162: main(p_argc, p_argv)
163   163:     int     p_argc;
164   164:     char    **p_argv;
165   165: {
166   166:     // ARGUMENT PARSING ============================================
           =======
167   167:     char  *arg;
168   168:     int argc;
169   169:     char **argv;
170   170:     char c;
171   171:     int i;
172   172:     argc = p_argc;
173   173:     argv = p_argv;
174   174:     if (argc < 2) use_err();
175   175:     i_flg=r_flg=o_flg=l_flg=FALSE;
176   176: 
177   177:     while(--argc != 0)
178   178:      { if(*(arg=*++argv) == '-')
179   179:         {switch(*++arg)
180   180:          {
181   181:            case 'i':
182   182:            case 'I': i_flg++;
183   183:                      break;
184   184:            case 'r':
185   185:            case 'R': r_flg++;
186   186:                      break;
187   187:            case 'l':
188   188:            case 'L':  l_flg++;
189   189:                       break;
190   190:            case 'o':
191   191:            case 'O': { o_flg++;
192   192:                        if(--argc == 0) use_err();
193   193:                        strcpy(lst_fil,*++argv);
194   194:                        if(lst_fil[0] == '-') use_err();
195   195:                         break;}
196   196:            case 'w':
197   197:            case 'W': { if(--argc == 0) use_err();
198   198:                        i = atoi(*++argv);
199   199:                        if( i<=MINCOL || i>=255 ) use_err();
200   200:                        maxcol = i;
201   201:                        break;
202   202:                        }
203   203:            default: use_err();
204   204:          }
205   205:        }
206   206:      }
207   207: 
208   208: 
209   209:     // OUTPUT FILE  ================================================
           ===
210   210:      if(o_flg)
211   211:        {if( (f_lst_fil=fopen(lst_fil,"w")) == NULL)
212   212:         { printf("ERROR: Unable to create list file - %s\n",lst_fil)
           ;

XC ... 'C' Concordance Utility   ../XRF.C                   Page 5

213   213:           exit(0);}
214   214:        printf("XC ... 'C' Concordance Utility  v1.0\n\n");
215   215:         }
216   216:     prt_ref = FALSE;
217   217: 
218   218: 
219   219:     // INPUT FILE  =================================================
           ==
220   220:     for(linum=0;linum < MAX_WRD;linum++) {
221   221:        id_vector[linum] = NULL; }
222   222: 
223   223:     for(linum=0;linum < MAX_ALPHA;linum++)
224   224:      {
225   225:        alpha_vector[linum].alpha_top =
226   226:        alpha_vector[linum].alpha_lst = NULL;
227   227:      }
228   228: 
229   229:     fil_cnt = wrd_cnt = linum = 0;
230   230:     filevl=paglin=pagno=edtnum=0;
231   231:     id_cnt=rhsh_cnt=0;
232   232:     argc = p_argc;  argc--;
233   233:     argv = p_argv;
234   234: 
235   235:     while(argc--) {
236   236:        strcpy(gbl_fil,*++argv);
237   237:        if(*gbl_fil == '-')  break;
238   238:        proc_file(gbl_fil,dummy);
239   239:        }
240   240: 
241   241:     if(!l_flg) {
242   242:       gbl_fil[0] = '\0';
243   243:       prnt_tbl();
244   244:       printf("\nAllowable Symbols: %d\n",MAX_WRD);
245   245:       printf("Unique    Symbols: %d\n",id_cnt);}
246   246: 
247   247:     if(o_flg) {
248   248:      nl();
249   249:      /* if(fprintf(f_lst_fil,"%c",CPMEOF) == ERROR) lst_err(); */
250   250:      fclose(f_lst_fil);
251   251:     }
252   252: }
253   253: 
254   254: 
255   255: /*******************************************************************
           ******/
256   256: int
257   257: lst_err()
258   258: { printf("\nERROR: Write error on list output file - %s\n",
259   259:    lst_fil);
260   260:   exit(0);
261   261: }
262   262: 
263   263: 
264   264: /*******************************************************************
           ******/
265   265: void

XC ... 'C' Concordance Utility   ../XRF.C                   Page 6

266   266: use_err()
267   267:        { printf("\nERROR: Invalid parameter specification\n\n");
268   268:        printf("Usage: xc <filename>... <flag(s)>\n\n");
269   269:        printf("Flags: -i            = Enable file inclusion\n");
270   270:        printf("       -l            = Generate listing only\n");
271   271:        printf("       -r            = Cross-reference reserved words
           \n");
272   272:        printf("       -o <outfile>  = Write output to named file\n")
           ;
273   273:        printf("       -w width      = Width of output page; default=
           78\n");
274   274:        printf("Flags must follow all input file names");
275   275:        exit(0); }
276   276: 
277   277: 
278   278: /*******************************************************************
           ******/
279   279: int
280   280: proc_file(filnam,incnum)
281   281: char    *filnam;
282   282: int      incnum;        /* prev. included line number (return to cal
           ler) */
283   283: {
284   284:   char  token[MAX_LEN]; /* token buffer */
285   285:   int   eof_flg;        /* end-of-file indicator */
286   286:   int   tok_len;        /* token length */
287   287:   FILE  *infile;        /* input file */
288   288:   strcpy(act_fil,filnam);
289   289:   edtnum=0;
290   290:   if((infile=fopen(filnam,"r")) == NULL)
291   291:       {printf("\nERROR: Unable to open input file: %s\n",filnam);
292   292:         return 0;}  /* ignore error */
293   293: 
294   294:   if(filevl++ == 0) prt_hdr();
295   295:   eof_flg = FALSE;
296   296:   do {
297   297:        if(get_token(infile,token,&tok_len,&eof_flg,0))
298   298:           if(chk_token(token))
299   299:              {
300   300:              if(strcmp(token,"#include") == 0)
301   301:                 {
302   302:                 get_include_fileid(token,infile);
303   303:                 if(!i_flg) continue;
304   304:                 else
305   305:                    {
306   306:                    nl();
307   307:                    edtnum=proc_file(token,edtnum);
308   308:                    strcpy(act_fil,filnam);
309   309:                    continue;
310   310:                    }
311   311:                 }
312   312:             put_token(token,linum);
313   313:             }
314   314:      } while (!eof_flg);
315   315:      filevl -= 1;
316   316:      fclose(infile);

XC ... 'C' Concordance Utility   ../XRF.C                   Page 7

317   317:      return( incnum );
318   318: }
319   319: 
320   320: 
321   321: /*******************************************************************
           ******/
322   322: void
323   323: get_include_fileid(token,infile)
324   324: 	char *token;
325   325: 	FILE *infile;
326   326: {
327   327:    char c, term;
328   328:    while ( (term=getc(infile)) == ' ' )  echo(term);
329   329:    echo(term);
330   330:    if ( term=='<' ) term='>';   /* terminator is > or " */
331   331:    if ( (term!='>') && (term!='"') )
332   332:       {
333   333:       printf("Error scanning #INCLUDE fileid: %c\n", term);
334   334:       exit(1);
335   335:       }
336   336:    do {
337   337:       if ( (c = getc(infile)) != ' ')
338   338:          {
339   339:          *token++ = c;
340   340:          echo(c);
341   341:          }
342   342:       else
343   343:          echo(c);
344   344:       }
345   345:       while ( c!=term );
346   346:    *--token = '\0';
347   347: }
348   348: 
349   349: 
350   350: /*******************************************************************
           ******/
351   351: void
352   352: echo(c)
353   353: 	char c;
354   354: {
355   355:    static int col = 11;
356   356:    int i;
357   357:    echochar(c);
358   358:    if( c == '\n' )
359   359:       col = 11;
360   360:    else if( ++col > maxcol )  {
361   361:       col = 11;
362   362:       paglin++;
363   363:       echochar('\n');
364   364:       for( i=1; i<=11; i++ )  echochar(' ');
365   365:       }
366   366: }
367   367: 
368   368: void
369   369: echochar(c)
370   370: char c;

XC ... 'C' Concordance Utility   ../XRF.C                   Page 8

371   371: {
372   372:    if(o_flg)  {
373   373:       if(fprintf(f_lst_fil,"%c",c) == ERROR)  lst_err();
374   374:       }
375   375:    else
376   376:       printf("%c",c);
377   377: }
378   378: 
379   379: 
380   380: /*******************************************************************
           ******/
381   381: int
382   382: get_token(infile,g_token,g_toklen,g_eoflg,g_flg)
383   383: FILE    *infile;
384   384: char    *g_token;
385   385: int     *g_toklen;
386   386: int     *g_eoflg;
387   387: int     g_flg;
388   388: /*
389   389:         'getoken' returns the next valid identifier or
390   390:         reserved word from a given file along with the
391   391:         character length of the token and an end-of-file
392   392:         indicator
393   393: */
394   394: {
395   395: int     c;
396   396: char    *h_token;
397   397: char    tmpchr;
398   398: h_token = g_token;
399   399: gtk:
400   400: *g_toklen = 0;
401   401: g_token = h_token;
402   402: /*
403   403:         Scan and discard any characters until an alphabetic or
404   404:         '_' (underscore) character is encountered or an end-of-file
405   405:         condition occurs
406   406: */
407   407: 
408   408: while( (!isalpha(*g_token = rdchr(infile,g_eoflg,g_flg)))
409   409:   && !*g_eoflg
410   410:   && *g_token != '_'
411   411:   && *g_token != '0'
412   412:   && *g_token != '#');
413   413: if(*g_eoflg) return(FALSE);
414   414: *g_toklen += 1;
415   415: /*
416   416:         Scan and collect identified alpanumeric token until
417   417:         a non-alphanumeric character is encountered or and
418   418:         end-of-file condition occurs
419   419: */
420   420: if(g_flg) tmpchr = '.';
421   421:      else tmpchr = '_';
422   422: 
423   423: while( (isalpha(c=rdchr(infile,g_eoflg,g_flg))
424   424:         || isdigit(c)
425   425:         || c == '_'

XC ... 'C' Concordance Utility   ../XRF.C                   Page 9

426   426:         || c == tmpchr)
427   427:      && !*g_eoflg)
428   428:         {
429   429:          if(*g_toklen < MAX_LEN)
430   430:           { *++g_token = c;
431   431:           *g_toklen += 1; }
432   432:         }
433   433: /*
434   434:         Check to see if a numeric hex or octal constant has
435   435:         been encountered ... if so dump it and try again
436   436: */
437   437:         if (*h_token == '0') goto gtk;
438   438: /*
439   439:         Tack a NULL character onto the end of the token
440   440: */
441   441:  *++g_token = NULL;
442   442: /*
443   443:         Screen out all #token strings except #include
444   444: */
445   445: if (*h_token == '#' && strcmp(h_token,"#include")) goto gtk;
446   446:  return(TRUE);
447   447: }
448   448: 
449   449: /*******************************************************************
           ******/
450   450: int
451   451: fil_chr(infile,f_eof)
452   452:     FILE *infile;
453   453:     int *f_eof;
454   454:    {
455   455:     int fc;
456   456:     fc=getc(infile);
457   457: 
458   458:     if (fc == EOF) {
459   459:         *f_eof = TRUE;
460   460:         fc = (int) NULL;
461   461:     }
462   462:     return(fc);
463   463: }
464   464: 
465   465: 
466   466: /*******************************************************************
           ******/
467   467: char
468   468: rdchr(infile,r_eoflg,rd_flg)
469   469: int     *r_eoflg;
470   470: FILE    *infile;
471   471: int     rd_flg;
472   472: /*
473   473:         'rdchr' returns the next valid character in a file
474   474:         and an end-of-file indicator. A valid character is
475   475:         defined as any which does not appear in either a
476   476:         commented or a quoted string ... 'rdchr' will correctly
477   477:         handle comment tokens which appear within a quoted
478   478:         string
479   479: */

XC ... 'C' Concordance Utility   ../XRF.C                   Page 10

480   480: {
481   481: int     c;
482   482: int     q_flg;          /* double quoted string flag */
483   483: int     q1_flg;         /* single quoted string flag */
484   484: int     cs_flg;         /* comment start flag */
485   485: int     ce_flg;         /* comment end flag */
486   486: int     c_cnt;          /* comment nesting level */
487   487: int     t_flg;          /* transparency flag */
488   488: q_flg = FALSE;
489   489: q1_flg = FALSE;
490   490: cs_flg = FALSE;
491   491: ce_flg = FALSE;
492   492: t_flg = FALSE;
493   493: c_cnt  = 0;
494   494: rch:
495   495: /*
496   496:         Fetch character from file
497   497: */
498   498: c=fil_chr(infile,r_eoflg);
499   499: if(*r_eoflg) return(c);   /* EOF encountered */
500   500: if(c == '\n')
501   501:                 nl();
502   502:              else
503   503:                 echo(c);
504   504: if(rd_flg) return(c);
505   505: if(t_flg) { t_flg = !t_flg;
506   506:             goto rch;}
507   507: if(c == '\\') { t_flg = TRUE;
508   508:                 goto rch;}
509   509: /*
510   510:         If the character is not part of a quoted string
511   511:         check for and process commented strings...
512   512:         nested comments are handled correctly but unbalanced
513   513:         comments are not ... the assumption is made that
514   514:         the syntax of the program being xref'd is correct
515   515: */
516   516: if (!q_flg && !q1_flg) {
517   517:      if (c == '*' && c_cnt && !cs_flg) { ce_flg = TRUE;
518   518:                       goto rch;}
519   519:      if (c == '/' && ce_flg) { c_cnt -= 1;
520   520:                           ce_flg = FALSE;
521   521:                           goto rch; }
522   522:      ce_flg = FALSE;
523   523:      if (c == '/') { cs_flg = TRUE;
524   524:                 goto rch; }
525   525:      if (c == '*' && cs_flg) { c_cnt += 1;
526   526:                           cs_flg = FALSE;
527   527:                           goto rch; }
528   528:      cs_flg = FALSE;
529   529:      if (c_cnt) goto rch;
530   530: }
531   531: /*
532   532:         Check for and process quoted strings
533   533: */
534   534: if ( c == '"' && !q1_flg) { q_flg =  !q_flg; /* toggle quote flag */
           

XC ... 'C' Concordance Utility   ../XRF.C                   Page 11

535   535:                         goto rch;}
536   536: if (q_flg) goto rch;
537   537: if (c == '\'') { q1_flg = !q1_flg; /* toggle quote flag */
538   538:                 goto rch; }
539   539: if (q1_flg) goto rch;
540   540: /*
541   541:         Valid character ... return to caller
542   542: */
543   543: return(c);
544   544: }
545   545: 
546   546: 
547   547: /*******************************************************************
           ******/
548   548: int
549   549: chk_token(c_token)
550   550: char    *c_token;
551   551: {
552   552:   char  u_token[MAX_LEN];
553   553:   int   i;
554   554:     {
555   555:       if(r_flg) return(TRUE);
556   556:       i = 0;
557   557:       do { u_token[i] = toupper(c_token[i]); }
558   558:          while (c_token[i++] != NULL);
559   559:       switch(u_token[0]) {
560   560:         case 'A': if (strcmp(u_token,"AUTO") == 0) return(FALSE);
561   561:                   break;
562   562:         case 'B': if (strcmp(u_token,"BREAK") == 0) return(FALSE);
563   563:                   break;
564   564:         case 'C': if (strcmp(u_token,"CHAR") == 0) return (FALSE);
565   565:                   if (strcmp(u_token,"CONTINUE") == 0) return (FALSE
           );
566   566:                   if (strcmp(u_token,"CASE") == 0) return (FALSE);
567   567:                   break;
568   568:         case 'D': if(strcmp(u_token,"DOUBLE") == 0) return(FALSE);
569   569:                   if(strcmp(u_token,"DO") == 0) return(FALSE);
570   570:                   if(strcmp(u_token,"DEFAULT") == 0) return(FALSE);
571   571:                   break;
572   572:         case 'E': if(strcmp(u_token,"EXTERN") == 0) return(FALSE);
573   573:                   if(strcmp(u_token,"ELSE") == 0) return(FALSE);
574   574:                   if(strcmp(u_token,"ENTRY") == 0) return(FALSE);
575   575:                   break;
576   576:         case 'F': if(strcmp(u_token,"FLOAT") == 0) return(FALSE);
577   577:                   if(strcmp(u_token,"FOR") == 0) return(FALSE);
578   578:                   break;
579   579:         case 'G': if(strcmp(u_token,"GOTO") == 0) return(FALSE);
580   580:                   break;
581   581:         case 'I': if(strcmp(u_token,"INT