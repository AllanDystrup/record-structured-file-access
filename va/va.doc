




Sat Feb 21 10:26:55 CET 2026
CCITT CRC (REVERSE) for     va.h   is	[7FFA]





######  #######  #####
#     # #     # #     #
#     # #     # #
#     # #     # #
#     # #     # #
#     # #     # #     #
######  #######  #####



 #####   #####   #####

 #####   #####   #####









 #    #    ##            #    #
 #    #   #  #           #    #
 #    #  #    #          ######
 #    #  ######   ###    #    #
  #  #   #    #   ###    #    #
   ##    #    #   ###    #    #






/*+1========================================================================*/
/*   MODULE                       VA.H                                      */
/*==========================================================================*/
/*   FUNCTION      Header file for module VA.C (and user modules);
 *                 #include this file for access to PUBLIC virtual array (VA)
 *                 functions defined in VA.C.
 *
 *   SYSTEM        Standard (ANSI/ISO) C,
 *                 Tested on PC/MS DOS 3.3 (MSC 600A) & UNIX SYS V3 (GNU GCC)
 *
 *   SEE ALSO      Modules : GENERAL.H, ACCESS.H, VA.C
 *
 *   PROGRAMMER    Allan Dystrup
 *
 *   COPYRIGHT     (c) Allan Dystrup, Kommunedata I/S, Feb. 1992
 *
 *   VERSION       $Header: d:/cwork/index/RCS/va.h 0.1 92/07/06 09:41:24
 *                 Allan_Dystrup PREREL Locker: Allan_Dystrup $
 *                 ----------------------------------------------------------
 *                 $Log:	va.h $
 *                 Revision 0.1  92/07/06  09:41:24  Allan_Dystrup
 *                 PREREL (ALFA1)
 *
 *-1========================================================================*/Sat Feb 21 10:26:55 CET 2026
CCITT CRC (REVERSE) for     va.h   is	[7FFA]






END EXTRACTION






Sat Feb 21 10:26:55 CET 2026
CCITT CRC (REVERSE) for     va.c   is	[2555]





######  #######  #####
#     # #     # #     #
#     # #     # #
#     # #     # #
#     # #     # #
#     # #     # #     #
######  #######  #####



 #####   #####   #####

 #####   #####   #####









 #    #    ##             ####
 #    #   #  #           #    #
 #    #  #    #          #
 #    #  ######   ###    #
  #  #   #    #   ###    #    #
   ##    #    #   ###     ####






/*+1========================================================================*/
/* MODULE                         VA.C                                      */
/*==========================================================================*/
/* FUNCTION    Toolbox for building virtual arrays (arrays as disk-files with
 *             automatic caching in RAM). This module contains a collection
 *             of basic routines for : creating, accessing and maintaining
 *             index'es for very fast access to simple datafiles.
 *             A datafile must be record-structured (arbitrary record size)
 *             with each record identified by a unique NUMERIC key-value.
 *
 * SYSTEM      Standard Ansi C.
 *             Tested on PC/MS DOS V.3.3 (MSC 6.0A) & UNIX SYS V.3 (GNU GCC).
 *
 * SEE ALSO    Modules:
 *             GENERAL.H, ACCESS.H, VA.H for macros & errorhandling
 *             INDEX.C/H ............... for building index'es from datafiles.
 *             KEY.C/H ................. for accessing datarec's via index'es.
 *
 * PROGRAMMER  Allan Dystrup
 *
 * COPYRIGHT   (c) Allan Dystrup, Kommunedata I/S February 1992.
 *
 * VERSION     $Header: d:/cwork/index/RCS/va.c 0.1 92/07/06 09:42:13
 *             Allan_Dystrup PREREL Locker: Allan_Dystrup $
 *             --------------------------------------------------------------
 *             $Log:	va.c $
 *             Revision 0.1  92/07/06  09:42:13  Allan_Dystrup
 *             PREREL (ALFA1)
 *
 * REFERENCES  Mark Tichenor[1988] : "Virtual Arrays in C"
 *             Dr. Dobb's Journal, May 1988.
 *
 * USAGE       Module va.c features the following public routines for
 *             building and working with indexfiles; - See headerfile va.h
 *             and the function documentation for a detailed description of
 *             the user accesible datastructures and interface functions.
 *                 eVAIdxCreate()        // Create a new indexfile
 *                 eVAIdxOpen()          // Open an existing indexfile
 *                 eVAIdxClose()         // Close an open indexfile
 *
 *                 eVAeyInsert()         // Insert new (key,offset) in index
 *                 eVAKeyDelete()        // Delete (key,offset) from index
 *                 eVAKeyFind()          // Look up (key,offset) in index
 *
 *                 eVAIdxGetLoad()       // Get loadfactor for open indexfile
 *                 eVAIdxGetSize()       // Get size for open indexfile
 *
 * DOC         Documentation is incorporated into the module and may be
 *             selectively extracted (using a utility such as ex.awk) :
 *                Level 1: Module documentation (history, design, testdriver)
 *                Level 2: PUBLIC functions (module program interface, "API")
 *                Level 3: major PRIVATE functions (design)
 *                Level 4: minor PRIVATE functions (support)
 *
 * BUGS        The module is coded in STANDARD C (ANSI/ISO), which is a
 *             feature! -  It is however prepared to compile under "old"
 *             K&R C (if you prefer bugs ...)
 *             The errorchecking of file I/O is rather "slack" for max speed.
 *
 * =========================== VIRTUAL ARRAYS ================================
 *
 * A Virtual Array (VA) is stored on disk, but accessed as though it was in
 * memory. This functionality is obtained by providing a set of access-
 * functions with built-in file management : When a value is assigned to an
 * array-element and when an array-element is referenced in an expression,
 * data is automatically written-to/read-from the corresponding VA file-record.
 * Thus the user never performs any explicit reads/writes on a VA.
 *
 * To minimize disk I/O the access-functions pass their record read/write-
 * operations through a cache buffer.
 *
 * The extremely simple access strategy of VA's can be used in building index-
 * files based on direct lookup : datafile-offset = VA[keyvalue]. This method
 * however is only feasible for datafiles with numeric key-values. Note that
 * the indexfile will be relatively large, when the keyvalue-range is big and
 * the datafile-records small; - For sparse keyvalues a scatter-storage (HASH)
 * technique should be preferred, unless very fast access is important.
 *
 *
 * =========================== MODULE STRUCTURE ==============================
 *
 *                                 Data Model
 * To define a Virtual Array (VA) on disk and in core we need some datastruct's
 * for size- & statusinfo (one HEADER-record) and for array element values
 * (multiple KEY-records). These data must be maintained both external and in
 * RAM. The appropriate data-structs. are defined in the include-file VA.H.
 *
 * (1) Header-record layout
 *                           RAM (incore)
 *                           struct stVACore (*VACB)
 *                           +---------------------+ FILE:
 *                           | enum     indexmode  | Open mode [RO | RW]
 *                           | FILE     *pfArFile  | Handle for VA file
 *             +---------------SIZEINFO stSize     | VA file size info.
 *             |             |                     | CACHE:
 *             |             | WORD wBfSize        | #rec's in VA buf. (BFSIZE)
 *             |             | WORD wBfElSize      | #bytes in VA buf-elem.
 *             |             | char *pcBf-------+  | Ptr. to VA cache-buf.
 *             |             | char *pcArElInit |  | Ptr. to (last) blank rec.
 *             |             +------ | -------- | -+
 *             |                     |          |
 *             |                     |          |   VA Cache buffer (malloc'ed)
 *             |                     |          |   Rec#  Rec.Contents
 *             |                     |          |   +-----+--------------------+
 *             |                     |        0 +-->|DWORD: <occupied slot>    |
 *             |                     |              +-----+--------------------+
 *             |                     |        1     |EMPTY: <empty slot>       |
 *             |                     |              +-----+--------------------+
 *             |                     |        :     :     :                    :
 *             |                     |              +-----+--------------------+
 *             |                     |     BFSIZE   |DWORD| <occupied slot>    |
 *             |                     |     ---------+-----+--------------------+
 *             |                     +---->BFSIZE+1 | --- | initialization rec |
 *             |                           ---------+-----+--------------------+
 *     DISK (external) HEADER
 *     struct stVAsize (SIZEINFO)
 *     +-----------------+
 *     | DWORD dwArSize  | #key-rec's total in VA file
 *     | DWORD dwArUsed  | #key-rec's used in VA file
 *     | WORD  wArElSize | #bytes in each key-rec
 *     | char  cFill	 | Fill char for empty rec
 *     +-----------------+
 *
 *
 * (2) Key-record layout (default)
 *
 *     DISK (external)
 *     struct stVArec (REC)
 *     +-----------------+
 *     | DWORD  offset	 | map VA[keyvalue]->FileOffset
 *     +-----------------+ (value:EMPTY if not defined)
 *
 *
 *                         Function decomposition
 * The functions to generate and access these data structures may be grouped
 * into 2 separate levels :
 * [1] HIGH LEVEL (INDEX INTERFACE)
 *     Application functions built "on top of" the basic VA-functionality.
 *     In this module we build an index interface (Hdr- & Key-rec. operations),
 *     - you may easily extend or substitute these for new purposes.
 * [2] LOW LEVEL (VIRTUAL ARRAY INTERFACE)
 *     Basic Virtual Array (VA) functions, - these constitute a stable set of
 *     utilities to generate, maintain and access VA-files on disk.
 *
 * The main calling hierachy is outlined in the following diagram :
 *
 *                    (1) Index operations
 *
 *      (1.1)                          (1.2)
 *      Index Header operations        Index Key operations
 *
 *      eVAIdxCreate                    eVAKeyInsert----+
 *       | eVAIdxOpen                   eVAKeyDelete--->+
 *       |  | eVAIdxClose               eVAKeyFind----->+-----------+
 *       |  |          |                                |           |
 *       |  |          |                           [RW] |      [RO] |
 *       |  |          |                                |           |
 *       |  |          |                                |           |
 *   ... |  | ........ | .............................. | ......... | ...
 *       |  |          |                                |           |
 *       |  |          |       (2) Virtual Array        |           |
 *       |  |          |                                |           |
 *       |  |          |       (2.1)                    |           |
 *       |  |          |       VA high-level I/O        |           |
 *       |  |          |       MACRO'S                  |           |
 *       |  |          |                          dwAOFF(pVA,dw)  dwROFF(pVA,dw)
 *       |  |          |                                |           |
 *       |  |          |                          pAREC(pVA,dw)   pRREC(pVA,dw)
 *       |  |          |       (2.2)                    |           |
 *       |  |          |       VA low-level I/O         |           |
 *       |  |          |       FUNC'S                   |           |
 *       +--|->iVAinit |                          pvVAaccess      pvVAread
 *       +->+->pVAopen |
 *          iVAclose<--+
 *
 *-1========================================================================*/Sat Feb 21 10:26:55 CET 2026
CCITT CRC (REVERSE) for     va.c   is	[2555]

/*+1 MODULE VA.C ===========================================================*/
/*   NAME   01                     main                                     */
/*== SYNOPSIS ==============================================================*/
int REAL_MAIN()
{
/* DESCRIPTION
 *   Testdriver for module va.c; - exercises the functions in the module
 *   and validates the functionality through trace-statements (when compiled
 *   with flag "DEBUG").
 *
 *   1: Print signon message & setup to catch "break" signals.
 *
 *   2: MAKE and fill a new VirtualArray (VA) ... :
 *      2.1: Try creating & opening new VA file, mode RW (init header), -
 *           actions 2.x are skipped, if the VA-file already exists
 *      2.2: Create dwArSize VA elements (in chunks of STEP)
 *      2.3: Delete elements #10-#19 in VA
 *      2.4: Try Re-initializing duplicate & deleted elements
 *      2.5: Close VA gracefully (flush cache to disk & release resources)
 *
 *   3: TEST the Virtual Array (VA) by looking up entries in the VA file ... :
 *      3.1: Open existing VA file, mode RO
 *      3.2: Print VA statistics
 *      3.3: Access all elements of the VA
 *      3.4: Close VA gracefully (flush cache to disk & release resources)
 *
 * RETURN
 *   main() is a testdriver and not intented to interface with any calling
 *   program. The return value from main() is thus insignificant in this
 *   context.
 *   You should however notice the checking of error-conditions on return
 *   from each call to a PUBLIC function defined in va.c; - This practice
 *   should also be followed in your application to "catch" and diagnose any
 *   malfunction in the system or in the services provided by this module.
 *   (You will probably want to write your own error-handling, though).
 *
 * EXAMPLE
 *   The contents of function main() demonstrates the basic aspects of
 *   building and accessing a VirtualArray using the *LOW LEVEL* public data-
 *   structures and interface-functions in VA.C/H.
 *   The modules INDEX.C/H and KEY.C/H provides more *HIGL LEVEL* interfaces
 *   for generating and using indexfiles from application programs.
 *
 * SEE ALSO
 *   general.h, access.h & va.h for a detailed description of symbolic constants,
 *   macro's, data structures, return codes and error codes.
 *-1*/Sat Feb 21 10:26:55 CET 2026
CCITT CRC (REVERSE) for     va.c   is	[2555]

/*+4 MODULE HASH.C ---------------------------------------------------------*/
/*   NAME   01.01                 vSigCatch                                 */
/*-- SYNOPSIS --------------------------------------------------------------*/
#define    MAXLINE 81

PRIVATE void
vSigCatch(iSigNum)
    int       iSigNum;	       /* Signal number to catch */
{
/* DESCRIPTION
 *    Support function for main() test driver.
 *    Signal handler set up to catch the "break" signals : SIGINT (asynch.
 *    interactive attention) & SIGTERM (asynch. interactive termination).
 *    1: Prompts user for break confirmation
 *    2: Depending on user confirmation : [Y]->terminate or [N]->continue... :
 *       2.1: Terminates program "gracefully" (using global VA file descr.)
 *       2.2: Continues : eat rest of line, reset signal, and continue.
 * RETURN
 *    If break confirmed: program terminated with exit code 'EXIT_FAILURE'
 *    else: signal 'iSigNum' reset and program execution resumed.
 * BUGS
 *    Asynch. signals don't guarantee access to volatile data at sequence pts;
 *    Since we restrict our access to READ operations, this shouldn't pose any
 *    problem, - though not strictly ANSI (cf. type sig_atomic_t).
 *-4*/Sat Feb 21 10:26:55 CET 2026
CCITT CRC (REVERSE) for     va.c   is	[2555]

/*+2 MODULE VA.C ===========================================================*/
/*   NAME   02                     eVAIdxCreate                             */
/*== SYNOPSIS ==============================================================*/
PUBLIC    eRetType
eVAIdxCreate(ppVA, pzIdxFile, dummy1, dummy2)
    VACB     *ppVA;	       /* Handle for VA index descr.struct to create */
    char     *pzIdxFile;       /* Name of physical Virtual Array index (file) */
    WORD      dummy1;	       /* Dummy argument, - ignored */
    DWORD     dummy2;	       /* Dummy argument, - ignored */
{
/* DESCRIPTION
 *    Creates (and opens) a VirtualArray file in the current directory on
 *    disk with the name of "pzIdxFile" and mode Read/Write. A header with
 *    VA size-info (initially all zero) is written to the file, and an incore
 *    descriptor structor for VA (VACB) is set up with handle ppVA.
 *
 *    1: Call iVAinit() to create new VA-file, write header & close file.
 *    2: Call eVAIdxOpen() to (re)open the VA-file and set up an incore VACB.
 *
 * RETURN
 *    Side effects (netto).: VirtualArray file created & opened.
 *                           Incore VACB allocated & initialized.
 *    Call-by-reference....: Handle ppVA pointed to new VACB.
 *    Function return value: OK if operation succeeded, ERROR otherwise.
 *                           If ERROR, "Astat" holds the precise error code.
 *-2*/Sat Feb 21 10:26:55 CET 2026
CCITT CRC (REVERSE) for     va.c   is	[2555]

/*+2 MODULE VA.C ===========================================================*/
/*   NAME   03                     eVAIdxOpen                               */
/*== SYNOPSIS ==============================================================*/
PUBLIC    eRetType
eVAIdxOpen(ppVA, pzIdxFile, pzAccess)
    VACB     *ppVA;	   /* Handle for VA index descr.struct to open */
    char     *pzIdxFile;   /* Name of physical Virtual Array index (file) */
    char     *pzAccess;	   /* Mode "rb" (ReadOnly) or "w+b" (ReadWrite) */
{
/* DESCRIPTION
 *    Opens an already existing VirtualArray file in the current directory
 *    on disk with the name of "pzIdxFile" and mode "pzAccess".
 *    Allocates an incore VA descr.struct. (VACB), initializes this with
 *    sizeinfo from the VA-file header and points handle ppVA to the VACB.
 *
 *    1: Call pVAopen() to set up a default incore VACB (save handle in ppVA).
 *    2: Correct template for empty VA-rec in VACB to : EMPTY.
 *       (the general/default empty VA-rec. template is : "all spaces")
 *
 * RETURN
 *    Side effects.........: VA-file opened & incore VACB instantiated.
 *    Call-by-reference....: Handle ppVA pointed to new VACB.
 *    Function return value: OK if operation succeeded, ERROR otherwise.
 *                           If ERROR, "Astat" holds the precise error code.
 *-2*/Sat Feb 21 10:26:55 CET 2026
CCITT CRC (REVERSE) for     va.c   is	[2555]

/*+2 MODULE VA.C ===========================================================*/
/*   NAME   04                     eVAIdxClose                              */
/*== SYNOPSIS ==============================================================*/
PUBLIC    eRetType
eVAIdxClose(ppVA)
    VACB     *ppVA;	       /* Handle for VA index descr.struct to open */
{
/* DESCRIPTION
 *   Closes an open VA file, and releases the resources allocated for the
 *   attached "in core" VA descriptor structure (VACB) pointed to by *ppVA.
 *
 *   1: Calls the generic VA function iVAclose() to perform the shutdown.
 *
 * RETURN
 *    Side effects.........: VA cache buffer flushed (if VA opened mode RW).
 *                           VirtualArray file (*ppVA)->pfArFile closed.
 *    Call-by-reference....: *ppVA VA descr.struct. fully deallocated.
 *    Function return value: OK if operation succeeded, ERROR otherwise.
 *                           If ERROR, "Astat" holds the precise error code.
 *-2*/Sat Feb 21 10:26:55 CET 2026
CCITT CRC (REVERSE) for     va.c   is	[2555]

/*+2 MODULE VA.C ===========================================================*/
/*   NAME   05                     eVAKeyInsert                             */
/*== SYNOPSIS ==============================================================*/
PUBLIC    eRetType
eVAKeyInsert(ppVA, pcKey, dwDatOffset)
    VACB     *ppVA;	       /* Handle for VA index descr.struct */
    char     *pcKey;           /* Key-string (index/slot) for VirtualArray */  
    DWORD     dwDatOffset;     /* Value to insert in VA-slot: VA[Key] */
{
/* DESCRIPTION
 *   Inserts value "dwDatOffset" into the VirtualArray, slot VA[Key]; -
 *   String "pcKey" holds a unique Key-value identifying a datafile-record,
 *   Number dwDatOffset holds the file-offset of the rec. corresp. to pcKey.
 *   The function inserts the value "dwDatOffset" into VA-slot: VA[Key].
 *
 *   1: CONVERT Key from string (pcKey) to number (dwKey) format.
 *   2: ASSERT that slot VA[Key] -if it exists- is not already occupied;
 *      If Key > VA-max, VA is extended with free slots until & incl. Key.
 *      The unique value: EMPTY marks a free/new slot in the VirtualArray.
 *   3: INSERT value "dwDatOffset" into the VirtualArray, slot VA[Key]; -
 *      Duplicate keys are obviously not allowed (Key<->VAslot 1:1 relation).
 *   4: UPDATE VA header with new "used count" (incr. #used slots).
 *
 * RETURN
 *    Side effects.........: dwDatOffset inserted into VA-slot VA[Key]; -
 *                           VA-file extended with free slots if past EOF.
 *                           VACB & VA-file header size-info updated.
 *    Function return value: OK if operation succeeded, ERROR otherwise.
 *                           If ERROR, "Astat" holds the precise error code.
 *-2*/Sat Feb 21 10:26:55 CET 2026
CCITT CRC (REVERSE) for     va.c   is	[2555]

/*+2 MODULE VA.C ===========================================================*/
/*   NAME   06                     eVAKeyDelete                             */
/*== SYNOPSIS ==============================================================*/
PUBLIC    eRetType
eVAKeyDelete(ppVA, pcKey)
    VACB     *ppVA;	       /* Handle for VA index descr.struct */
    char     *pcKey;           /* Key-string (index/slot) for VirtualArray */  
{
/* DESCRIPTION
 *   Inserts a "free-mark" into the VirtualArray, slot VA[Key]; -
 *   String "pcKey" holds a unique Key-value identifying a datafile-record,
 *   Const. EMPTY is a unique value used for marking a free VA-slot.
 *   The function inserts EMPTY into VA-slot: VA[Key], thus deleting it.
 *
 *   1: CONVERT Key from string (pcKey) to number (dwKey) format.
 *   2: ASSERT that slot VA[Key] exists and is currently occupied,
 *      (unique value: EMPTY marks a free slot in the VirtualArray).
 *   3: INSERT value EMPTY (ie. deleted/free) into VA, slot VA[Key].
 *   4: UPDATE VA header with new "used count" (decr. #used slots).
 *
 * RETURN
 *    Side effects.........: VA-slot VA[Key] marked deleted/free; -
 *                           VACB & VA-file header size-info updated.
 *    Function return value: OK if operation succeeded, ERROR otherwise.
 *                           If ERROR, "Astat" holds the precise error code.
 *-2*/Sat Feb 21 10:26:55 CET 2026
CCITT CRC (REVERSE) for     va.c   is	[2555]

/*+2 MODULE VA.C ===========================================================*/
/*   NAME   07                     eVAKeyFind                               */
/*== SYNOPSIS ==============================================================*/
PUBLIC    eRetType
eVAKeyFind(ppVA, pcKey, pdwDatOffset)
    VACB     *ppVA;	       /* Handle for VA index descr.struct */
    char     *pcKey;           /* Key-string (index/slot) for VirtualArray */  
    DWORD    *pdwDatOffset;    /* Value to retrieve from VA-slot: VA[Key] */
{
/* DESCRIPTION
 *   Finds VA-slot VA[Key], and reads it's value into var.param *pdwDatOffset.
 *   String "pcKey" holds a unique Key-value identifying a datafile-record,
 *   Ptr. "pdwDatOffset" points to a variable for returning an offset value.
 *   The function read the value in VA[KEY], and assigns it to *pdwDatOffset.
 *
 *   1: CONVERT Key from string (pcKey) to number (dwKey) format.
 *   2: ASSERT that slot VA[Key] exists (ie. Key is inside current VA range).
 *   3: RETRIEVE value (ie. datafile-offset) from VA slot: VA[Key]; -
 *         If    VA-file opened mode RW , flush cache entry before read,
 *         Else (VA-file opened mode RO), just overwrite cache entry.
 *
 * RETURN
 *    Call-by-reference....: Offset of datarecord identified by Key
 *                           returned in var.param. *pdwDatOffset.
 *    Function return value: OK if operation succeeded, ERROR otherwise.
 *                           If ERROR, "Astat" holds the precise error code.
 *                           (eg. attempt to find a free/deleted key-record)
 *-2*/Sat Feb 21 10:26:55 CET 2026
CCITT CRC (REVERSE) for     va.c   is	[2555]

/*+2 MODULE VA.C ===========================================================*/
/*   NAME   08                     eVAIdxGetSize                            */
/*== SYNOPSIS ==============================================================*/
PUBLIC    eRetType
eVAIdxGetSize(ppVA, pdwSize, pdwUsed)
    VACB     *ppVA;	       /* Handle for VA index descr.struct (VACB) */
    DWORD    *pdwSize;	       /* Ptr. to variable for returning size */
    DWORD    *pdwUsed;	       /* Ptr. to variable for returning used */
{
/* DESCRIPTION
 *    Retrieve current size (total #VA-slots) & usage (used #VA-slots)
 *    from "incore" VA descriptor struct. (VACB) to var. parameters.
 *
 *    1: RETRIEVE array-size & -usage from "incore" VACB with handle ppVA.
 *    2: ASSERT sensible values of size and used variables.
 *
 * RETURN
 *    Call-by-reference....: VA-size & used returned in *pdwSize & *pdwUsed.
 *    Function return value: OK if operation succeeded, ERROR otherwise.
 *                           If ERROR, "Astat" holds the precise error code.
 *-2*/Sat Feb 21 10:26:55 CET 2026
CCITT CRC (REVERSE) for     va.c   is	[2555]

/*+2 MODULE VA.C ===========================================================*/
/*   NAME   09                     eVAIdxGetLoad                            */
/*== SYNOPSIS ==============================================================*/
PUBLIC    eRetType
eVAIdxGetLoad(ppVA, pwLoad)
    VACB     *ppVA;	       /* Handle for VA index descr.struct (VACB) */
    WORD     *pwLoad;	       /* Var. Param for ret. load = 100 * used/size */
{
/* DESCRIPTION
 *    Retrieve current size (total #VA-slots) & usage (used #VA-slots)
 *    from "incore" VA descriptor struct. (VACB), and use these values 
 *    to calculate the current VA load-factor = (100 * used)/total.
 *
 *    1: RETRIEVE array-size & -used from incore VACB (call eVAIdxGetSize()).
 *    2: ASSERT positive value of size (thus preventing divide-by-zero error).
 *    3: CALCULATE the VA load-factor from size & used.
 *
 * RETURN
 *    Call-by-reference....: VA-load factor returned in *pwLoad.
 *    Function return value: OK if operation succeeded, ERROR otherwise.
 *                           If ERROR, "Astat" holds the precise error code.
 *-2*/Sat Feb 21 10:26:55 CET 2026
CCITT CRC (REVERSE) for     va.c   is	[2555]

/*+2 MODULE VA.C ===========================================================*/
/*   NAME   10                     iVAinit                                  */
/*== SYNOPSIS ==============================================================*/
PUBLIC int
iVAinit(pzIdxFile, wElSize, iFill)
char   *pzIdxFile;     /* Name of physical Virtual Array (file) */
WORD   wElSize;	       /* Size (#byte) of one record in VA file */
int    iFill;          /* Filler-char for initializing empty slot */
{
/* DESCRIPTION
 *    Create a VirtualArray-index file in the current directory on disk
 *    with the name of <pzIdxFile> and an record-size of <wElSize>:
 *
 *    1: Check that VA file does not already exist (bail out if it does!)
 *    2: Create new VA file :
 *       2.1: OPEN new VA file, mode <w+b> (create/truncate).
 *       2.2: WRITE a VA header (for empty VirtualArray) to the file.
 *       2.3: CLOSE the VA file.
 *
 * RETURN
 *    Side effects.........: VA-file created, header-rec written, file closed.
 *    Function return value: 1 if operation succeeded, 0 otherwise.
 *-2*/Sat Feb 21 10:26:55 CET 2026
CCITT CRC (REVERSE) for     va.c   is	[2555]

/*+2 MODULE VA.C ===========================================================*/
/*   NAME   11                     pVAopen                                  */
/*== SYNOPSIS ==============================================================*/
PUBLIC    VACB
pVAopen(pzIdxFile, pzAccess)
    char     *pzIdxFile;    /* Name of physical Virtual Array index (file) */
    char     *pzAccess;     /* "rb" (for ReadOnly) or "w+b" (for ReadWrite) */
{
/* DESCRIPTION
 *    Open an existing VirtualArray (VA) file & set up an incore descriptor:
 *
 *    1:   Instantiate an "incore" VA descriptor structure (VACB) :
 *         1.2: Allocate "incore" VACB, and point pVA to it.
 *         1.2: Open the (existing) VA file <pzIdxFile>, mode <pzAccess>.
 *         1.3: Initialize the "incore" VACB from the VA file header.
 *    2:   Instantiate a VA cache-buffer for the new VACB :
 *         2.1: Allocate a VA cache buffer, size BFSIZE.
 *         2.2: Set up last buf-rec as a blank (using fill-char from VA hdr).
 *         2.3: Initialize buf-rec index negative (=empty) for all elements.
 *
 * RETURN (2.4)
 *    Side effects.........: VA-file opened & VACB w/cache buffer instantiated.
 *    Function return value: Ptr to instantiated VA descr., - NULL if error.
 *-2*/Sat Feb 21 10:26:55 CET 2026
CCITT CRC (REVERSE) for     va.c   is	[2555]

/*+2 MODULE VA.C ===========================================================*/
/*   NAME   12                     iVAclose                                 */
/*== SYNOPSIS ==============================================================*/
PUBLIC int
iVAclose(pVA)
    VACB      pVA;       /* Ptr to "incore" VA descriptor structure (VACB) */
{
/* DESCRIPTION
 *    Close an existing VirtualArray (VA) file & release the incore descriptor:
 *
 *    1: If VA file opened mode Read/Write, flush VA cache buffer to disk.
 *       1.1: Point to first VA cache record.
 *       1.2: LOOP: flush all occupied VA cache records to disk.
 *    2: Release all resources allocated to the VACB descriptor structure.
 *
 * RETURN
 *    Side effects.........: VA cache flushed (if mode RW); VACB released.
 *    Function return value: 1 if operation succeeded, 0 otherwise.
 *-2*/Sat Feb 21 10:26:55 CET 2026
CCITT CRC (REVERSE) for     va.c   is	[2555]

/*+2 MODULE VA.C ===========================================================*/
/*   NAME   13                     pvVAaccess                               */
/*== SYNOPSIS ==============================================================*/
PRIVATE void     *
pvVAaccess(pVA, dwArIndex)
    VACB      pVA;	            /* Pointer to VA-Control-Block struct */
    DWORD     dwArIndex;	    /* Index in VA for record to access */
{
/* DESCRIPTION
 *    Access (Read / Write) a record in the virtual array (VA) :
 *
 *    1:   Calc. cache buffer address (circular wrap) of VA rec# : "dwArIndex".
 *    2:   Retrieve current rec# in calculated cache buffer entry (1. field).
 *    3:   Test VA rec# "dwArIndex" against current rec# in the cache buffer :
 *         3.1: If VA-rec present, return address of rec. contents (2. field),
 *         3.2: else If past EOF of VA, create new element(s): extend VA file,
 *         3.3: else If buffer slot occupied by other rec., flush to disk.
 *    4:   Now read VA record "dwArIndex" from file to cache buffer, and
 *         Return address of rec. contents (2. field of cache buffer entry).
 *
 * RETURN
 *    Side effects.........: VA-file silently extended, if dwArIndex past EOF.
 *    Call-by-reference....: VACB (handle pVA) updated with new sizeinfo.
 *    Function return value: Pointer to record content (in cache-buffer), -
 *                           NULL if error (disk full et. al.)
 *-2*/Sat Feb 21 10:26:55 CET 2026
CCITT CRC (REVERSE) for     va.c   is	[2555]

/*+2 MODULE VA.C ===========================================================*/
/*   NAME   14                     pvVAread                                 */
/*== SYNOPSIS ==============================================================*/
PRIVATE void     *
pvVAread(pVA, dwArIndex)
    VACB      pVA;	            /* Pointer to VA-Control-Block struct */
    DWORD     dwArIndex;	    /* Index in VA for record to read */
{
/* DESCRIPTION
 *    Read a record in the virtual array (VA) :
 *
 *    0:   Check VA index out-of-range; If yes, return NULL-ptr (can't read).
 *    1:   Calc. cache buffer address (circular wrap) of VA rec# : "dwArIndex".
 *    2:   Retrieve current rec# in calculated cache buffer entry (1. field).
 *    3:   Test VA rec# "dwArIndex" against current rec# in the cache buffer :
 *         3.1: If VA-rec present, return address of rec. contents (2. field),
 *         3.2: If buffer slot occupied by other elem, simply read new elem &
 *              Return address of rec. contents (2. field of cache buf.entry).
 * RETURN
 *    Function return value: Pointer to record content (in cache-buffer), -
 *                           NULL if error (index out-of-range).
 *-2*/Sat Feb 21 10:26:55 CET 2026
CCITT CRC (REVERSE) for     va.c   is	[2555]






END EXTRACTION

